<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>八股文更新 | 过去的过去是过往，未来的未来是遥不可及</title><meta name="author" content="梦境引导者"><meta name="copyright" content="梦境引导者"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java1、什么是 Java 内部类？ 内部类的分类有哪些 ？内部类有哪些优点和应用场景？内部类是指定义在另⼀个类内部的类，它可以访问外部类的成员变量和⽅法。 内部类的分类有以下⼏种：   成员内部类：定义在类内部，但在⽅法外部的类。它可以访问外部类的所有成员变量和⽅法；   静态内部类：定义在类内部，但使⽤ static 修饰的类。它只能访问外部类的静态成员变量和⽅法；   局部内部类：定义在⽅">
<meta property="og:type" content="article">
<meta property="og:title" content="八股文更新">
<meta property="og:url" content="http://example.com/2025/01/26/JOB-md/index.html">
<meta property="og:site_name" content="过去的过去是过往，未来的未来是遥不可及">
<meta property="og:description" content="Java1、什么是 Java 内部类？ 内部类的分类有哪些 ？内部类有哪些优点和应用场景？内部类是指定义在另⼀个类内部的类，它可以访问外部类的成员变量和⽅法。 内部类的分类有以下⼏种：   成员内部类：定义在类内部，但在⽅法外部的类。它可以访问外部类的所有成员变量和⽅法；   静态内部类：定义在类内部，但使⽤ static 修饰的类。它只能访问外部类的静态成员变量和⽅法；   局部内部类：定义在⽅">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/5.jpg">
<meta property="article:published_time" content="2025-01-26T08:48:54.000Z">
<meta property="article:modified_time" content="2025-01-26T13:01:29.600Z">
<meta property="article:author" content="梦境引导者">
<meta property="article:tag" content="Java_knowledge-update">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/5.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "八股文更新",
  "url": "http://example.com/2025/01/26/JOB-md/",
  "image": "http://example.com/img/5.jpg",
  "datePublished": "2025-01-26T08:48:54.000Z",
  "dateModified": "2025-01-26T13:01:29.600Z",
  "author": [
    {
      "@type": "Person",
      "name": "梦境引导者",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/2025/01/26/JOB-md/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '八股文更新',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw /img/说说.png"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-link"></i><span> 友链</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://store.sorryios.com/"><span> GPT账号</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://leetcode.cn/"><span> leetcode</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/21cfbf15/"><span> 使用说明</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/5.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">过去的过去是过往，未来的未来是遥不可及</span></a><a class="nav-page-title" href="/"><span class="site-name">八股文更新</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw /img/说说.png"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-link"></i><span> 友链</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://store.sorryios.com/"><span> GPT账号</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://leetcode.cn/"><span> leetcode</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://butterfly.js.org/posts/21cfbf15/"><span> 使用说明</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">八股文更新</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-01-26T08:48:54.000Z" title="发表于 2025-01-26 16:48:54">2025-01-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-01-26T13:01:29.600Z" title="更新于 2025-01-26 21:01:29">2025-01-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Coding/">Coding</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">66.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>214分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="1、什么是-Java-内部类？-内部类的分类有哪些-？内部类有哪些优点和应用场景？"><a href="#1、什么是-Java-内部类？-内部类的分类有哪些-？内部类有哪些优点和应用场景？" class="headerlink" title="1、什么是 Java 内部类？ 内部类的分类有哪些 ？内部类有哪些优点和应用场景？"></a>1、什么是 Java 内部类？ 内部类的分类有哪些 ？内部类有哪些优点和应用场景？</h2><p>内部类是指定义在另⼀个类内部的类，它可以访问外部类的成员变量和⽅法。</p>
<p>内部类的分类有以下⼏种： </p>
<ul>
<li><p>成员内部类：定义在类内部，但在⽅法外部的类。它可以访问外部类的所有成员变量和⽅法； </p>
</li>
<li><p>静态内部类：定义在类内部，但使⽤ static 修饰的类。它只能访问外部类的静态成员变量和⽅法； </p>
</li>
<li><p>局部内部类：定义在⽅法内部的类。它只能访问⽅法内部的<strong>final 变量和⽅法参数</strong>； </p>
</li>
<li><p>匿名内部类：没有类名的内部类，通常⽤于创建只需要使⽤⼀次的类。</p>
</li>
</ul>
<p>内部类的合理使⽤存在以下优点： </p>
<ul>
<li><p>通过内部类变相地实现多继承，使得⼀个类可以<strong>假性继承</strong>多个⽗类； </p>
</li>
<li><p>内部类可以隐藏实现细节，从⽽简化代码的编写； </p>
</li>
<li><p>内部类可以访问外部类的私有成员变量和⽅法，从⽽增加了程序的灵活性和安全性。</p>
</li>
</ul>
<p>内部类常⻅的使⽤场景如下： </p>
<ul>
<li><p>可⽤于实现<strong>回调函数</strong>提供给外部类使⽤； </p>
</li>
<li><p>通过内部类中定义静态成员变量，利⽤内部类的加载机制，从⽽实现<strong>单例模式</strong>； </p>
</li>
<li><p>有多继承需求时可使⽤内部类实现<strong>假性多继承</strong>。</p>
<p>###单例模式：</p>
<p><strong>单例模式是指在内存中只会创建且仅创建一次对象的设计模式。</strong>在程序中<strong>多次使用同一个对象且作用相同</strong>时，为了防止频繁地创建对象使得内存飙升，单例模式可以让程序仅在内存中<strong>创建一个对象</strong>，让所有需要调用的地方都共享这一单例对象。</p>
<ul>
<li><p>懒汉式：在<strong>真正需要使用</strong>对象时才去创建该单例类对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonDemo2</span> &#123;</span><br><span class="line">    <span class="comment">//私有化构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonDemo2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//只提供一个实例，并不创建对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo2 instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供公共的获取方法,因为不是在类加载时就创建对象，因此存在线程安全问题，使用synchronized关键字保证线程安全，效率降低</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingletonDemo2 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">SingletonDemo2</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>饿汉式：在<strong>类加载</strong>时已经创建好该单例对象，等待被程序使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>DCL懒汉式（双重检测锁模式）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton; </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;  <span class="comment">// 线程A和线程B同时看到singleton = null，如果不为null，则直接返回singleton</span></span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123; <span class="comment">// 线程A或线程B获得该锁进行初始化</span></span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123; <span class="comment">// 其中一个线程进入该分支，另外一个线程则不会进入该分支</span></span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>静态内部类单例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态内部类实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonDemo4</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonDemo4</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不会在外部类初始化时就直接加载，只有当调用了getInstance方法时才会静态加载，线程安全，final保证了在内存中只有一份</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SingletonDemo4</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonDemo4</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo4 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> InnerClass.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>枚举单例（防止反射，序列化）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//枚举方式实现单例模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SingletonDemo5</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo5 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>线程池：<strong>可以使⽤单例模式来确保系统中只有⼀个线程池。</strong></p>
<h2 id="2、什么是反射机制？说说反射机制的优缺点、应⽤场景？"><a href="#2、什么是反射机制？说说反射机制的优缺点、应⽤场景？" class="headerlink" title="2、什么是反射机制？说说反射机制的优缺点、应⽤场景？"></a>2、什么是反射机制？说说反射机制的优缺点、应⽤场景？</h2><p>在Java 程序中，**<code>JVM</code> 加载完一个类后，在<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%A0%86%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">堆内存</a>中就会产生该类的一个 <code>Class</code> 对象，一个类在堆内存中最多只会有一个 <code>Class</code> 对象<strong>，这个<code>Class</code> 对象包含了该类的</strong>完整结构信息<strong>，我们通过这个 <code>Class</code> 对象便可以得到该类的</strong>完整结构信息<strong>。因此，我们形象的将获取<code>Class</code>对象的过程称为：</strong>反射**。</p>
<p>反射就是 Reflection，Java 的反射是<strong>指程序在运⾏期可以拿到⼀个对象的所有信息</strong>。 正常情况下，如果我们要调⽤⼀个对象的⽅法，或者访问⼀个对象的字段，通常会传⼊对象实例</p>
<p>优点: </p>
<p>➢可以实现<strong>动态创建对象和编译</strong>，体现出很⼤的灵活性 </p>
<p>缺点: </p>
<p>➢对性能有影响。使⽤反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满⾜我们的要求。这类操作总是慢于直接执⾏相同的操作。</p>
<p>应用场景：</p>
<p>➢在运⾏时<strong>判断任意⼀个对象所属的类</strong> </p>
<p>➢在运⾏时<strong>构造任意⼀个类的对象</strong> </p>
<p>➢在运⾏时判断任意⼀个类所具有的成员变量和⽅法 </p>
<p>➢在<strong>运⾏时获取泛型信息</strong> </p>
<p>➢在运⾏时调⽤任意⼀个对象的成员变量和⽅法 </p>
<p>➢<strong>在运⾏时处理注解</strong> </p>
<p>➢⽣成<strong>动态代理</strong>（动态代理，因为不确定需要代理的类，所以需要通过反射动态的获取）</p>
<p>➢<strong>RPC 框架</strong>，RPC 框架就是动态的⽣成类对象，然后调⽤⽅法的。</p>
<h2 id="3、说说-Java-中多态实现原理"><a href="#3、说说-Java-中多态实现原理" class="headerlink" title="3、说说 Java 中多态实现原理"></a>3、说说 Java 中多态实现原理</h2><p>多态机制包括静态多态（编译时多态）和动态多态（运行时多态） </p>
<p><strong>编译时多态（静态多态）</strong>：通过<strong>方法重载</strong>（Method Overloading）实现。方法重载是在编译时决定的，不涉及运行时的动态行为。</p>
<p><strong>运行时多态（动态多态）</strong>：通过<strong>方法重写</strong>（Method Overriding）实现。动态多态是在运行时通过<strong>动态绑定</strong>来决定调用哪个方法。</p>
<h3 id="多态的优势"><a href="#多态的优势" class="headerlink" title="多态的优势"></a><strong>多态的优势</strong></h3><ul>
<li><strong>代码可扩展性</strong>：通过父类引用来指向不同子类的实例，增加了代码的灵活性和扩展性。</li>
<li><strong>可维护性</strong>：多态允许修改程序而不影响已有代码，通过继承和方法重写可以很方便地对现有代码进行扩展。</li>
<li><strong>可读性</strong>：多态性简化了代码，通过使用统一的接口调用，不需要关心具体对象的类型。</li>
</ul>
<p>##线程安全</p>
<p><strong>当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。</strong></p>
<h4 id="多线程编程中的三个核心概念-原子性，可见性，有序性"><a href="#多线程编程中的三个核心概念-原子性，可见性，有序性" class="headerlink" title="多线程编程中的三个核心概念:原子性，可见性，有序性"></a>多线程编程中的三个核心概念:原子性，可见性，有序性</h4><h4 id="如何实现线程安全"><a href="#如何实现线程安全" class="headerlink" title="如何实现线程安全"></a>如何实现线程安全</h4><ul>
<li><p>第一种 : <strong>互斥同步</strong></p>
<p>1.普通同步方法，锁是当前实例对象<br>2.静态同步方法，锁是当前类的Class对象<br>3.同步方法块，锁是Synchronized括号里匹配的对象</p>
</li>
<li><p>第二种方法就是：<strong>非阻塞同步</strong></p>
</li>
</ul>
<p>CAS是实现非阻塞同步的计算机指令，它有三个操作数：内存位置，旧的预期值，新值，在执行CAS操作时，当且仅当内存地址的值符合旧的预期值的时候，才会用新值来更新内存地址的值，否则就不执行更新。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">使用方法：使用JUC包下的整数原子类AtomicInteger </span><br></pre></td></tr></table></figure>

<ul>
<li>第三种：<strong>无同步方案</strong></li>
</ul>
<p>线程本地存储：将共享数据的可见范围限制在一个线程中。这样无需同步也能保证线程之间不出现数据争用问题。</p>
<p>经常使用的就是ThreadLocal类</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20241019180658796-173788154339560.png" alt="image-20241019180658796" style="zoom:50%;" />

<p>##泛型</p>
<p>1、泛型的本质是为了将<strong>类型参数化</strong>，在泛型使用过程中，数据类型被设置为一个参数，从外部传入一个数据和数据类型不匹配，编译器报错</p>
<p>2、Object使得取出类型不知道是啥，未传入指定类型会以object存在</p>
<p>3、可读性、通用性</p>
<p>4、代码复用</p>
<p>注意：</p>
<p>1、<strong>泛型类中的静态方法和静态变量不可以使用泛型类所声明的类型参数</strong></p>
<p><strong>位置：</strong></p>
<p>1.非静态的成员属性类型<br>2.非静态方法的形参类型（包括非静态成员方法和构造器）<br>3.非静态的成员方法的返回值类型</p>
<p> <strong>存储方式：</strong></p>
<p>泛型擦除</p>
<p>##git</p>
<h3 id="查看当前分支的情况"><a href="#查看当前分支的情况" class="headerlink" title="查看当前分支的情况"></a>查看当前分支的情况</h3><p>git status</p>
<h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><p><code>git branch &lt;分支名&gt;</code> 创建分支。</p>
<p><code>git checkout &lt;分支名&gt;</code> 切换到该分支。</p>
<h3 id="查看本地分支和远程分支对应关系"><a href="#查看本地分支和远程分支对应关系" class="headerlink" title="查看本地分支和远程分支对应关系"></a>查看本地分支和远程分支对应关系</h3><p>git branch -vv</p>
<h3 id="撤回修改"><a href="#撤回修改" class="headerlink" title="撤回修改"></a>撤回修改</h3><p>git checkout .  已经修改了文件，但还没有运行 <code>git add</code> 命令将这些更改添加到暂存区，那么 <code>git checkout .</code> 会丢弃这些更改，将文件恢复到最后一次提交的状态</p>
<h3 id="创建远程分支并push"><a href="#创建远程分支并push" class="headerlink" title="创建远程分支并push"></a>创建远程分支并push</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push -u origin new-branch：origin 是克隆的远程仓库的默认名称，-u是未设置的情况下进行设置</span><br></pre></td></tr></table></figure>

<h3 id="拉取当前分支的最新代码"><a href="#拉取当前分支的最新代码" class="headerlink" title="拉取当前分支的最新代码"></a>拉取当前分支的最新代码</h3><p>git pull origin &lt;分支名&gt;</p>
<p>###推送到远程仓库</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 将文件添加到暂存区</span><br><span class="line">git add &lt;文件名&gt;  # 添加单个文件</span><br><span class="line">git add .        # 添加所有修改的文件</span><br><span class="line"></span><br><span class="line"># 提交更改到本地仓库</span><br><span class="line">git commit -m <span class="string">&quot;提交信息&quot;</span></span><br><span class="line"></span><br><span class="line">git push origin &lt;分支名&gt;    </span><br></pre></td></tr></table></figure>

<p>##springboot</p>
<p><strong>Spring</strong>：一个强大的<strong>依赖注入框架</strong>，<strong>用于管理对象生命周期、配置和依赖。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20241027190107863-173788154339662.png" alt="image-20241027190107863"></p>
<p><strong>Spring MVC</strong>：基于 Spring 的 MVC 架构，<strong>用于处理 Web 请求和视图逻辑的控制器层</strong></p>
<p><strong>MyBatis</strong>：一个 ORM（对象关系映射）框架，<strong>用于持久层操作，通过 SQL 查询操作数据库。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20241027192055402-173788154339661.png" alt="image-20241027192055402"></p>
<p><strong>Spring Boot 是 Spring 框架的一个子项目，旨在简化 Spring 应用的开发。</strong>它集成了 Spring 框架的核心模块，自动配置很多默认的组件，并提供嵌入式服务器，使开发者可以快速构建独立运行的 Spring 应用。</p>
<table>
<thead>
<tr>
<th>特点</th>
<th>SSM (Spring + Spring MVC + MyBatis)</th>
<th>Spring Boot</th>
</tr>
</thead>
<tbody><tr>
<td><strong>配置复杂度</strong></td>
<td>手动配置多，XML 配置繁琐</td>
<td>自动配置，几乎无需手动配置</td>
</tr>
<tr>
<td><strong>启动与运行</strong></td>
<td>需要外部服务器（Tomcat 等）</td>
<td>嵌入式服务器，JAR 文件即可运行</td>
</tr>
<tr>
<td><strong>依赖管理</strong></td>
<td>手动管理依赖版本，配置复杂</td>
<td><code>starter</code> 依赖简化依赖管理，自动处理兼容性</td>
</tr>
<tr>
<td><strong>开发效率</strong></td>
<td>配置工作量大，学习曲线陡峭</td>
<td>开发体验友好，快速开发</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>企业级项目，需定制配置较多的场景</td>
<td>快速开发，适合微服务和中小型项目</td>
</tr>
<tr>
<td><strong>灵活性</strong></td>
<td>更灵活，可以定制更多配置</td>
<td>灵活性较低，但可以通过配置自定义</td>
</tr>
</tbody></table>
<h3 id="常见的-starter-组件"><a href="#常见的-starter-组件" class="headerlink" title="常见的 starter 组件"></a><strong>常见的 <code>starter</code> 组件</strong></h3><ul>
<li><strong><code>spring-boot-starter</code></strong><ul>
<li>基础的 <code>starter</code>，包含启动 Spring Boot 应用所需的基本组件和依赖。它是所有 Spring Boot 项目的核心，通常由其他 <code>starter</code> 依赖。</li>
</ul>
</li>
<li><strong><code>spring-boot-starter-web</code></strong><ul>
<li>用于构建 Web 应用的 <code>starter</code>，包含 Spring MVC、嵌入式 Tomcat（默认）、Jackson（用于 JSON 处理）等依赖。适用于构建 RESTful Web 服务和 Web 应用。</li>
<li><strong>包含</strong>：Spring MVC、Jackson、嵌入式 Tomcat、日志等。</li>
</ul>
</li>
<li><strong><code>spring-boot-starter-data-mongodb</code></strong><ul>
<li>用于 MongoDB 的数据访问支持，适合构建基于 NoSQL 的应用程序。</li>
<li><strong>包含</strong>：Spring Data MongoDB、MongoDB 驱动。</li>
</ul>
</li>
<li><strong><code>spring-boot-starter-test</code></strong><ul>
<li>为应用程序提供测试支持，包含 JUnit、Mockito、Spring Test 等常用测试框架。</li>
<li><strong>包含</strong>：JUnit、Spring Test、Mockito、AssertJ 等。</li>
</ul>
</li>
<li><strong><code>spring-boot-starter-thymeleaf</code></strong><ul>
<li>用于集成 Thymeleaf 模板引擎，支持服务器端渲染 HTML。</li>
<li><strong>包含</strong>：Thymeleaf 和其整合包。</li>
</ul>
</li>
<li><strong><code>spring-boot-starter-log4j2</code></strong><ul>
<li>集成 Log4j2 日志框架，用于替代默认的日志框架（Logback）。</li>
<li><strong>包含</strong>：Log4j2 相关依赖。</li>
</ul>
</li>
<li><strong><code>spring-boot-starter-logging</code></strong><ul>
<li>默认的日志 <code>starter</code>，内置了 Logback 和 SLF4J 日志支持，几乎所有项目都会默认包含这个。</li>
<li><strong>包含</strong>：Logback、SLF4J。</li>
</ul>
</li>
</ul>
<p><strong>其他功能性 <code>starter</code> 组件</strong></p>
<ul>
<li><strong><code>spring-boot-starter-amqp</code></strong><ul>
<li>提供对 AMQP 协议（如 RabbitMQ）的支持，适合消息驱动的应用。</li>
<li><strong>包含</strong>：Spring AMQP、RabbitMQ 客户端。</li>
</ul>
</li>
<li><strong><code>spring-boot-starter-cloud-connectors</code></strong><ul>
<li>适合与云服务交互，特别是在 PaaS 环境中自动检测并连接数据库、消息中间件等。</li>
<li><strong>包含</strong>：Spring Cloud Connectors。</li>
</ul>
</li>
</ul>
<h3 id="Spring-IOC"><a href="#Spring-IOC" class="headerlink" title="Spring IOC"></a>Spring IOC</h3><p>传统的对象管理方式中，对象的依赖关系通常是通过类内部手动创建（例如通过 <code>new</code> 关键字）。这种方式会导致类与类之间高度耦合，使得代码不够灵活、难以测试和维护。而通过 IOC，控制权从应用程序转移到了外部的 IOC 容器，依赖关系由容器来处理和注入。</p>
<p><strong>IOC 的工作原理</strong>：</p>
<ul>
<li><p><strong>控制反转</strong>：对象的依赖由容器负责创建和注入，而不是对象自己去管理。</p>
</li>
<li><p><strong>依赖注入（DI, Dependency Injection）</strong>：IOC 的具体实现方式之一。Spring 框架通过依赖注入的方式，将对象的依赖关系注入到对象中。</p>
<p>1、构造器注入</p>
<p>2、setter方法注入</p>
<p>3、字段注入</p>
</li>
</ul>
<p><strong>两种常见的 IOC 容器:</strong></p>
<p><strong>BeanFactory</strong>：</p>
<ul>
<li>是 Spring 中最基础的 IOC 容器。</li>
<li>以<strong>延迟初始化</strong>为主，只有在<strong>请求 Bean 时才会创建它</strong>。</li>
<li>适合<strong>资源有限的环境</strong>或简单的应用。</li>
</ul>
<p><strong>ApplicationContext</strong>：</p>
<ul>
<li>是 <strong>BeanFactory 的子接口</strong>，功能更加丰富。</li>
<li><strong>支持更高级的特性</strong>，例如事件发布、国际化、AOP 等。</li>
<li>ApplicationContext <strong>容器会在启动时创建并初始化所有的 Bean（默认是单例模式的 Bean）</strong>。</li>
<li>常见的实现类包括 <code>ClassPathXmlApplicationContext</code> 和 <code>AnnotationConfigApplicationContext</code>。</li>
</ul>
<h3 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h3><p><strong>1、干什么</strong>：<strong>Spring AOP</strong> 是 Spring 框架中提供的面向切面编程的功能，用于在不改变业务逻辑代码的情况下，通过“切面”对程序的各个模块进行功能增强或行为扩展。</p>
<p><strong>2、基础概念：</strong></p>
<p><strong>Aspect（切面）</strong>：</p>
<ul>
<li>切面是 AOP 的核心，它是横切关注点的模块化表现。一个切面可以看作是包含某些横切逻辑的模块，如日志记录、性能监控等。</li>
<li>切面通常由 <strong>通知</strong>（Advice）和 <strong>切入点</strong>（Pointcut）组成。</li>
</ul>
<p><strong>Advice（通知）</strong>：</p>
<ul>
<li>通知定义了切面中的具体增强行为（如日志记录或事务管理）。Spring AOP 提供了多种类型的通知，它们会在方法执行的不同阶段被调用。</li>
<li>通知类型有：<ul>
<li><strong>前置通知（Before Advice）</strong>：在目标方法执行前执行的通知。</li>
<li><strong>后置通知（After Advice）</strong>：在目标方法执行后执行的通知（无论方法是否成功执行）。</li>
<li><strong>返回通知（After Returning Advice）</strong>：在目标方法成功返回结果后执行的通知。</li>
<li><strong>异常通知（After Throwing Advice）</strong>：在目标方法抛出异常后执行的通知。</li>
<li><strong>环绕通知（Around Advice）</strong>：在目标方法执行前后都可以执行的通知。环绕通知是功能最强的通知类型，因为它可以完全控制方法的执行。</li>
</ul>
</li>
</ul>
<p><strong>Pointcut（切入点）</strong>：</p>
<ul>
<li>切入点定义了在什么地方应用切面，即哪些方法或类会被 AOP 增强。切入点表达式用于指定哪些方法会触发增强逻辑。</li>
</ul>
<p><strong>Joinpoint（连接点）</strong>：</p>
<ul>
<li>连接点是程序执行过程中可以插入切面的特定点。通常，连接点是指方法的执行，但也可以是构造器的执行等。在 Spring AOP 中，连接点主要是指方法的执行。</li>
</ul>
<p><strong>Target Object（目标对象）</strong>：</p>
<ul>
<li>被切面增强的对象称为目标对象（也叫目标类）。</li>
</ul>
<p><strong>3、原理</strong>：</p>
<p>Spring AOP 基于 <strong>代理模式</strong> 实现。通过动态代理，Spring 能够在目标对象的方法调用之前、之后或替代方法调用的方式来执行增强的逻辑。</p>
<ul>
<li><strong>JDK 动态代理</strong>：用于基于接口的代理。目标对象必须实现接口，通过代理类拦截接口方法调用，并在方法前后织入切面逻辑。</li>
<li><strong>CGLIB 代理</strong>：用于代理没有实现接口的类。CGLIB 通过生成目标类的子类来代理方法调用。</li>
</ul>
<p>###Spring常见注解</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20241105223222632-1731414167417-173788154339663.png" alt="image-20241105223222632" style="zoom: 67%;" />

<p>MVC复合注解：@restController&#x3D;&#x3D;@Controller+@ResponseBody</p>
<h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><p>Dockerfile 的基本结构</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 指定基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> &lt;镜像名&gt;:&lt;标签&gt;</span><br><span class="line"><span class="comment"># 2. 维护者信息（可选）</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> maintainer=<span class="string">&quot;&lt;你的名字或邮箱&gt;&quot;</span></span></span><br><span class="line"><span class="comment"># 3. 设置工作目录（可选）</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="comment"># 4. 拷贝本地文件到镜像内</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> &lt;本地路径&gt; &lt;容器路径&gt;</span></span><br><span class="line"><span class="comment"># 5. 运行命令安装依赖等（每条 RUN 生成一层）</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> &lt;命令&gt;</span></span><br><span class="line"><span class="comment"># 6. 暴露端口（声明要开放的端口）</span></span><br><span class="line"><span class="keyword">EXPOSE</span> &lt;端口号&gt;</span><br><span class="line"><span class="comment"># 7. 设置环境变量（可选）</span></span><br><span class="line"><span class="keyword">ENV</span> &lt;环境变量名&gt;=&lt;值&gt;</span><br><span class="line"><span class="comment"># 8. 容器启动时执行的命令</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;可执行文件&quot;</span>, <span class="string">&quot;参数1&quot;</span>, <span class="string">&quot;参数2&quot;</span>]</span></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;可执行文件&quot;</span>, <span class="string">&quot;参数1&quot;</span>]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="completableFuture"><a href="#completableFuture" class="headerlink" title="completableFuture"></a>completableFuture</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> Object result;       <span class="comment">// Either the result or boxed AltResult</span></span><br><span class="line"><span class="keyword">volatile</span> Completion stack;    <span class="comment">// Top of Treiber stack of dependent actions  链表实现的栈，保存了所有的后续动作</span></span><br></pre></td></tr></table></figure>

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20241111113703756-173788154339664.png" alt="image-20241111113703756" style="zoom:67%;" />

<p><strong>在执行任务时，每个completablefuture都有一个completion，自身的completion会加入到前置completion的栈中，当前置栈完成任务时，会执行下一个栈中的任务。</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20241111113407472-173788154339665.png" alt="image-20241111113407472" style="zoom:50%;" />



<p>同步任务会在主线程中运行，异步任务会在线程池中运行。实际上这是不对的，参考上图。</p>
<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p><strong>RabbitMQ</strong>：A <strong>broker</strong> ，可以将消息进行投递和流式处理，易于部署在云环境、本地、本地计算机上。</p>
<p>1、可互操作：采用AMQP协议进行传输</p>
<p>2、灵活性：采用6种工作模式</p>
<p>3、可靠性：<strong>有确认消息传输和跨集群复制消息的能力</strong></p>
<p>应用场景：解耦互连服务、RPC、订阅等</p>
<p><strong>交换机类型</strong>：扇形交换机（<strong>将消息广播到消息队列中</strong>），直连交换机（<strong>将消息通过Routing Key路由到消息队列中</strong>），主题交换机（<strong>将消息通过Routing Key模糊匹配的方式路由到消息队列中</strong>）</p>
<p><strong>高可用：</strong></p>
<p>1、普通集群 </p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20241104133915645-173788154339666.png" alt="image-20241104133915645" style="zoom: 50%;" />

<p>2、镜像集群 </p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20241104134129226-173788154339767.png" alt="image-20241104134129226" style="zoom: 50%;" />

<p>3、仲裁队列</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20241104134509105-173788154339768.png" alt="image-20241104134509105"></p>
<p>##项目</p>
<p>###Protobuf </p>
<table>
<thead>
<tr>
<th>序列化原理</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>消息结构定义</strong></td>
<td>使用 <code>.proto</code> 文件定义消息结构，每个字段都有唯一的字段编号，用编号而不是字段名称进行识别，减少数据量。</td>
</tr>
<tr>
<td><strong>字段编号和可选字段</strong></td>
<td>每个字段用唯一的数字编号标识，常用字段分配小编号以减少大小，支持可选字段，不存在的字段不占用空间。</td>
</tr>
<tr>
<td><strong>紧凑的二进制编码格式</strong></td>
<td>使用 Varint（变长编码）存储整数，较小数字占用更少字节；整型、布尔值、枚举值等使用 Varint 编码，字符串和字节先存长度，再存数据。</td>
</tr>
<tr>
<td><strong>键值对存储</strong></td>
<td>每个字段以键值对形式存储，<strong>键由字段编号和字段类型</strong>组成，<strong>值为字段数据，</strong>这种结构使得 Protobuf 序列化高效，解析迅速。</td>
</tr>
<tr>
<td><strong>向后兼容性</strong></td>
<td>新增字段不会影响旧数据格式，旧版本客户端可以忽略不识别的字段；删除字段不会影响兼容性，只要编号不重用或重新定义为不同类型。</td>
</tr>
<tr>
<td><strong>序列化过程</strong></td>
<td>根据 <code>.proto</code> 文件生成代码，<strong>将消息转换为二进制格式，使用字段编号、Varint 编码及键值对结构，将消息压缩为高效的字节序列</strong>。</td>
</tr>
<tr>
<td><strong>反序列化过程</strong></td>
<td>将二进制格式解析回对象结构，通过字段编号识别各字段并解码值。</td>
</tr>
<tr>
<td><strong>Protobuf 的优势</strong></td>
<td>体积小、解析速度快、网络传输高效，支持多语言，具有灵活性和扩展性，可保持向后兼容。</td>
</tr>
<tr>
<td><strong>示例</strong></td>
<td>例如定义 <code>Person</code> 消息 <code>&#123;id: 123, name: &quot;Alice&quot;&#125;</code>，通过字段编号及紧凑编码序列化为小体积的二进制格式，节省传输空间。</td>
</tr>
</tbody></table>
<p>原理：<strong>protobuf 使用不同的编码规则来处理不同的数据类型，如 Varint 编码用于整数、定长编码用于浮点数等。每种数据类型都有其自己的编码规则，以便在编码和解码时正确还原数据</strong></p>
<p>RPC：</p>
<h2 id="SQL调优"><a href="#SQL调优" class="headerlink" title="SQL调优"></a>SQL调优</h2><p>sql层面：</p>
<p>1、*<em>避免使用select <em>，查询不必要的字段</em></em></p>
<p>2、<strong>建立联合索引，避免回表操作</strong></p>
<p><strong>3、尽量用小表驱动大表，in关键字</strong>：SQL先执行后面的语句在执行前面的，因此可以左边写大表，右边写小表</p>
<p><strong>4、批量插入，比如一次插入500条左右的数据</strong></p>
<p><strong>5、在SQL语句前面做一些过滤操作</strong></p>
<p><strong>6、避免使用join关联多个表，考虑延迟关联</strong></p>
<p>数据库层面：</p>
<p><strong>1、字段类型，varchar(500)和char(50)</strong></p>
<p>2、读写分离、主从复制（查询操作多于写操作，不影响读操作采用读写分离操作）</p>
<p>二进制日志：DDL语句和DML语句，主库在事务提交时，会把数据变更记录在二进制文件Binlog中</p>
<p>3、分库分表（海量数据存储、IO瓶颈）</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20241118144922270-173788154339769.png" alt="image-20241118144922270" style="zoom:50%;" />

<p>4、设置数据库隔离级别</p>
<p>5、增加数据库连接池大小、查看bufferpool命中情况</p>
<p>业务层面：</p>
<p><strong>比如查询count，在一张表中耗时，可以考虑做个缓存，在MySQL重新建立一张表存储count的值，在有变化时异步更新count，或者在Redis中做个缓存，会有弱一致性的问题。</strong></p>
<p>##Nacos</p>
<h3 id="Nacos和Eureka的区别"><a href="#Nacos和Eureka的区别" class="headerlink" title="Nacos和Eureka的区别"></a>Nacos和Eureka的区别</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20241030102036801-173788154339770.png" alt="image-20241030102036801"></p>
<p>Nacos：<strong>主动检测非临时实例，检测到不会剔除，心跳检测临时实例</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20241118215705149-173788154339772.png" alt="image-20241118215705149"></p>
<h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p><strong>MySQL：3306</strong></p>
<p><strong>Redis：6379</strong></p>
<p><strong>Rabbitmq：5672</strong></p>
<p><strong>Http：80</strong></p>
<p><strong>Https：443</strong></p>
<h2 id="4、Java-中-IO-流分为几种"><a href="#4、Java-中-IO-流分为几种" class="headerlink" title="4、Java 中 IO 流分为几种?"></a>4、Java 中 IO 流分为几种?</h2><ul>
<li><p>Java 中✁流分为两种：一种✁字节流，另一种✁字符流。 </p>
</li>
<li><p>IO 流分别由四个抽象类来表示（两输入两输出）:InputStream，OutputStream，Reader，Writer</p>
</li>
</ul>
<h2 id="5、守护线程是什么？用什么方法实现守护线程"><a href="#5、守护线程是什么？用什么方法实现守护线程" class="headerlink" title="5、守护线程是什么？用什么方法实现守护线程"></a>5、守护线程是什么？用什么方法实现守护线程</h2><p>Java<strong>线程分为用户线程和守护线程</strong>。</p>
<p>守护线程是程序运行的时候在后台提供一种通用服务的线程。所有用户线程停止，进程会停掉所有守护线程，退出程序。</p>
<p>Java中把线程设置为守护线程的方法：在 start 线程之前调用线程的<strong>setDaemon(true)</strong> 方法。</p>
<p>注意：</p>
<ul>
<li>setDaemon(true) 必须在 start() 之前设置，否则会抛出IllegalThreadStateException异常，该线程仍默认为用户线程，继续执行</li>
<li>守护线程所创建的线程也是守护线程</li>
<li>守护线程<strong>不应该访问、写入持久化资源，如文件、数据库，因为它会在任何时间被停止，导致资源未释放</strong>、数据写入中断等问题。</li>
</ul>
<h2 id="6、Threadlocal"><a href="#6、Threadlocal" class="headerlink" title="6、Threadlocal"></a>6、Threadlocal</h2><p>ThreadLocal叫做<em><strong>线程变量</strong></em>，意思是ThreadLocal中<strong>填充的变量</strong>属于<strong>当前线程</strong>，该变量对其他线程而言是隔离的，也就是说该变量是当前线程独有的变量。ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。</p>
<p>ThreadLocal 变量，线程局部变量，同一个 ThreadLocal 所包含的对象，在不同的 Thread 中有不同的副本。这里有几点需要注意：</p>
<ul>
<li>因为每个 Thread 内有自己的实例副本，<strong>且该副本只能由当前 Thread</strong> 使用。</li>
<li>既然每个 Thread 有自己的实例副本，且其它 Thread 不可访问，那就<strong>不存在多线程间共享</strong>的问题。</li>
</ul>
<p>ThreadLocal 提供了线程本地的实例。它与普通变量的区别在于，每个使用该变量的线程都会初始化一个完全独立的实例副本。ThreadLocal 变量通常被private static修饰。<strong>当一个线程结束时，它所使用的所有 ThreadLocal 相对的实例副本都可被回收</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA0NDUzMDE%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-173788154339773.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; localVarA = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;String&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; localVarB = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure>

<p>ThreadLocalMap其实是Thread线程的一个属性值，而ThreadLocal是维护ThreadLocalMap这个属性指的一个工具类。<em>Thread线程可以拥有多个ThreadLocal维护的自己线程独享的共享变量</em>（这个共享变量只是针对自己线程里面共享）。</p>
<p>ThreadLocal 适用于如下两种场景：</p>
<ul>
<li>1、<strong>每个线程需要有自己单独的实例</strong></li>
<li>2、<strong>实例需要在多个方法中共享，但不希望被多线程共享</strong></li>
</ul>
<p>举例：</p>
<p>1）存储用户Session</p>
<p>2）数据库连接，处理数据库事务</p>
<p>​        注意pool.getConnection()，都是先从<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=threadlocal&spm=1001.2101.3001.7020">threadlocal</a>里面拿的，如果threadlocal里面有，则用，保证线程里的多个dao操作，用的是同一个connection，以保证事务。</p>
<p>​       如果新线程，则将新的connection放在threadlocal里，再get给到线程。</p>
<p>3）数据跨层传递（controller,service, dao）</p>
<p>4）**Spring使用ThreadLocal解决线程安全问题 **（Bean的作用域）</p>
<hr>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240520164954890-173788154339771.png" alt="image-20240520164954890"></p>
<h2 id="7、ThreadLocal与Synchronized的区别"><a href="#7、ThreadLocal与Synchronized的区别" class="headerlink" title="7、ThreadLocal与Synchronized的区别"></a>7、ThreadLocal与Synchronized的区别</h2><p>ThreadLocal<T>其实是与线程绑定的一个变量。<strong>ThreadLocal和Synchonized都用于解决多线程并发访问。</strong></p>
<p>但是ThreadLocal与synchronized有本质的区别：</p>
<p>1、<strong>Synchronized用于线程间的数据共享，而ThreadLocal则用于线程间的数据隔离。</strong></p>
<p>2、<strong>Synchronized是利用锁的机制，使变量或代码块在某一时刻只能被一个线程访问。而ThreadLocal为每一个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的数据共享。</strong></p>
<p>而Synchronized却正好相反，它<strong>用于在多个线程间通信时能够获得数据共享</strong>。</p>
<p><strong>一句话理解ThreadLocal，threadlocal是作为当前线程中属性ThreadLocalMap集合中的某一个Entry的key值Entry（threadlocal,value），虽然不同的线程之间threadlocal这个key值是一样，但是不同的线程所拥有的ThreadLocalMap是独一无二的，也就是不同的线程间同一个ThreadLocal（key）对应存储的值(value)不一样，从而到达了线程间变量隔离的目的，但是在同一个线程中这个value变量地址是一样的。</strong></p>
<h2 id="8、线程池"><a href="#8、线程池" class="headerlink" title="8、线程池"></a>8、<font color=red>线程池</font></h2><p>线程池是一种利用池化技术思想来实现的线程管理技术，主要是为了<strong>复用线程、便利地管理线程和任务、并将线程的创建和任务的执行</strong>解耦开来。我们可以创建线程池来复用<strong>已经创建的线程来降低频繁创建和销毁线程所带来的资源消耗</strong>。在JAVA中主要是使用<strong>ThreadPoolExecutor类来创建线程池</strong>，并且JDK中也提供了Executors工厂类来创建线程池（不推荐使用）。</p>
<p><font color=red><strong>线程池的优点：</strong></font></p>
<ul>
<li><strong>降低资源消耗</strong>，复用已创建的线程来降低创建和销毁线程的消耗。</li>
<li><strong>提高响应速度</strong>，任务到达时，可以不需要等待线程的创建立即执行。</li>
<li><strong>提高线程的可管理性</strong>，使用线程池能够统一的分配、调优和监控。</li>
</ul>
<p><strong>ThreadPoolExecutor的构造组成</strong></p>
<ul>
<li><strong>corePoolSize</strong>，核心线程数量，决定是否创建新的线程来处理到来的任务</li>
<li><strong>maximumPoolSize</strong>，最大线程数量，线程池中允许创建线程地最大数量&#x3D;（corePoolsize+救急线程）</li>
<li><strong>keepAliveTime</strong>，线程空闲时存活的时间</li>
<li><strong>unit</strong>，空闲存活时间单位</li>
<li><strong>workQueue</strong>，任务队列，用于存放已提交的任务。满则创建救急线程</li>
<li><strong>threadFactory</strong>，线程工厂，用于创建线程执行任务</li>
<li><strong>handler</strong>，拒绝策略，当线程池处于饱和时，使用某种策略来拒绝任务提交</li>
</ul>
<p><strong>生命周期流转</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240328092321582-173788154339774.png" alt="image-20240328092321582"></p>
<p><strong>执行流程</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/JOB-md.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDkzMjU1,size_16,color_FFFFFF,t_70#pic_center.png"></p>
<p>1）如果workerCount &lt; corePoolSize &#x3D;&#x3D;&gt; 创建线程执行提交的任务<br>2）如果workerCount &gt;&#x3D; corePoolSize &amp;&amp; 阻塞队列未满 &#x3D;&#x3D;&gt; 添加至阻塞队列，等待后续线程来执行提交地任务<br>3）如果workerCount &gt;&#x3D; corePoolSize &amp;&amp; workerCount &lt; maxinumPoolSize &amp;&amp; 阻塞队列已满 &#x3D;&#x3D;&gt; 创建非核心线程执行提交的任务<br>4）如果workerCount &gt;&#x3D; maxinumPoolSize &amp;&amp; 阻塞队列已满 &#x3D;&#x3D;&gt; 执行拒绝策略</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240520145614023-173788154339775.png" alt="image-20240520145614023"></p>
<p>【建议】不同类型的业务任务尽量使用不同的线程池</p>
<p><strong>应用场景</strong></p>
<p>1.网购商品秒杀</p>
<p>2.云盘文件上传和下载</p>
<p>3.12306网上购票系统等</p>
<p><strong>使用</strong></p>
<p>只要有并发的地方、任务数量大或小、每个任务执行时间长或短的都可以使用线程池;<br>只不过在使用线程池的时候,注意一下设置合理的线程大小即可;</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240520150653313-173788154339776.png" alt="image-20240520150653313"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240520151118373-173788154339777.png" alt="image-20240520151118373"></p>
<p>​      <strong>计算密集型的线程恰好在某时因为发生一个页错误或者因其他原因而暂停，刚好有一个“额外”的线程，可以确保在这种情况下CPU周期不会中断工作</strong></p>
<p>​      <strong>如果任务有50%的时间处于阻塞状态，则程序所需线程数为处理器可用核心数的两倍。如果任务被阻塞的时间少于50%，即这些任务是计算密集型的，则程序所需线程数将随之减少，但最少也不应低于处理器的核心数。如果任务被阻塞的时间大于执行时间，即该任务是IO密集型的，我们就需要创建比处理器核心数大几倍数量的线程。</strong></p>
<p>现在基本不使用了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240520152115875-173788154339778.png" alt="image-20240520152115875"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240520155548456-173788154339779.png" alt="image-20240520155548456"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240520160441323-173788154339780.png" alt="image-20240520160441323"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240520160858725-173788154339781.png" alt="image-20240520160858725"></p>
<p>Semaphore：通常<strong>用于那些资源有明确访问数量限制的场景</strong>，常用于限流。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240520162149543-173788154339782.png" alt="image-20240520162149543"></p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.tree.TreeNode;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">1</span>); <span class="comment">// 创建一个具有1个许可的信号量</span></span><br><span class="line">    <span class="keyword">static</span> AtomicInteger t=<span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; print(), <span class="string">&quot;Thread-A&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; print(), <span class="string">&quot;Thread-B&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; ) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire(); <span class="comment">// 获取一个许可</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">                <span class="keyword">if</span> ((t.get()%<span class="number">2</span>==<span class="number">1</span> &amp;&amp; name.equals(<span class="string">&quot;Thread-A&quot;</span>)) || (t.get()%<span class="number">2</span>==<span class="number">0</span> &amp;&amp; name.equals(<span class="string">&quot;Thread-B&quot;</span>))) &#123;</span><br><span class="line">                    System.out.println(name+<span class="string">&quot; &quot;</span>+t.get());</span><br><span class="line">                    i++;</span><br><span class="line">                    t.incrementAndGet();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                semaphore.release(); <span class="comment">// 释放一个许可</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Semaphore和线程池的区别</p>
<ul>
<li><p>使用Semaphore，实际<strong>工作线程</strong>由开发者自己创建；使用线程池，实际工作线程由线程池创建</p>
</li>
<li><p>使用Semaphore，并发线程的控制必须手动通过<strong>acquire()和release()函数</strong>手动完成；使用线程池，并发线程的控制由线程池自动管理</p>
</li>
<li><p>使用Semaphore<strong>不支持设置超时和实现异步访问</strong>；使用线程池则可以实现超时和异步访问，通过提交一个Callable对象获得Future，从而可以在需要时调用Future的方法获得线程执行的结果，同样利用<strong>Future也可以实现超时</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallableTask</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 模拟一些耗时的计算或I/O操作</span></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Result of the task&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个固定大小的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交Callable任务并获取Future对象</span></span><br><span class="line">        Future&lt;String&gt; future = executorService.submit(<span class="keyword">new</span> <span class="title class_">MyCallableTask</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 尝试在5秒内获取任务结果</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.get(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">            System.out.println(<span class="string">&quot;Task completed: &quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 如果任务超时或发生异常</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Task timed out or interrupted: &quot;</span> + e.getMessage());</span><br><span class="line">            <span class="comment">// 取消任务</span></span><br><span class="line">            future.cancel(<span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭线程池</span></span><br><span class="line">            executorService.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="9、数据库连接池"><a href="#9、数据库连接池" class="headerlink" title="9、数据库连接池"></a>9、数据库连接池</h2><p>为数据库连接建立一个<strong>“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。</strong></p>
<p>数据库连接池负<strong>责分配、管理和释放数据库连接</strong>，它允许应用程序<strong>重复使用一个现有的数据库连接，而不是重新建立一个。</strong></p>
<p>数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由<strong>最小数据库连接数来设定的</strong>。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的<strong>最大数据库连接数量限定了这个连接池能占有的最大连接数</strong>，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。<br>优点：资源重用、更快的系统反应速度、新的资源分配手段、统一的连接管理，避免数据库连接泄露</p>
<h2 id="10、请你介绍下-JVM-内存模型，分为哪些区域？各区域的作⽤是什么？"><a href="#10、请你介绍下-JVM-内存模型，分为哪些区域？各区域的作⽤是什么？" class="headerlink" title="10、请你介绍下 JVM 内存模型，分为哪些区域？各区域的作⽤是什么？"></a>10、请你介绍下 JVM 内存模型，分为哪些区域？各区域的作⽤是什么？</h2><p>JVM：类加载器+运行时数据区+执行引擎+本地接口库</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240328102300380-173788154339783.png" alt="image-20240328102300380"></p>
<p>分<strong>线程共有、线程私有</strong>。</p>
<ul>
<li><p>程序计数器：字节码解释器可以改变程序计数器来<strong>读取指令，控制代码</strong>的流程；多线程的话，<strong>能记录线程当前运⾏的位置</strong>（唯⼀⼀个不出现outofmemoryerror的数据区） </p>
</li>
<li><p>虚拟机栈：</p>
<p>1）为<strong>调⽤java⽅法</strong>服务的，每⼀个被<strong>线程执⾏的⽅法</strong>，为该栈中的栈帧，即每个⽅法对应⼀个栈帧。 </p>
<p>2）调⽤⼀个⽅法，就会向栈中压⼊⼀个栈帧；</p>
<p>3）⼀个⽅法调⽤完成，就会把该栈帧从栈中弹出；若栈内存⼤⼩不允许动态扩容，可能会出现StackOverflowerror；如果栈内存⼤⼩可以动态扩容，则可能出现 <strong>outofmemoryerror</strong>； </p>
<ul>
<li><p>栈内存变大导致线程数变少（非越大越好），默认栈内存1024k</p>
</li>
<li><p>方法内的局部变量是否安全？</p>
<ul>
<li>如果方法内局部变量<strong>没有逃离方法的作用范围</strong>，它是线程安全的</li>
<li>如果是<strong>局部变量引用了对象，并逃离方法的作用范围</strong>，需要考虑线程安全</li>
</ul>
</li>
<li><p>栈内存溢出</p>
<ul>
<li>栈帧过多导致栈内存溢出</li>
<li>栈帧过大（方法参数和局部变量）导致栈内存溢出</li>
</ul>
</li>
<li><p>堆栈区别</p>
<ul>
<li>栈内存一般会用来存储局部变量和方法调用，但堆内存是用来存储Java对象和数组的的。<strong>堆会GC垃圾回收</strong>，而栈不会。</li>
<li>栈内存是线程私有的，而堆内存是线程共有的。</li>
<li>两者异常错误不同，但如果栈内存或者堆内存不足都会抛出异常。<ul>
<li>栈空间不足:java.lang.StackOverFlowError。</li>
<li>堆空间不足:java.lang.OutOfMemoryErkor。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>本地⽅法栈：<strong>native⽅法</strong>通过这个实现 </p>
</li>
<li><p>堆：Java堆是Java虚拟机所管理内存中最⼤的⼀块，<strong>存放实例对象与数组</strong>；容易出现<strong>outofmemoryerror</strong></p>
<ul>
<li>年轻代+老年代</li>
<li>年轻代被划分为三部分，Eden区和两个大小严格 相同的Survivor区。根据JVM的策略，在经过几次垃圾收集后，仍然存活于Survivor的对象将被移动到老年代区间。</li>
<li>老年代主要保存生命周期长的对象，一般是一些老的对象</li>
</ul>
</li>
<li><p>⽅法区：<strong>存放已被加载的类信息、常量、静态变量</strong>、即时编译器编译后的代码数据。即<strong>永久代</strong>，在<strong>jdk1.8</strong>中不存在⽅法区了，被称为<strong>元空间（Metaspace）</strong>—&gt;放在本地内存中。线程共享区域、<strong>虚拟机启动时创建，关闭虚拟机时释放</strong></p>
<p>原⽅法区分成两部分；</p>
<ul>
<li>1：加载的类信息</li>
<li>2：运⾏时常量池；</li>
</ul>
<p>运行时常量池</p>
<ul>
<li><p>常量池：可以看作是一张表，<strong>虚拟机指令根据这张常量表找到要执行的类名方法名、参数类型、字面量</strong>等信息</p>
</li>
<li><p>当类被加载，它的常量池信息就会放入<strong>运行时常量池，并把里面的符号地址变为真实地址</strong></p>
</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240525142854502-173788154339784.png" alt="image-20240525142854502"></p>
<p>直接内存：</p>
<ul>
<li><p>并不属于JVM中的内存结构，不由JVM进行管理。是<strong>虚拟机</strong>的系统内存</p>
</li>
<li><p>常见于 <strong>NIO 操作时，用于数据缓冲区，分配回收成本较高，但读写性能高</strong>，不受 JVM 内存回收管理</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240525164346760-173788154339785.png" alt="image-20240525164346760"></p>
</li>
</ul>
<h2 id="11、什么是双亲委派模式？有什么作⽤？"><a href="#11、什么是双亲委派模式？有什么作⽤？" class="headerlink" title="11、什么是双亲委派模式？有什么作⽤？"></a>11、什么是双亲委派模式？有什么作⽤？</h2><p>双亲委派保证类加载器，自下而上的委派，又自上而下的加载，保证每一个类在各个类加载器中都是同一个类。</p>
<p>**具体来说，当⼀个类加载器需要加载某个类时，它⾸先会委派给它的⽗类加载器去加载该类。如果⽗类加载器⽆法找到该类，则再将加载任务委派给它的⽗类加载器，直到最终委派到顶层的启动类加载器。如果顶层的启动类加载 器仍然⽆法找到该类，则会抛出 ClassNotFoundException 异常。 **</p>
<p><strong>这样做的好处是：防⽌内存中出现多份同样的字节码。</strong></p>
<p>双亲委派模式的作⽤：</p>
<ul>
<li>保证 JVM 中<strong>每个类只会被加载⼀次，避免重复加载</strong>。当⼀个类被加载后，它会被**缓存在 JVM **的内存中，以便之后的使⽤。 </li>
<li>如果<strong>不</strong>采⽤双亲委派模式，可能会导致<strong>同⼀个类被多次加载</strong>，从⽽浪费⼤量的内存资源。 </li>
<li>此外，双亲委派模式还可以保证<strong>类的安全性</strong>，因为如果⼀个类是由⽤户⾃定义的类加载器加载的，那么它并不能访问由系统类加载器或其它更⾼级别的类加载器加载的类。对于⼀些核⼼类，例如 java.lang.Object、 java.lang.String 等，它们都是由启动类加载器加载的，因此也可以保证它们的正确性和安全性。</li>
</ul>
<hr>
<p>类加载器：JVM只会运行二进制文件，类加载器的作用就是<strong>将字节码文件加载到JVM</strong>中，从而让Java程序能够启动起来。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240525205008161-173788154339786.png" alt="image-20240525205008161"></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240525205908055-173788154339787.png" alt="image-20240525205908055" style="zoom: 67%;" />

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240525210525127-173788154339788.png" alt="image-20240525210525127" style="zoom: 67%;" />

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240525211413640-173788154339789.png" alt="image-20240525211413640" style="zoom:50%;" />



<h2 id="11、怎么打破双亲委派模式"><a href="#11、怎么打破双亲委派模式" class="headerlink" title="11、怎么打破双亲委派模式"></a>11、怎么打破双亲委派模式</h2><p>类的加载方式默认是双亲委派，如果我们有一个类想要通过自定义的类加载器来加载这个类，而不是通过系统默认的类加载器，说白了就是不走双亲委派那一套。</p>
<p>1、自定义类加载器 ，重写loadclass方法。典型的打破双亲委派模型的框架和中间件有<strong>tomcat</strong>与<strong>osgi</strong><br>2、SPI机制绕开loadclass 方法。当前线程设定关联类加载器。</p>
<p>当然这里要注意一下，Object.class这是对象的顶级类，改变类的类加载器的时候要注意，如果全部改了，Object.class就找不到了，加载不了了。所以呢，这里重写的时候，要注意分类解决，把你<strong>想要通过自定义类加载器加载的和想通过默认类加载器加载的分隔开</strong>。</p>
<p>如果不想打破双亲委派模型，就重写**ClassLoader类中的findClass()**方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。</p>
<p>由于java中无法直接引用BootstrapClassLoader，所以在初始化TestClassLoader时，传入parent为null，也就是TestClassLoader的父类加载器设置为BootstrapClassLoader。</p>
<p>双亲委派的逻辑在 <strong>loadClass</strong>，由于现在的类加载器的关系为TestClassLoader —&gt;<strong>BootstrapClassLoader</strong>，所以TestClassLoader中无需重写loadClass。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="E:\java\blog\source_posts\JOB-md.assets\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNjU4NjEyMA==,size_1,color_FFFFFF,t_70%23pic_center.png"></p>
<h2 id="12、常⻅的垃圾回收算法有⼏种类型？他们对应的优缺点是什么？"><a href="#12、常⻅的垃圾回收算法有⼏种类型？他们对应的优缺点是什么？" class="headerlink" title="12、常⻅的垃圾回收算法有⼏种类型？他们对应的优缺点是什么？"></a>12、常⻅的垃圾回收算法有⼏种类型？他们对应的优缺点是什么？</h2><p><strong>什么是垃圾？</strong></p>
<p>如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾，如果定位了垃圾，则有可能会被垃圾回收器回收。</p>
<p><strong>怎么定位垃圾？</strong></p>
<ul>
<li>引用计数法：循环引用，引用计数法失效</li>
<li>可达性分析算法<ul>
<li>Java 虚拟机中的垃圾回收器采用<strong>可达性分析来探索所有存活</strong>的对象</li>
<li>扫描堆中的对象，看是否能够沿着 <strong>GC Root 对象 为起点的引用链</strong>找到该对象，找不到，表示可以回收<ul>
<li>那些可以作为GC Root<ul>
<li><strong>虚拟机栈(栈帧中的本地变量表)中引用的对象</strong></li>
<li><strong>方法区中类静态属性引用的对象</strong></li>
<li><strong>方法区中常量引用的对象</strong></li>
<li>本地方法栈中 JNI(即一般说的 Native 方法)引用的对象</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p><strong>标记-清除算法、复制算法、标记-整理算法、分代收集算法</strong></p>
<p>**标记-清除算法 **</p>
<p>标记—清除算法包括两个阶段：“标记”和“清除”。 标记阶段：确定所有要回收的对象，并做标记。 清除阶段：将标记阶段确定不可⽤的对象清除。 </p>
<p>优点：算法简单明了，实现容易 </p>
<p>缺点： 标<strong>记和清除的效率都不高。 会产⽣⼤量的碎⽚，⽽导致频繁</strong>的回收。 </p>
<p><strong>复制算法</strong> </p>
<p>内存分成⼤⼩相等的两块，每次使⽤其中⼀块，当垃圾回收的时候， 把存活的对象复制到另⼀块上，然后把这块内存整个清理掉。 </p>
<p>缺点： 需要<strong>浪费额外的内存作为复制区。 当存活率较⾼时，复制算法</strong>效率会下降。 </p>
<p><strong>标记-整理算法</strong></p>
<p>标记—整理算法不是把存活对象复制到另⼀块内存，⽽是把存活对象往内存的⼀端移动，然后直接回收边界以外的 内存。 </p>
<p>缺点： 算<strong>法复杂度⼤，执⾏步骤</strong>较多 </p>
<p>**分代收集算法 **</p>
<p>⽬前⼤部分 JVM 的垃圾收集器采⽤的算法。根据对象存<strong>活的⽣命周期将内存划分为若⼲个</strong>不同的区域。⼀般情况下将堆区划分为<strong>新⽣代（ Young Generation 和⽼年代（ Tenured Generation ），永久代（ Permanet Generation）</strong>。 </p>
<p>⽼年代的特点是每次垃圾收集时只有少量对象需要被回收，⽽新⽣代的特点是每次垃圾回收时都有⼤量的对象需要被回收，那么就可以根据<strong>不同代的特点采取最适合的</strong>收集算法。 </p>
<p>Young：存放新创建的对象，对象⽣命周期⾮常短，⼏乎⽤完可以⽴即回收，也叫 <strong>Eden 区</strong>。 </p>
<p>Tenured： young 区多次回收后存活下来的对象将被移到 tenured 区，也叫 **old **区。 </p>
<p>Perm：永久<strong>代，主要存储加载的类信息，⽣命周期⻓，⼏乎不会被</strong>回收。</p>
<p>缺点： 算<strong>法复杂度⼤，执⾏</strong>步骤较多。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240525213548925-173788154339790.png" alt="image-20240525213548925" style="zoom: 67%;" />



<p>垃圾回收器：串行垃圾收集器、并行垃圾收集器、CMS（Concurrent Mark Sweep）(并发)垃圾收集器 、G1垃圾收集器（jdk9之后默认使用G1）</p>
<p>cms:标记清除；G1：<strong>标记整理算法</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240525214606516-173788154339791.png" alt="image-20240525214606516"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240525221432259-173788154339892.png" alt="image-20240525221432259"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240821131230109-173788154339893.png" alt="image-20240821131230109"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240821131249121-173788154339894.png" alt="image-20240821131249121"></p>
<h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>为每个对象维护一个计数器，对象被引用就+1，置为null了就-1，JVM扫描堆内存，发现数值为0则回收</p>
<p>缺点：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/003bf544beaff7dd4bb99fe82df3282a.png"></p>
<h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>普通对象A，经一个引用链可以到达GC Root对象，则A不可被回收</p>
<p>GC Root对象包括：</p>
<ul>
<li><p>线程对象Thread（引用线程栈帧中的方法参数、局部变量等）</p>
</li>
<li><p>系统类加载器加载的java.lang.Class对象（引用类中的静态变量）</p>
</li>
<li><p>监视器对象（引用synchronized锁的对象）</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/6bcc0f357efb19532c398ae555a6af61.png"></p>
<ul>
<li>本地方法调用时使用的全局对象</li>
</ul>
<p><strong>强、软、弱、虚引用区别</strong></p>
<p>软\弱引用就是通过SoftReference和WeakReference这两个类来实现定义强弱引用的</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240525222316561-173788154339895.png" alt="image-20240525222316561"></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/double222222/article/details/135671320">【JVM】深入理解Java引用类型：强引用、软引用、弱引用和虚引用_java弱引用和虚引用-CSDN博客</a></p>
<h2 id="13、并发和并⾏有什么区别？同步和异步有什么区别？"><a href="#13、并发和并⾏有什么区别？同步和异步有什么区别？" class="headerlink" title="13、并发和并⾏有什么区别？同步和异步有什么区别？"></a>13、并发和并⾏有什么区别？同步和异步有什么区别？</h2><p><strong>并发</strong>：指多个任务同时在执⾏，但是它们并不是在同⼀时刻执⾏，⽽是通过<strong>快速切换上下⽂来模拟同时执⾏</strong>，优秀的并发可以⽆限逼近并⾏，但⽆法完全做到并⾏。 </p>
<p>例如，在⼀个 Web 服务器上，多个⽤户访问同⼀个⽹站，服务器会并发地处理这些请求，同时响应每个请求，但是在某⼀时刻只有⼀个请求被处理； </p>
<p>在单核cpu下，多个线程轮流使用cpu称为并发。</p>
<p>在多核cpu下，。。。。。。。。一个或多个cpu。。。。</p>
<p><strong>并⾏</strong>：指多个任务同时在执⾏，并且它们真正地同时执⾏，通常需要多个 CPU 或者多台计算机协同⼯作。 </p>
<p>例如，在⼀个分布式计算系统中，不同的计算节点可以同时执⾏不同的任务，并在完成任务后将结果汇总，以加速 计算的过程。</p>
<p>在多核cpu下，线程和cpu是一对一。。。</p>
<p><strong>同步</strong>：指调⽤某个函数或⽅法时，程序必须等待函数或⽅法执⾏完毕才能继续往下执⾏。 </p>
<p>最熟知的便是使⽤同步机制来控制多个线程之间的访问，如在 Java 中的 synchronized 关键字可以确保同⼀时间 只有⼀个线程可以访问某个对象的临界区，避免了多个线程同时修改同⼀个对象导致的数据不⼀致问题；</p>
<p><strong>异步</strong>：指调⽤某个函数或⽅法时，程序可以继续往下执⾏，不必等待函数或⽅法执⾏完毕。当函数或⽅法执⾏完毕 后，程序会得到⼀个通知或回调来处理结果。在 Java 中<strong>可以使⽤ CompletableFuture 类来异步执⾏某个任务</strong>，从⽽提⾼程序的性能。 </p>
<p>虽然并发和并⾏、同步和异步都是计算机领域中常⽤的概念，但是它们的区别还是很明显的。并发和并⾏关注的是任务的执⾏⽅式，同步和异步则关注的是数据的处理⽅式。</p>
<h2 id="14、什么是-BIO、NIO、AIO？写的不好"><a href="#14、什么是-BIO、NIO、AIO？写的不好" class="headerlink" title="14、什么是 BIO、NIO、AIO？写的不好"></a>14、什么是 BIO、NIO、AIO？写的不好</h2><p><strong>BIO、NIO、AIO 都是 Java 中网络编程的 I&#x2F;O 模型。</strong> </p>
<p>BIO（Blocking IO ）是JDK1.4之前的传统IO模型，特点就是同步阻塞等待数据，直到数据读取完毕才会返回结果， <strong>线程会⼀直阻塞在 read&#x2F;write ⽅法上，不能处理其他的 IO 请求，它的并发性能⽐较差</strong>。 </p>
<p>NIO（Non-Blocking IO）是Java 1.4 之后新增的 IO 模型，它⽀持同步⾮阻塞式的 IO 操作。NIO 采⽤了<strong>多路复⽤器来处理 IO 请求，通过⼀个线程处理多个 IO 请求，实现了⾼并发处理</strong>。NIO 主要有三个核⼼概念：Selector、 Channel、Buffer。Selector 负责监听多个 Channel 上的事件，Channel 可以理解为对原始 IO 的封装，Buffer则是对数据的封装。 </p>
<p>AIO（Asynchronous IO）是Java 1.7 之后新增的 IO 模型，它⽀持异步⾮阻塞 IO 操作。与 NIO 不同的是，AIO 在 进⾏读写操作时不需要像 NIO ⼀样⼀直轮询，⽽是通过<strong>回调函数的⽅式在数据准备好后通知应⽤程序进行数据的读取</strong>，这样可以更加⾼效地利⽤系统资源，提⾼吞吐量。但是 AIO 在处理⼩⽂件和⼩数据量时的性能并不如 NIO</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/JOB-md.assets/image-20240328105608795-173788154339896.png" alt="image-20240328105608795"></p>
<p>理解：</p>
<table>
<thead>
<tr>
<th>BIO 同步阻塞 IO，即打算约⼥神，给⼥神发短信后，没⻅到⼥神就⼀直等在宿舍楼下。</th>
</tr>
</thead>
<tbody><tr>
<td>NIO 同步⾮阻塞 IO，即打算约⼥神，给⼥神发短信后，没⻅到⼥神就⼀直发短信。</td>
</tr>
<tr>
<td>NIO java中的 NIO，就是打算约⼥神，你让宿管⼤妈去挨个看每⼀个下楼的妹⼦，⼥神下楼了⼤妈就通知你。</td>
</tr>
<tr>
<td>AIO 就是打算约⼥神，你发完短信，你就去玩游戏了，⼥神下楼了，发短信给你，你才出现。</td>
</tr>
</tbody></table>
<h2 id="15、线程的⽣命周期是什么，线程有⼏种状态，什么是上下⽂切换？"><a href="#15、线程的⽣命周期是什么，线程有⼏种状态，什么是上下⽂切换？" class="headerlink" title="15、线程的⽣命周期是什么，线程有⼏种状态，什么是上下⽂切换？"></a>15、线程的⽣命周期是什么，线程有⼏种状态，什么是上下⽂切换？</h2><p>线程状态：new、Runnable（start）、terminated、blocked、waiting、Timed_waited。</p>
<p><strong>上下文</strong>：cpu当前的寄存器信息保存、恢复上下文的过程。通过让cpu恢复过去的记忆，回到过去的状态。</p>
<p>先创建2个线程的初始上下文，并存入到相应的内存颗粒上。经过内核调度，先让线程一运行，也就是说使用线程一的上下文来设置cpu寄存器，其中eip寄存器让cpu跳转到线程一的方法上运行。这时发生时钟中断，cpu跳转到内核代码，内核将当前代码保存到线程一的内存颗粒上。这时，使用线程二的上下文来设置cpu寄存器，eip寄存器让cpu跳转到线程二的方法上运行。</p>
<hr>
<p>线程通常有五种状态：<strong>创建，就绪，运⾏、阻塞和死亡状态</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240328110106604-173788154339897.png" alt="image-20240328110106604"></p>
<p>新建状态（New）：新创建了⼀个线程对象。 </p>
<p>就绪状态（Runnable）：线程对象创建后，其他线程调⽤了该对象的start⽅法。该状态的线程位于可运⾏线程池中，变得可运⾏，等待获取 CPU 的使⽤权。 </p>
<p>运⾏状态（Running）：就绪状态的线程获取了 CPU，执⾏程序代码。</p>
<p>阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃 CPU 使⽤权，暂时停⽌运⾏。直到线程进⼊就绪 状态，才有机会转到运⾏状态。 </p>
<p>死亡状态（Dead）：线程执⾏完了或者因异常退出了 run ⽅法，该线程结束⽣命周期。</p>
<p>其中阻塞的情况⼜分为三种：</p>
<ul>
<li><strong>等待阻塞</strong>：运⾏的线程执<strong>⾏wait⽅法，该线程会释放占⽤的所有资源</strong>，JVM 会把该线程放⼊“等待池”中。进⼊这个状态后，是不能⾃动唤醒的，必须依靠其他线程调⽤ notify 或 notifyAll ⽅法才能被唤醒，wait 是 object 类的⽅法 </li>
<li><strong>同步阻塞</strong>：<strong>运行的线程在获取对象的同步锁时，若该同步锁被别的线程占⽤，则 JVM 会把该线程放⼊“锁池” 中</strong>。</li>
<li><strong>其他阻塞</strong>：运⾏的线程执⾏<strong>sleep 或 join ⽅法，或者发出了 I&#x2F;O 请求时，JVM 会把该线程置为阻塞状态</strong>。当 sleep 状态超时、join 等待线程终⽌或者超时、或者 I&#x2F;O 处理完毕时，线程重新转⼊就绪状态。sleep 是 Thread 类 的⽅法。</li>
</ul>
<h2 id="15、线程"><a href="#15、线程" class="headerlink" title="15、线程"></a>15、线程</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240517210758181-173788154339898.png" alt="image-20240517210758181"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240517210918749-173788154339899.png" alt="image-20240517210918749"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240517210940223-1737881543398100.png" alt="image-20240517210940223"></p>
<p>线程退出：</p>
<p>1.打标记，volatile(读写屏障，先读（阻止下方其他读操作越过屏障排到volatile变量读之上）后写（阻止上方其他写操作越过屏障排到voltile变量之下），防止指令重排序)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240605150440979-1737881543398101.png" alt="image-20240605150440979"></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240605150632252-1737881543398103.png" alt="image-20240605150632252" style="zoom: 67%;" />

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240605150736445-1737881543398102.png" alt="image-20240605150736445"></p>
<p>2.interrupted</p>
<hr>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240520082322562-1737881543398104.png" alt="image-20240520082322562"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240520084640535-1737881543398105.png" alt="image-20240520084640535"></p>
<p>死锁产生的四个必要条件是：</p>
<ol>
<li><strong>互斥条件（Mutual Exclusion）</strong>：资源不能被多个线程同时占有。任何时候，一个资源只能被一个线程持有。</li>
<li><strong>持有和等待条件（Hold and Wait）</strong>：线程至少持有一个资源，并且正在等待获取额外的资源，而该资源目前被其他线程持有。</li>
<li><strong>非抢占条件（No Preemption）</strong>：线程持有的资源在未使用完之前不能被其他线程强行抢占。</li>
<li><strong>循环等待条件（Circular Wait）</strong>：存在一个线程集合，每个线程都在等待下一个线程所持有的资源，形成一个循环等待链。</li>
</ol>
<p>只有当这四个条件同时满足时，死锁才会发生。为了预防死锁，必须至少破坏其中一个条件。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240520085808390-1737881543398106.png" alt="image-20240520085808390"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240520091121176-1737881543398107.png" alt="image-20240520091121176"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240520092042093-1737881543398108.png" alt="image-20240520092042093"></p>
<h2 id="16、synchronized-关键字是什么，有什么作⽤？"><a href="#16、synchronized-关键字是什么，有什么作⽤？" class="headerlink" title="16、synchronized 关键字是什么，有什么作⽤？"></a>16、synchronized 关键字是什么，有什么作⽤？</h2><p>synchronized 是 Java 中的⼀个关键字，⽤来实现<strong>同步锁</strong>。 </p>
<p>它可以修饰<strong>⽅法或代码块，保证同⼀时刻只有⼀个线程可以执⾏被修饰的部分</strong> </p>
<p>synchronized 的作⽤有以下⼏点： </p>
<ul>
<li><p>保证数据的<strong>原⼦性和可⻅性</strong>，防⽌多线程操作导致的数据不⼀致。 </p>
</li>
<li><p><strong>防止指令重排序</strong>，保证代码执⾏的顺序和预期⼀致。 （同vatilate）</p>
</li>
<li><p><strong>实现线程间的通信</strong>，通过 wait 和 notify ⽅法来实现线程的等待和唤醒。</p>
</li>
</ul>
<p>synchronized的使⽤⽅式有以下⼏种： </p>
<ul>
<li><p>修饰⾮静态⽅法，锁对象是当前实例对象 </p>
</li>
<li><p>修饰静态⽅法，锁对象是当前类对象 </p>
</li>
<li><p>修饰代码块，锁对象是括号⾥指定的对象</p>
</li>
</ul>
<p>synchronized 和其他同步⼯具（如 ReentrantLock）相⽐，有以下优缺点： </p>
<ul>
<li>优点：**简单易用，不需要手动释放锁。 **</li>
<li>缺点：不灵活，不能设置超时时间、中断等；效率低，每次都要进⼊内核态获取锁；不可重⼊，同⼀个线程在获取到锁后还要再次获取锁会造成死锁</li>
</ul>
<hr>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240518080509328-1737881543398109.png" alt="image-20240518080509328"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240518081939770-1737881543398110.png" alt="image-20240518081939770"></p>
<p>###synchronized的锁升级过程？</p>
<p>无锁–》偏向锁–》轻量级锁–》重量级锁</p>
<p>偏向锁：</p>
<p>轻量级锁：在多线程交替执行同步块的情况下，可以避免重量级锁引起的性能损耗</p>
<p>中间态：自旋锁：默认自旋10次，JVM会认为自旋获得锁的线程，会增加自旋的时间</p>
<p>锁消除：不存在竞争情况下，会进行synchronized的消除</p>
<p>锁粗化：JVM会探测到一连串细小的操作都使用同一对象加锁，将同步代码块的范围放大，放到这串操作的外面，只需加一次锁即可</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240518083110814-1737881543398111.png" alt="image-20240518083110814"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240518083929983-1737881543398112.png" alt="image-20240518083929983"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240518090150780-1737881543398113.png" alt="image-20240518090150780"></p>
<p>AQS（AbstractQueuedSynchronizer，抽象队列同步器），构建锁或者其他同步组件的基础框架。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240518091126044-1737881543398114.png" alt="image-20240518091126044"></p>
<p>上述队列是双向链表的。</p>
<p>举例：</p>
<p>Lock接口实现类ReentrantLock（源码）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加锁方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sync是什么</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="comment">//因此，sync是基于AQS框架实现的，AQS框架中有内部类node，基于该node实现锁机制</span></span><br><span class="line"><span class="comment">//由源码可知，sync的实现类有公平锁和非公平锁两个类， ReentrantLock的默认构造方法是非公平锁进行加锁。 在抽象类sync中，已经写好了tryLock()和lock()方法，tryRelease(int releases)等方法，子类实现使用即可。</span></span><br></pre></td></tr></table></figure>

<p>[AQS讲的很好]<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1z44y1X7BJ?spm_id_from=333.788.player.switch&vd_source=03235a8277a4e1950048927a7c975e38">https://www.bilibili.com/video/BV1z44y1X7BJ?spm_id_from=333.788.player.switch&amp;vd_source=03235a8277a4e1950048927a7c975e38</a></p>
<h2 id="17、设计模式可以分为哪⼏类？⼀共有多少种主流的设计模式？场景？"><a href="#17、设计模式可以分为哪⼏类？⼀共有多少种主流的设计模式？场景？" class="headerlink" title="17、设计模式可以分为哪⼏类？⼀共有多少种主流的设计模式？场景？"></a>17、<font color=red>设计模式可以分为哪⼏类？⼀共有多少种主流的设计模式？场景？</font></h2><ul>
<li><p>创建型模式：这类模式关注对象创建的机制，包括单例模式、⼯⼚模式、抽象⼯⼚模式、建造者模式和原型模式等。 </p>
</li>
<li><p>结构型模式：这类模式关注对象之间的组合关系，包括适配器模式、装饰器模式、代理模式、组合模式、桥接 模式、外观模式和享元模式等。 </p>
</li>
<li><p>⾏为型模式：这类模式关注对象之间的通信⽅式和协作⽅式，包括模板⽅法模式、策略模式、命令模式、职责 链模式、状态模式、观察者模式、中介者模式和访问者模式等。 </p>
<p>⽬前主流的设计模式有23种，它们分别是： </p>
</li>
<li><p>单例模式 :确保类只有⼀个实例，并提供全局访问点。</p>
<p>⼯⼚⽅法模式 ：每个具体的类都有⾃⼰的⼯⼚⽅法，负责创建对象实例。</p>
<p>抽象⼯⼚模式 ：⼀组相关或相互依赖的对象，由⼀个抽象⼯⼚对象负责创 建。</p>
<p>建造者模式 原型模式 适配器模式 装饰器模式 代理模式 外观模式 桥接模式 组合模式 享元模式 策略模式 模板⽅法模式 观察者模式 迭代器模式 职责链模式 </p>
<p>命令模式 备忘录模式 状态模式 访问者模式 中介者模式 解释器模式</p>
</li>
</ul>
<h2 id="18、什么是⼯⼚模式？使⽤⼯⼚模式有什么好处？⼯⼚模式有哪些分类？各-⾃的应⽤场景是什么？"><a href="#18、什么是⼯⼚模式？使⽤⼯⼚模式有什么好处？⼯⼚模式有哪些分类？各-⾃的应⽤场景是什么？" class="headerlink" title="18、什么是⼯⼚模式？使⽤⼯⼚模式有什么好处？⼯⼚模式有哪些分类？各 ⾃的应⽤场景是什么？"></a>18、什么是⼯⼚模式？使⽤⼯⼚模式有什么好处？⼯⼚模式有哪些分类？各 ⾃的应⽤场景是什么？</h2><ul>
<li>⼯⼚模式</li>
</ul>
<p>​	把对象的构造交给⼀个类,这样在对象构造过程中,调⽤者不需要知道对象的产⽣过程。降低了代码的耦合度，同时体现了⾯向对象的封装的特征。</p>
<p>​	好处：松耦合 封装 可拓展 复⽤</p>
<p><strong>简单⼯⼚模式</strong> （⼀个⼯⼚⽣产所有的对象 ）</p>
<p>​	如果它负责的对象太多，简单⼯⼚容易庞⼤，变成超级类 </p>
<p>​	简单⼯⼚的拓展是竖向拓展（拓展需要访问⼯⼚内部，职责不够单⼀） </p>
<p>​	因此，他适合在’简单场景’ - 对象少且固定</p>
<p><strong>⼯⼚⽅法模式</strong> （ ⼀个⼯⼚⼀个对象 ）</p>
<p>​	⼯⼚⽅法是横向拓展，由于⼯⼚对象1对1，耦合度没有任何减少，要⽣产类就要知道那个对应的⼯⼚ </p>
<p>​	当需要⽣产新的产品时，⽆需更改既有的⼯⼚，只需要添加新的⼯⼚即可。保持了⾯向对象的可扩展性(纵向，横向都很不错)，符合开闭原则。 </p>
<p>​	因此，⼯⼚⽅法模式适⽤于对象多⽽且可能增加的场景</p>
<p>举例：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240903120657525-1737881543398115.png" alt="image-20240903120657525"></p>
<p><strong>抽象⼯⼚模式</strong> （ 抽象接⼝⼯⼚实现 ）</p>
<p>​	抽象⼯⼚是定义了⼀个接⼝，然后由具体⼯⼚去实现抽象⽅法，突出特点就是运⽤了多态，耦合够松。 </p>
<p>​	缺点也很明显，在接⼝不变的情况下，⽆论是横向拓展性还是松耦合都很好，但是⼀旦接⼝有新的功能增加， 所有的⼯⼚实现都需要纵向拓展。即横向拓展能⼒强，但是纵向拓展能⼒&#x3D;0 </p>
<p>​	因此，抽象⼯⼚模式适合产品族（即有相似属性）的⽣产</p>
<p><strong>责任链模式：一级一级的向下执行</strong></p>
<p><strong>工厂+策略模式：利用Spring IOC容器，写对应的配置文件，通过一个Map存储（key为配置文件的Bean的名字，value为实例化的Bean），通过登录的类型利用Map获取实例化的Bean，然后调用Bean的方法。</strong></p>
<p>单例模式，工厂模式、代理模式、装饰器模式、策略模式、责任链模式</p>
<h2 id="19、设计模式是什么？为什么要学习和使⽤设计模式？"><a href="#19、设计模式是什么？为什么要学习和使⽤设计模式？" class="headerlink" title="19、设计模式是什么？为什么要学习和使⽤设计模式？"></a>19、设计模式是什么？为什么要学习和使⽤设计模式？</h2><p>设计模式：是⼀套经过反复使⽤的代码设计经验，⽬的是为了重⽤代码、让代码更容易被他⼈理解、保证代码可靠 性。  </p>
<p>项⽬中合理地运⽤设计模式可以完美解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式描述 了⼀个在我们周围不断重复发⽣的问题，以及该问题的核⼼解决⽅案，这也是它能被⼴泛应⽤的原因。 设计模式分为三⼤类</p>
<p>设计模式分为三⼤类：</p>
<p>创建型模式：共5种：⼯⼚⽅法模式、抽象⼯⼚模式、单例模式、建造者模式、原型模式 </p>
<p>结构型模式：共7种：适配器模式、装饰器模式、代理模式、桥接模式、外观模式、组合模式、享元模式 </p>
<p>⾏为型模式：共11种：策略模式、模板⽅法模式、观察者模式、责任链模式、访问者模式、中介者模式、迭 代器模式、命令模式、状态模式、备忘录模式、解释器模式</p>
<h2 id="20、什么是单例模式？使⽤单例模式有什么好处？有哪些常⽤的单例模式实现⽅式？各⾃的应⽤场景是什么？"><a href="#20、什么是单例模式？使⽤单例模式有什么好处？有哪些常⽤的单例模式实现⽅式？各⾃的应⽤场景是什么？" class="headerlink" title="20、什么是单例模式？使⽤单例模式有什么好处？有哪些常⽤的单例模式实现⽅式？各⾃的应⽤场景是什么？"></a>20、什么是单例模式？使⽤单例模式有什么好处？有哪些常⽤的单例模式实现⽅式？各⾃的应⽤场景是什么？</h2><p><strong>单例模式</strong>是⼀种设计模式，它的⽬的是<strong>保证⼀个类只有⼀个实例</strong>，并提供⼀个<strong>全局的访问点</strong>。使⽤单例模式可以<strong>避免多次创建对象，节省内存空间</strong>，同时也可以保证<strong>数据的⼀致性</strong>。在开发过程中使⽤单例模式有以下好处：</p>
<ol>
<li><p><strong>节省内存空间</strong>。单例模式只创建⼀个实例，避免了多次创建对象所造成的内存消耗。 </p>
</li>
<li><p><strong>简化代码</strong>。单例模式提供了⼀个<strong>全局的访问点</strong>，可以⽅便地调⽤实例的⽅法，避免了重复的代码。 </p>
</li>
<li><p><strong>保证数据的⼀致性</strong>。由于只有⼀个实例，可以<strong>避免并发访问时数据不⼀致</strong>的问题。</p>
</li>
</ol>
<p>单例模式在开发中有许多适⽤的场景，如：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240514101608541-1737881543398116.png" alt="image-20240514101608541"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240514101619111-1737881543398117.png" alt="image-20240514101619111"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240514101632919-1737881543398118.png" alt="image-20240514101632919"></p>
<h2 id="21、JVM实践"><a href="#21、JVM实践" class="headerlink" title="21、JVM实践"></a>21、JVM实践</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240526085749985-1737881543398119.png" alt="image-20240526085749985"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240526091115059-1737881543398120.png" alt="image-20240526091115059"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240526091142500-1737881543398121.png" alt=" "></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20241024100646569-1737881543398122.png" alt="image-20241024100646569" style="zoom: 67%;" />



<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240526093420155-1737881543398123.png" alt="image-20240526093420155" style="zoom: 67%;" />



<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240526094046837-1737881543398124.png" alt="image-20240526094046837"  />



<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240526094648969-1737881543398126.png" alt="image-20240526094648969"></p>
<p>对应Linux命令：</p>
<p><strong>top：</strong>展示所有的进程，查看那个进程占用CPU过高</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240526094829790-1737881543398125.png" alt="image-20240526094829790"></p>
<p><strong>ps：</strong>查看当前进程下那个线程占用CPU过高</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240526094917659-1737881543398127.png" alt="image-20240526094917659"></p>
<p><strong>printf：</strong>将当前过高的线程ID转十六进制</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240526095023812-1737881543398128.png" alt="image-20240526095023812"></p>
<p><strong>jstack:</strong> 查看当前进程下所有线程的日志，与十六进制对应的线程ID查看报错信息</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240526094959596-1737881543398129.png" alt="image-20240526094959596"></p>
<p>在日志中找当前线程对应的信息</p>
<p>##22、String, StringBuffer and StringBuilder</p>
<p>1）可变性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String是不可变的，只读字符串，即String引用的字符串内容是不能被改变的。</span><br><span class="line">StringBuilder和StringBuffer都继承自AbstractStringBuilder类（提供了很多修改字符串的方法比如append），所以StringBuffer和StringBuilder表示的字符串对象可以直接进行修改。</span><br></pre></td></tr></table></figure>

<p>2）线程安全性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String中的对象是不可变的，可理解为常量，线程安全。StringBuffer对方法加了同步锁（<span class="keyword">synchronized</span>）或者对调用的方法加了同步锁，所以线程安全。StringBuilder没有对方法进行加同步锁，所以是非线程安全。</span><br></pre></td></tr></table></figure>


<h2 id="23、非受检异常和受检异常"><a href="#23、非受检异常和受检异常" class="headerlink" title="23、非受检异常和受检异常"></a>23、非受检异常和受检异常</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/java-basic-exception-1.png"></p>
<ul>
<li><strong>可查异常</strong>（编译器要求必须处置的异常）：</li>
</ul>
<p>正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。</p>
<p>除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。</p>
<ul>
<li><strong>不可查异常</strong>(编译器不要求强制处置的异常)</li>
</ul>
<p>包括运行时异常（RuntimeException与其子类）和错误（Error）。</p>
<h2 id="24、讲一下wait和notify这个为什么要在synchronized"><a href="#24、讲一下wait和notify这个为什么要在synchronized" class="headerlink" title="24、讲一下wait和notify这个为什么要在synchronized?"></a>24、讲一下wait和notify这个为什么要在synchronized?</h2><p><strong>监视器（Monitor）所有权</strong>：在Java中，每个对象都有一个监视器（Monitor），线程可以通过<code>synchronized</code>关键字来获取这个监视器的所有权。</p>
<p><strong>数据一致性</strong>：在同步代码块或方法中，可以防止多个线程同时访问共享资源，从而避免数据竞争和不一致的状态。</p>
<p><strong>避免死锁和竞态条件</strong>：例如，一个线程可能试图在另一个线程调用<code>notify()</code>之前调用<code>wait()</code>，如果没有同步，这将导致线程无限期地等待。</p>
<p>##25、内存池有哪几种，解释下内存池概念</p>
<p>内存池（Memory Pool）是一种内存管理技术，它允许程序预先分配一大块内存，然后在这块内存中按需分配和释放小块内存。内存池的主要目的是减少内存分配和释放的开销，提高内存使用效率，并减少内存碎片。</p>
<ul>
<li><strong>减少系统调用的次数</strong>：频繁的系统调用（如malloc和free）会导致性能瓶颈，内存池可以减少这些调用。</li>
<li><strong>降低内存碎片</strong>：通过集中管理内存块，内存池有助于减少内存碎片问题。</li>
<li><strong>提高内存分配效率</strong>：预先分配内存可以加快内存分配的速度，特别是在高并发环境下。</li>
</ul>
<h3 id="1-固定大小内存池（Fixed-Size-Memory-Pool）"><a href="#1-固定大小内存池（Fixed-Size-Memory-Pool）" class="headerlink" title="1. 固定大小内存池（Fixed-Size Memory Pool）"></a>1. 固定大小内存池（Fixed-Size Memory Pool）</h3><ul>
<li><strong>概念</strong>：固定大小内存池中的每个内存块大小相同。当请求内存时，系统从池中分配一个固定大小的块。释放时，块被返回到池中以供后续使用。</li>
<li><strong>优点</strong>：简化了内存管理，因为每个块的分配和释放操作都非常快，且没有内存碎片问题。</li>
<li><strong>缺点</strong>：如果需要不同大小的内存块，可能会造成空间浪费。</li>
</ul>
<h3 id="2-可变大小内存池（Variable-Size-Memory-Pool）"><a href="#2-可变大小内存池（Variable-Size-Memory-Pool）" class="headerlink" title="2. 可变大小内存池（Variable-Size Memory Pool）"></a>2. 可变大小内存池（Variable-Size Memory Pool）</h3><ul>
<li><strong>概念</strong>：可变大小内存池允许分配不同大小的内存块。它通常使用一种类似于伙伴系统的算法来管理内存块，可以根据需要将大块内存分割成小块，或将小块合并成大块。</li>
<li><strong>优点</strong>：更灵活，可以根据需求分配不同大小的内存。</li>
<li><strong>缺点</strong>：管理复杂，可能会产生内存碎片。</li>
</ul>
<h3 id="3-对象池（Object-Pool）"><a href="#3-对象池（Object-Pool）" class="headerlink" title="3. 对象池（Object Pool）"></a>3. 对象池（Object Pool）</h3><ul>
<li><strong>概念</strong>：对象池是一种特殊的内存池，它专门用于管理对象实例的创建和销毁。对象池预先分配一定数量的对象实例，并在需要时重用这些实例。</li>
<li><strong>优点</strong>：减少了对象创建和销毁的开销，特别是对于那些创建成本较高的对象。</li>
<li><strong>缺点</strong>：需要合理预测池的大小，以避免资源浪费或不足。</li>
</ul>
<h3 id="4-基于页的内存池（Page-Based-Memory-Pool）"><a href="#4-基于页的内存池（Page-Based-Memory-Pool）" class="headerlink" title="4. 基于页的内存池（Page-Based Memory Pool）"></a>4. 基于页的内存池（Page-Based Memory Pool）</h3><ul>
<li><strong>概念</strong>：基于页的内存池将内存分割成固定大小的页。分配和释放操作以页为单位进行，这有助于减少外部碎片。</li>
<li><strong>优点</strong>：减少了外部内存碎片，并且可以快速分配和释放整页内存。</li>
<li><strong>缺点</strong>：可能会产生内部碎片，因为不是每个页都会被完全利用。</li>
</ul>
<p>##26、springboot启动流程</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1e14y1A7pT/?spm_id_from=333.337.search-card.all.click&vd_source=03235a8277a4e1950048927a7c975e38">史上最完整的Spring启动流程_哔哩哔哩_bilibili</a></p>
<table>
<thead>
<tr>
<th></th>
<th>@EnableAutoConfiguration</th>
<th>@Configuration：源配置类</th>
</tr>
</thead>
<tbody><tr>
<td>@SpringBootApplication</td>
<td><strong>@SpringBootConfiguration</strong>：</td>
<td>@Import（AutoConfigurationImportSelector.class）:显示的从其他地方加载配置类的方式</td>
</tr>
<tr>
<td></td>
<td><strong>@ComponentScan</strong>：扫描指定的package，得到配置类</td>
<td></td>
</tr>
</tbody></table>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20241021112740635-1737881543398130.png" alt="image-20241021112740635"></p>
<p>自动找到所有的配置类用到的注解是@SpringbootApplication,。。。。，<strong>将加载的配置类进行解析处理，并将得到BeanDefinition注册到已经创建好的IOC容器</strong>中，最后启动web服务器。</p>
<p><strong>AutoConfigurationImportSelector.class中有个获取配置类的方法，主要使用到SpringFactories 机制，类似于Java的SPI机制，它的核心逻辑是从 classpath 中读取到所有 Jar 包中的配置文件 META-IF&#x2F;spring.factories然后根据指定的 key 从配置文件中解析出对应的 value 值，多个value值用逗号隔开，这里使用的Key是EnableAutoConfiguration的全限定类名，最后根据注解@conditional注解过滤掉不必要的自动配置类</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20241021162118472-1737881543398131.png" alt="image-20241021162118472"></p>
<p>###自定义一个SpringBoot的自动化配置</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20241021212516181-1737881543398132.png" alt="image-20241021212516181"></p>
<p>第一步：<strong>在项目下，将你的配置类写好，将要使用的Service注册到spring容器中，可以使用@Bean注解修饰</strong></p>
<p>第二步：<strong>在resources目录下的meta-Inf,…创建，。。。目录，将要配置的类写到value位置</strong></p>
<p>第三步：<strong>使用clean，install将项目打包，在别的项目中进行测试。</strong></p>
<hr>
<ol>
<li><p><strong>SpringApplication 的创建</strong>：</p>
<ul>
<li>首先，通过 <code>new SpringApplication()</code> 创建一个 <code>SpringApplication</code> 实例。</li>
<li>然后，调用 <code>SpringApplication.run()</code> 方法来启动 Spring Boot 应用。</li>
</ul>
</li>
<li><p><strong>SpringApplication 的 run 方法</strong>：</p>
<ul>
<li>调用 <code>run</code> 方法后，会执行一系列的初始化操作。</li>
<li>首先，调用 <code>prepareEnvironment</code> 方法，这个方法会创建并准备应用环境，比如设置 <code>SpringApplication.setDefaultProperties</code>。</li>
<li>然后，调用 <code>setListeners</code> 方法，这个方法会添加一些监听器，这些监听器会在启动过程中执行特定任务。</li>
<li>接着，调用 <code>prepareContext</code> 方法，这个方法会创建并准备 Spring 应用上下文，包括创建并准备 <code>ClassLoader</code>，加载并准备应用的主类。</li>
</ul>
</li>
<li><p><strong>SpringApplication 的 run 方法继续</strong>：</p>
<ul>
<li>然后，调用 <code>refreshContext</code> 方法，这个方法会刷新应用上下文，并创建 Spring 应用的组件。</li>
<li>最后，调用 <code>afterRefresh</code> 方法，这个方法会在刷新完成后执行一些后续操作，比如调用 <code>ApplicationRunner</code> 和 <code>CommandLineRunner</code> 的 <code>run</code> 方法。</li>
</ul>
</li>
<li><p><strong>执行命令行参数</strong>：</p>
<ul>
<li>如果启动时提供了命令行参数，Spring Boot 会解析这些参数，并将其传递给应用的主类。</li>
</ul>
</li>
<li><p><strong>运行应用的主方法</strong>：</p>
<ul>
<li><p>执行完上述步骤后，Spring Boot 会运行应用的主方法，这通常是 <code>public static void main(String[] args)</code> 方法。</p>
</li>
<li><p>主方法会启动应用，执行应用程序的业务逻辑。</p>
</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>服务创建</th>
<th>环境准备</th>
<th>容器创建</th>
<th>填充容器</th>
</tr>
</thead>
<tbody><tr>
<td>1.1 资源加载类</td>
<td>创建bootstrapContext，初始化intial方法</td>
<td>创建ApplicationContext</td>
<td>创建Bean对象放在ApplicationContext中，进行自动装配</td>
</tr>
<tr>
<td>Web的Servlet</td>
<td>启动监听器</td>
<td>其中，创建Servlet-web容器，</td>
<td></td>
</tr>
<tr>
<td>7个上下文初始化</td>
<td>构造环境组装启动参数</td>
<td>构建BeanFactory（用来解析各种注解），在其中加载7个上下文初始化，还有诸如Bean定义加载器将启动类，一些资源加载到Bean定义池（Map）</td>
<td></td>
</tr>
<tr>
<td>8个监听器</td>
<td>监听器通过观察者模式（逐一串行执行）监听环境</td>
<td></td>
<td></td>
</tr>
<tr>
<td>判断启动类</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="四舍五入"><a href="#四舍五入" class="headerlink" title="四舍五入"></a>四舍五入</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.text.DecimalFormat;</span><br><span class="line"></span><br><span class="line">Double d=9.567;</span><br><span class="line">System.out.println(new DecimalFormat(&quot;#.0&quot;).format(d));</span><br></pre></td></tr></table></figure>














<h1 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h1><h2 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h2><h2 id="1、简述计算机⽹络七层模型和各⾃的作⽤？"><a href="#1、简述计算机⽹络七层模型和各⾃的作⽤？" class="headerlink" title="1、简述计算机⽹络七层模型和各⾃的作⽤？"></a>1、<font color=red>简述计算机⽹络七层模型和各⾃的作⽤？</font></h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240329195126026-1737881543398133.png" alt="image-20240329195126026"></p>
<p>每⼀层都专注做⼀件事情，并且每⼀层都需要使⽤下⼀层提供的功能⽐如传输层需要使⽤⽹络层提供的路由和寻址功能，这样传输层才知道把数据传输到哪⾥去。</p>
<table>
<thead>
<tr>
<th>OSI层级</th>
<th>层名称</th>
<th>主要功能</th>
<th>对应的协议&#x2F;标准</th>
</tr>
</thead>
<tbody><tr>
<td>第1层</td>
<td>物理层</td>
<td>数据的物理传输</td>
<td><strong>Ethernet</strong>、USB、IEEE 802.11（Wi-Fi）、RS-232</td>
</tr>
<tr>
<td>第2层</td>
<td>数据链路层</td>
<td>比特流组帧，提供可靠的数据传输</td>
<td><strong>Ethernet</strong>、PPP、HDLC、ARP、STP</td>
</tr>
<tr>
<td>第3层</td>
<td>网络层</td>
<td>路由选择和逻辑地址寻址</td>
<td>IP（IPv4&#x2F;IPv6）、ICMP、IGMP、OSPF、BGP</td>
</tr>
<tr>
<td>第4层</td>
<td>传输层</td>
<td>端到端传输服务，确保数据完整</td>
<td><strong>TCP、UDP</strong></td>
</tr>
<tr>
<td>第5层</td>
<td>会话层</td>
<td>管理、控制会话</td>
<td>NetBIOS、PPTP、SMPP</td>
</tr>
<tr>
<td>第6层</td>
<td>表示层</td>
<td>数据格式化、加密、解密和压缩</td>
<td><strong>JPEG、MPEG、SSL&#x2F;TLS、ASCII</strong></td>
</tr>
<tr>
<td>第7层</td>
<td>应用层</td>
<td>提供应用服务，面向用户</td>
<td><strong>HTTP&#x2F;HTTPS、FTP、SMTP、POP3&#x2F;IMAP、DNS、Telnet、SNMP</strong></td>
</tr>
</tbody></table>
<h2 id="2、HTTP-是哪⼀层的协议？简述它的作⽤？"><a href="#2、HTTP-是哪⼀层的协议？简述它的作⽤？" class="headerlink" title="2、HTTP 是哪⼀层的协议？简述它的作⽤？"></a>2、HTTP 是哪⼀层的协议？简述它的作⽤？</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240329195044247-1737881543398134.png" alt="image-20240329195044247"></p>
<h2 id="3、HTTP-有哪些常⻅的状态码？"><a href="#3、HTTP-有哪些常⻅的状态码？" class="headerlink" title="3、HTTP 有哪些常⻅的状态码？"></a>3、HTTP 有哪些常⻅的状态码？</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240329192913926-1737881543398135.png" alt="image-20240329192913926"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240329192950268-1737881543398136.png" alt="image-20240329192950268"></p>
<h2 id="4、TCP-和-UDP-协议有什么区别，分别适⽤于什么场景"><a href="#4、TCP-和-UDP-协议有什么区别，分别适⽤于什么场景" class="headerlink" title="4、TCP 和 UDP 协议有什么区别，分别适⽤于什么场景"></a>4、TCP 和 UDP 协议有什么区别，分别适⽤于什么场景</h2><p>TCP 和 UDP 是计算机⽹络中两种常⽤的传输层协议，⽤于实现可靠传输和⽆连接传输。 </p>
<p>TCP（Transmission Control Protocol）是⼀种<strong>⾯向连接的、可靠的传输协议</strong>。它通过<strong>三次握⼿四次挥⼿</strong>进⾏连接和断开链接，保证数据的<strong>可靠性、完整性和顺序性</strong>，具有较⾼的传输效率。 TCP 协议适⽤于<strong>要求可靠传输的场景，如⽂件传输、电⼦邮件传输</strong>等。 </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240529101256710-1737881543398137.png" alt="image-20240529101256710"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240529101310559-1737881543399138.png" alt="image-20240529101310559"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240529101332319-1737881543399139.png" alt="image-20240529101332319"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240529101346558-1737881543399140.png" alt="image-20240529101346558"></p>
<p>##5、HTTP 协议中 GET 和 POST 有什么区别？分别适⽤于什么场景？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240329170211065-1737881543399141.png" alt="image-20240329170211065"></p>
<p><strong>GET 和 POST 之所以产⽣区别，是因为浏览器&#x2F;服务器的限制</strong>。</p>
<h2 id="6、简述-TCP-三次握手、四次挥手的流程？为什么需要三次握手？为什么需要四次挥手"><a href="#6、简述-TCP-三次握手、四次挥手的流程？为什么需要三次握手？为什么需要四次挥手" class="headerlink" title="6、简述 TCP 三次握手、四次挥手的流程？为什么需要三次握手？为什么需要四次挥手"></a>6、简述 TCP 三次握手、四次挥手的流程？为什么需要三次握手？为什么需要四次挥手</h2><p><strong>TCP（Transmission Control Protocol）是⼀种⾯向连接的协议，为了保证数据传输的可靠性，TCP 使⽤了三次握⼿和四次挥⼿的过程。</strong></p>
<p>三次握⼿的过程如下：</p>
<ol>
<li>第⼀次握⼿：客户端向服务器发送 SYN 报⽂，请求建⽴连接。 </li>
<li>第⼆次握⼿：服务器收到客户端的 SYN 报⽂，向客户端发送 SYN+ACK 报⽂，表示可以建⽴连接。 </li>
<li>第三次握⼿：客户端收到服务器的 SYN+ACK 报⽂，向服务器发送 ACK 报⽂，表示连接已经建⽴。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240329193253075-1737881543399142.png" alt="image-20240329193253075"></p>
<p><strong>为什么需要三次握⼿？</strong></p>
<p>三次握⼿的⽬的是为了确认双⽅的收发能⼒和同步初始序列号。</p>
<p><strong>四次挥⼿的过程如下：</strong></p>
<p>第⼀次挥⼿：客户端向服务器发送 FIN 报⽂，请求关闭连接。 </p>
<p>第⼆次挥⼿：服务器收到客户端的 FIN 报⽂，向客户端发送 ACK 报⽂，表示收到关闭请求。 </p>
<p>第三次挥⼿：服务器向客户端发送 FIN 报⽂，请求关闭连接。 </p>
<p>第四次挥⼿：客户端收到服务器的 FIN 报⽂，向服务器发送 ACK 报⽂，表示收到关闭请求。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240329193414899-1737881543399143.png" alt="image-20240329193414899"></p>
<p><strong>为什么需要四次挥⼿？</strong></p>
<p>四次挥⼿的⽬<strong>的是为了保证数据的完整性和可靠性</strong>。在关闭连接之前，双⽅需要确保所有数据都已经传输完毕，因此需要通过四次挥⼿的过程进⾏确认和处理。</p>
<p><strong>总结：三次握⼿的本质是确认通信双⽅收发数据的能⼒ ，四次挥⼿的⽬的是关闭⼀个连接。</strong></p>
<p>举例：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/JOB-md.assets/image-20240329193608836-1737881543399144.png" alt="image-20240329193608836"></p>
<h2 id="7、HTTP协议为什么是无状态的？如何让HTTP“有状态”？"><a href="#7、HTTP协议为什么是无状态的？如何让HTTP“有状态”？" class="headerlink" title="7、HTTP协议为什么是无状态的？如何让HTTP“有状态”？"></a>7、<font color=red>HTTP协议为什么是无状态的？如何让HTTP“有状态”？</font></h2><p>无状态是指<strong>协议对于事务处理没有记忆能力，不能保存每次客户端提交的信息</strong>，即当服务器返回应答之后，这次事务的所有信息就都丢掉了。<strong>如果用户发来一个新的请求，服务器也无法知道它是否与上次的请求有联系。</strong></p>
<p>一个包含多图片的网页的浏览：</p>
<p>（1）建立连接，客户端发送一个请求，服务器端返回一个HTML页面（这里的页面只是一个纯文本的页面，也就是我们写的HTML代码），关闭连接；</p>
<p>（2）浏览器解析HTML文件，遇到图片标记得到url，这时，客户端和服务器再建立连接，客户端发送一个图片请求，服务器返回图片应答，关闭连接。【这里又涉及到无状态定义：对于服务器来说，这次的请求虽然是同一个客户端的请求但是服务器还是不知道这个是之前的那个客户端，即对于事务处理没有记忆能力】</p>
<p>优点：<strong>服务器不用为每个客户端连接分配内存来记忆大量状态，也不用在客户端失去连接时去清理内存，节省服务器端资源，以更高效地去处理业务</strong>。</p>
<p>缺点：<strong>缺少状态意味着如果后续处理需要前面的信息，则客户端必须重传，这样可能导致每次连接每次连接传送的数据量增大。</strong></p>
<p>解决HTTP无状态的方法：</p>
<p>四种会话跟踪技术：</p>
<ul>
<li><strong>COOKIE</strong>:服务器可以发送一个Cookie到客户端，客户端在后续的请求中会自动附带这个Cookie，服务器通过Cookie来识别用户。</li>
<li><strong>Session</strong>:服务器为每个用户创建一个会话（Session），会话中可以保存用户的状态信息。服务器会生成一个唯一的会话ID，并通过Cookie或其他方式发送给客户端，客户端在后续请求中提供这个会话ID，服务器据此恢复会话状态。</li>
<li><strong>Token Based Authentication</strong>：使用基于Token的认证方式，如JSON Web Tokens（JWT），服务器可以生成一个Token并通过<strong>URL重写将其嵌入到URL</strong>中。客户端在后续请求中提供这个Token，服务器验证Token的有效性来维持状态。（添加sessionid  ）</li>
<li><strong>作为隐藏域嵌入HTML表单中（隐藏表单域）</strong>:在Web表单中，可以将状态信息隐藏在表单的隐藏字段中，提交表单时这些信息会发送到服务器。</li>
</ul>
<h2 id="8、session的工作原理"><a href="#8、session的工作原理" class="headerlink" title="8、session的工作原理"></a>8、<font color=red>session的工作原理</font></h2><p>通过在<strong>服务器端存储用户的会话信息</strong>来实现。</p>
<p>当用户访问服务器时，服务器会为该用户创建一个唯一的 Session ID，并将该 ID 存储在用户的浏览器中，通常是通过设置 Cookie 的方式。服务器会将用户的会话信息存储在服务器端的内存或数据库中，并与该 Session ID 相关联。</p>
<p>当用户进行下一次请求时，浏览器会自动将之前存储的 Session ID 发送给服务器。服务器通过该 ID 来查找对应的会话信息，从而可以获取用户的状态和其他相关数据。服务器可以根据会话信息来判断用户的身份、权限等信息，并进行相应的处理和响应。<strong>当用户关闭浏览器或会话超时时，会话信息会被销毁或清除。</strong></p>
<p>几个步骤：</p>
<p>用户访问服务器，<strong>服务器为用户创建一个唯一的 Session ID，并将其发送给用户的浏览器</strong>。</p>
<p>浏览器将 <strong>Session ID 存储在 Cookie 中，以便下次请求时发送给服</strong>务器。</p>
<p>用户进行下一次请求时，浏览器<strong>会自动将之前存储的 Session ID</strong> 发送给服务器。</p>
<p>服务器根据该 <strong>Session ID 查找对应的会话信息，并进行相应的处理</strong>和响应。</p>
<p>用户关闭浏览器或会话超时时，会话信息会被销毁或清除。</p>
<p>通过 <strong>Session，服务器可以在不同的请求之间保持用户的状态，实现用户认证、用户数据的持久化</strong>等功能</p>
<hr>
<p>为什么关闭浏览器，会话结束？</p>
<p>关闭浏览器之后，浏览器中保存的sessionid消失，下次重新打开浏览器之后，浏览器缓存中没有这个sessionid，自然是找不到服务器中对应的session对象。session对象找不到等同于会话结束。</p>
<p>##9、HTTP（Hypertext Transfer Protocol）和HTTPS（Hypertext Transfer Protocol Secure）是互联网上用于数据传输的协议。它们的主要区别在于安全性。</p>
<ol>
<li><strong>HTTP</strong>：<ul>
<li>HTTP 是一个基于<strong>请求&#x2F;响应模式的、无状态的、应用层的协</strong>议。</li>
<li>它使用<strong>明文传输数据，不提供任何加密措施</strong>，这意味着传输的数据可以被中间人轻松地截获和读取。</li>
<li>HTTP <strong>不验证服务器的身份</strong>，这使得用户可能与恶意服务器进行通信。</li>
<li>尽管可以通过使用HTTP头信息（如”X-Forwarded-For”）来追踪客户端，但它不是一种安全的身份验证机制。</li>
</ul>
</li>
<li><strong>HTTPS</strong>：<ul>
<li>HTTPS 是 HTTP 的安全版本，它使用 <strong>SSL&#x2F;TLS 协议来加密数据传输</strong>。</li>
<li><strong>SSL（Secure Sockets Layer）和 TLS（Transport Layer Security）是用于加密通信的协议</strong>，它们使用公钥和私钥对数据进行加密和解密。</li>
<li>HTTPS <strong>验证服务器的身份，确保用户与真正的服务器通信</strong>。</li>
<li>它提供了一种安全的身份验证机制，使得客户端和服务器之间的通信更加安全。</li>
</ul>
</li>
</ol>
<p>##10、HTTP&#x2F;2和HTTP有什么区别？</p>
<ol>
<li><p><strong>二进制格式</strong>：</p>
<ul>
<li><strong>HTTP&#x2F;1.1</strong> 使用<strong>文本格式传</strong>输请求和响应头，这使得协议相对容易理解和调试，但也容易受到“空闲闲聊”问题的影响。</li>
<li><strong>HTTP&#x2F;2</strong> 使<strong>用二进制格</strong>式传输数据，这使得协议的解析更加高效，但也使得调试变得更加复杂。</li>
</ul>
</li>
<li><p><strong>多路复用</strong>：</p>
<ul>
<li><strong>HTTP&#x2F;1.1</strong> 使用持<strong>久连接，但在同一个 TCP 连接上，同一时间只能处理一个请求</strong>。这导致了队头阻塞（Head-of-Line Blocking）的问题，即一个请求的处理时间过长会阻塞其他请求。</li>
<li><strong>HTTP&#x2F;2</strong> 引入了<strong>多路复用，允许多个请求和响应在同一个 TCP 连接上并发传输，</strong>解决了队头阻塞的问题。</li>
</ul>
</li>
<li><p><strong>头部压缩</strong>：</p>
<ul>
<li><strong>HTTP&#x2F;1.1</strong> 中的请求和响应头部是每次传输都会重复的，这导致不必要的网络开销。</li>
<li><strong>HTTP&#x2F;2</strong> 使用 HPACK <strong>算法对头部进行压缩，减少了网络</strong>传输的头部大小。</li>
</ul>
</li>
<li><p><strong>服务器推送</strong>：</p>
<ul>
<li><strong>HTTP&#x2F;1.1</strong> <strong>不支持服务器推送</strong>，即服务器不能主动向客户端发送数据，除非客户端先发起请求。</li>
<li><strong>HTTP&#x2F;2</strong> 允许<strong>服务器在客户端请求某个资源时，主动推送其他相关的资</strong>源，从而减少了客户端的后续请求，提高了页面加载速度。</li>
</ul>
</li>
<li><p><strong>安全性</strong>：</p>
<ul>
<li><strong>HTTP&#x2F;1.1</strong> 使用明文传输数据，不提供任何加密措施，这意味着传输的数据可以被中间人轻松地截获和读取。</li>
<li><strong>HTTP&#x2F;2</strong> 默认情况下<strong>使用 TLS 进行加密传输，这是 HTTPS</strong> 的基础。</li>
</ul>
</li>
</ol>
<hr>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20241201172706205-1737881543399145.png" alt="image-20241201172706205"></p>
<h2 id="11、HTTP和TCP的联系是什么"><a href="#11、HTTP和TCP的联系是什么" class="headerlink" title="11、HTTP和TCP的联系是什么"></a>11、HTTP和TCP的联系是什么</h2><ol>
<li><strong>TCP</strong>：<ul>
<li>TCP 是一种传输层协议，负责在网络中的两个端点之间建立可靠的、有序的、无重复的数据传输。</li>
<li>TCP 提供<strong>流量控制、拥塞控制和错误检测等功能，以确保数据传输的可靠性和高效性</strong>。</li>
<li><strong>TCP 建立连接、管理连接状态、传输数据和关闭连接。</strong></li>
</ul>
</li>
<li><strong>HTTP</strong>：<ul>
<li>HTTP 是一种应用层协议，用于在 Web 浏览器和服务器之间传输超文本数据。</li>
<li><strong>HTTP 依赖于 TCP 提供的可靠传输服务，它使用 TCP 连接来发送请求和接收响应</strong>。</li>
<li><strong>HTTP 定义了请求和响应的结构，包括头部（headers）和主体（body）</strong>。</li>
</ul>
</li>
</ol>
<h2 id="12、Https的握手过程（HyperText-Transfer-Protocol-over-Secure-Socket-Layer）"><a href="#12、Https的握手过程（HyperText-Transfer-Protocol-over-Secure-Socket-Layer）" class="headerlink" title="12、Https的握手过程（HyperText Transfer Protocol over Secure Socket Layer）"></a>12、Https的握手过程（HyperText Transfer Protocol over Secure Socket Layer）</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_52165864/article/details/138059978?ops_request_misc=%7B%22request_id%22:%22CAA73AA9-20DB-4277-BE53-12B8A83CE0D3%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=CAA73AA9-20DB-4277-BE53-12B8A83CE0D3&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-138059978-null-null.142%5Ev100%5Epc_search_result_base2&utm_term=https%E7%9A%84%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B&spm=1018.2226.3001.4187">HTTPS协议的详细讲解（四次握手）_ssl握手协议的四个步骤-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1KY411x7Jp/?spm_id_from=333.337.search-card.all.click&vd_source=03235a8277a4e1950048927a7c975e38">HTTPS是什么？加密原理和证书。SSL&#x2F;TLS握手过程_哔哩哔哩_bilibili</a></p>
<p>第一随机数、第二随机数、预主密钥</p>
<p>##13、数据库结构</p>
<p> <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Kg411z7RS?spm_id_from=333.788.videopod.sections&vd_source=03235a8277a4e1950048927a7c975e38">https://www.bilibili.com/video/BV1Kg411z7RS?spm_id_from=333.788.videopod.sections&amp;vd_source=03235a8277a4e1950048927a7c975e38</a></p>
<p>数据执行原理</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240902164849712-1737881543399146.png" alt="image-20240902164849712" style="zoom: 67%;" />



<p>SQL执行原理：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240902180151733-1737881543399147.png" alt="image-20240902180151733"></p>
<p>创建索引：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_62336297/article/details/125963674?ops_request_misc=%7B%22request_id%22:%22D1FAF342-AF31-4E9D-B986-37A972059358%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=D1FAF342-AF31-4E9D-B986-37A972059358&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-125963674-null-null.142%5Ev100%5Epc_search_result_base2&utm_term=%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95&spm=1018.2226.3001.4187">【创建索引的三种方式】-CSDN博客</a></p>
<p>区别：</p>
<ul>
<li><code>UNIQUE KEY</code> 可以包含多个列，而 <code>UNIQUE</code> 通常只指定单个列。</li>
<li><code>UNIQUE KEY</code> 允许列上有 <code>NULL</code> 值，而 <code>UNIQUE</code> 约束通常不允许列上有 <code>NULL</code> 值。</li>
<li>在某些数据库系统中（如 MySQL），<code>UNIQUE KEY</code> 可以在创建表时与 <code>PRIMARY KEY</code> 一起使用，而 <code>UNIQUE</code> 约束不能。</li>
</ul>
<h2 id="14、DNS解析"><a href="#14、DNS解析" class="headerlink" title="14、DNS解析"></a>14、DNS解析</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240909155303215-1737881543399148.png" alt="image-20240909155303215"></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1uL4y1B7aE/?spm_id_from=333.788&vd_source=03235a8277a4e1950048927a7c975e38">DNS域名解析过程_哔哩哔哩_bilibili</a></p>
<h2 id="15、UDP的多播和广播"><a href="#15、UDP的多播和广播" class="headerlink" title="15、UDP的多播和广播"></a>15、UDP的多播和广播</h2><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240909222306025-1737881543399149.png" alt="image-20240909222306025" style="zoom:67%;" />



<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240909222330163-1737881543399150.png" alt="image-20240909222330163" style="zoom:67%;" />



<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240909222419620-1737881543399151.png" alt="image-20240909222419620" style="zoom:67%;" />





<p>##16、阻塞I&#x2F;O和多路复用I&#x2F;O</p>
<p>阻塞I&#x2F;O和多路复用I&#x2F;O是两种不同的I&#x2F;O处理模型，它们各自适用于不同的场景。尽管多路复用I&#x2F;O在处理大量并发连接时通常更为高效，但阻塞I&#x2F;O在某些特定情况下仍然有其优点：</p>
<ol>
<li><strong>简单性</strong>：<ul>
<li><strong>编程模型简单</strong>：阻塞I&#x2F;O的编程模型相对简单直观。当线程发起一个I&#x2F;O操作时，它会阻塞直到操作完成，不需要额外的逻辑来处理I&#x2F;O事件。</li>
<li><strong>易于理解和维护</strong>：由于代码逻辑是顺序执行的，所以更容易理解和维护。</li>
</ul>
</li>
<li><strong>资源使用</strong>：<ul>
<li><strong>线程资源</strong>：阻塞I&#x2F;O通常与每个连接一个线程的模型相对应，这在某些情况下可能更易于资源管理，尤其是在连接数不是很多的情况下。</li>
<li><strong>上下文切换开销</strong>：在阻塞I&#x2F;O模型中，线程在I&#x2F;O操作期间处于阻塞状态，不会占用CPU资源，从而减少了上下文切换的开销。</li>
</ul>
</li>
<li><strong>同步操作</strong>：<ul>
<li><strong>同步处理</strong>：阻塞I&#x2F;O天然是同步的，这意味着在I&#x2F;O操作完成之前，线程会一直等待，这对于某些需要严格顺序执行的操作是有利的。</li>
</ul>
</li>
<li><strong>负载均衡</strong>：<ul>
<li><strong>负载均衡</strong>：在某些系统中，每个CPU核心可以运行一个阻塞I&#x2F;O的线程，这样可以实现负载均衡，因为每个核心都可以独立处理I&#x2F;O操作。</li>
</ul>
</li>
<li><strong>延迟</strong>：<ul>
<li><strong>可能更低的延迟</strong>：在某些情况下，特别是在处理少量连接时，阻塞I&#x2F;O可能会提供更低的延迟，因为它不需要像多路复用I&#x2F;O那样在多个文件描述符之间进行轮询。</li>
</ul>
</li>
<li><strong>兼容性</strong>：<ul>
<li><strong>兼容旧代码</strong>：对于一些旧有的或者现有的系统，可能已经使用了阻塞I&#x2F;O模型，因此在没有充足理由的情况下，可能不需要重构代码以使用多路复用I&#x2F;O。</li>
</ul>
</li>
</ol>
<p>尽管有上述优点，但在处理大量并发连接时，阻塞I&#x2F;O模型的缺点也相当明显，比如线程资源的大量消耗、无法有效利用CPU资源等。因此，在需要高并发处理的应用中，多路复用I&#x2F;O通常是更优的选择。然而，对于一些简单的应用或者那些不需要处理大量并发连接的服务，阻塞I&#x2F;O仍然是一个有效的解决方案。</p>
<p>##17、TCP</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/3-1737881543399152.jpg" style="zoom: 67%;" />

<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_feature.html#sack-%E6%96%B9%E6%B3%95">https://xiaolincoding.com/network/3_tcp/tcp_feature.html#sack-%E6%96%B9%E6%B3%95</a></p>
<p>重传机制：防止丢包</p>
<p>流量控制：<strong>TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量</strong></p>
<p>​		1、这里存在一个死锁现象：当发生窗口关闭时，接收方处理完数据后，会向发送方通告一个窗口非0的 ACK 报文，如果这个通告窗口的 ACK 报文在网络中丢失了，那麻烦就大了。</p>
<p>​		定时器不停询问：为了解决这个问题，TCP 为每个连接设有一个持续定时器，只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。</p>
<p>​		2、糊涂窗口：避免发送小数据引起的网络损耗</p>
<p>​		解决方式：<strong>接收方得满足「不通告小窗口给发送方」+ 发送方开启 Nagle 算法，才能避免糊涂窗口综合症</strong>。</p>
<p>拥塞控制：一般来说，计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。<strong>拥塞控制</strong>的目的就是<strong>避免「发送方」的数据填满整个网络。</strong>为了在「发送方」调节所要发送数据的量，定义了一个叫做「<strong>拥塞窗口</strong>」的概念。<strong>拥塞窗口 cwnd</strong>是发送方维护的一个的状态变量，它会根据<strong>网络的拥塞程度动态变化的</strong>。</p>
<p>怎么判断是否发生：其实只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是发生了超时重传，就会认为网络出现了拥塞</p>
<p>拥塞控制主要是四个算法：</p>
<ul>
<li><strong>慢启动</strong></li>
<li><strong>拥塞避免</strong></li>
<li><strong>拥塞发生</strong></li>
<li><strong>快速恢复</strong></li>
</ul>
<p>1、一个ACK，增加1</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/27-1737881543399153.jpg" style="zoom:50%;" />

<p>可以看出慢启动算法，发包的个数是<strong>指数性的增长</strong>。</p>
<p>2、当 <code>cwnd</code> &gt;&#x3D; <code>ssthresh</code>（65536） 时，就会使用「拥塞避免算法」。一个ACK，增加一个拥塞窗口大小分之一</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/28-1737881543399154.jpg" style="zoom:50%;" />

<p>3、当触发了重传机制，也就进入了「拥塞发生算法」。出现丢包，重传</p>
<p>​	1、超时重传</p>
<p>​		<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/29-1737881543399155.jpg" style="zoom:50%;" /></p>
<p>​	2、快速重传</p>
<p>​	<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20241201221614358-1737881543399156.png" alt="image-20241201221614358"></p>
<p>4、快速恢复</p>
<p>快速重传和快速恢复算法一般同时使用，快速恢复算法是认为，你还能收到3个重复 ACK 说明网络也不那么糟糕，所以没有必要像 RTO 超时那么强烈。</p>
<p>正如前面所说，进入快速恢复之前，Cwnd和ssthresh已被更新了:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cwnd = cwnd/<span class="number">2</span>     <span class="comment">//也就是设置为原来的一半;</span></span><br><span class="line">ssthresh = cwnd</span><br></pre></td></tr></table></figure>

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/%E6%8B%A5%E5%A1%9E%E5%8F%91%E7%94%9F-%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0.drawio-1737881543399157.png" style="zoom:50%;" />



<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="1、什么是进程和线程？它们有哪些区别和联系？"><a href="#1、什么是进程和线程？它们有哪些区别和联系？" class="headerlink" title="1、什么是进程和线程？它们有哪些区别和联系？"></a>1、什么是进程和线程？它们有哪些区别和联系？</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240329202141880-1737881543399158.png" alt="image-20240329202141880"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240516225341937-1737881543399159.png" alt="image-20240516225341937"></p>
<h2 id="2、死锁是什么？如何预防和避免死锁？"><a href="#2、死锁是什么？如何预防和避免死锁？" class="headerlink" title="2、死锁是什么？如何预防和避免死锁？"></a>2、死锁是什么？如何预防和避免死锁？</h2><p><strong>死锁是什么？</strong></p>
<p>多线程编程中，当两个线程为了保护两个不同的共享资源⽽使⽤了两个互斥锁，如果应⽤不当，会造成两个线程都在等待对⽅释放锁，没有外⼒的作⽤下，这些线程会⼀直互相等待，就没办法继续运⾏，这就是发⽣了死锁。</p>
<p><strong>如何预防和避免死锁？</strong></p>
<p>结合前面死锁的四个必要条件进行总结</p>
<p>只要破坏其中⼀个必要条件就可以避免死锁，最常⻅的并且可⾏的就是使⽤资源有序分配法，来破坏环路等待条件</p>
<p>例⼦1：线程之间如何避免死锁</p>
<ul>
<li><p>线程A和线程B获取资源的顺序要⼀样 </p>
</li>
<li><p>线程 A 是先尝试获取资源 A，然后尝试获取资源 B 的时候 </p>
</li>
<li><p>线程 B 同样也是先尝试获取资源 A，然后尝试获取资源 B </p>
</li>
<li><p>线程 A 和 线程 B 总是以相同的顺序申请⾃⼰想要的资源</p>
</li>
</ul>
<p>例⼦2：MySQL 如何避免死锁</p>
<ol>
<li>设置事务等待锁的超时时间 </li>
<li>开启主动死锁检测</li>
</ol>
<p>其他：利⽤⼯具排查死锁问题</p>
<ul>
<li>java：jstack </li>
<li>C：pstack + gdb</li>
</ul>
<h2 id="3、线程间有哪些通信⽅式？"><a href="#3、线程间有哪些通信⽅式？" class="headerlink" title="3、线程间有哪些通信⽅式？"></a>3、线程间有哪些通信⽅式？</h2><p><strong>共享内存</strong>：多个线程共享同⼀块内存空间，通过对内存的读写操作实现线程间的信息交换。可以使⽤  synchronized 关键字或 Lock 接⼝等机制来确保线程安全。</p>
<p><strong>消息传递</strong>：多个线程之间通过消息传递实现信息交换。在Java中，可以使⽤wait()、notify()和notifyAll()等⽅法来实现线程间消息传递。wait()⽅法会使当前线程等待，直到其他线程调⽤notify()或notifyAll()⽅法唤醒它；notify()⽅ 法会随机唤醒等待队列中的⼀个线程；notifyAll()⽅法会唤醒等待队列中的所有线程。</p>
<p><strong>信号量</strong>：通过信号量机制实现线程间的信息交换。Java中的 Semaphore 类就是⼀个信号量实现。</p>
<p><strong>管道</strong>：管道是⼀种特殊的流，⽤于在线程之间传递数据。Java 中的 PipedInputStream 和 PipedOutputStream 类 就是管道的实现。</p>
<p><strong>RPC调⽤</strong>：远程过程调⽤（RPC）是⼀种跨⽹络进⾏的远程调⽤，可以实现在不同的线程或机器之间进⾏信息交换。</p>
<p><strong>线程间通信与进程间通信的区别</strong> （扩展）</p>
<p><strong>线程是轻量级的进程，系统进⾏资源调度的基本单位是进程</strong>，但是因为进程上下⽂切换开销太⼤，所以有了线程，节省开销。 线程本身也是共享进程的内存，上下⽂切换⽅便。 </p>
<p>安全性，线程间通信的安全性相对较低，需要采⽤同步机制来保证共享变量的正确性；</p>
<p>⽽进程间通信的安全性相对较⾼，进程之间相互隔离，不会对对⽅的内存进⾏⾮法操作。</p>
<h2 id="4、什么是零拷⻉？说⼀说你对零拷⻉的理解？"><a href="#4、什么是零拷⻉？说⼀说你对零拷⻉的理解？" class="headerlink" title="4、什么是零拷⻉？说⼀说你对零拷⻉的理解？*"></a>4、什么是零拷⻉？说⼀说你对零拷⻉的理解？<font color='red'>*</font></h2><p><strong>本质：主要是因为建立了PageCache 到用户进程的虚拟地址映射（mmap file 存储在共享区域），从而避免了Pagecache和用户空间拷贝的过程。减少了一次拷贝。</strong></p>
<p><strong>上面是Mmap方式，sendfile方式在此基础上减少了两次上下文切换，直接从内核缓冲区拷贝到socket缓冲区。</strong></p>
<p>零拷⻉（Zero-Copy）是⼀种⾼效的数据传输技术，它可以将数据从内核空间直接传输到应⽤程序的内存空间中， 避免了不必要的数据拷⻉，从⽽提⾼了数据传输的效率和性能。</p>
<p><strong>传统IO：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240329203213572-1737881543400160.png" alt="image-20240329203213572"></p>
<p><strong>零拷⻉：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240329203237084-1737881543400162.png" alt="image-20240329203237084"></p>
<ol>
<li>java 调⽤ transferTo ⽅法后，要从 java 程序的⽤户态切换⾄内核态，使⽤ DMA 将数据读⼊内核缓冲区，不会使⽤ cpu </li>
<li>只会将⼀些 offset 和 length 信息拷⼊ socket 缓冲区，⼏乎⽆消耗 </li>
<li>使⽤ DMA 将 内核缓冲区的数据写⼊⽹卡，不会使⽤ cpu</li>
</ol>
<p>整个过程仅只发⽣了⼀次⽤户态与内核态的切换，数据拷⻉了 2 次。所谓的【零拷⻉】，<strong>并不是真正⽆拷⻉</strong>，⽽是 在不会拷⻉重复数据到 jvm 内存中，零拷⻉的优点有</p>
<ul>
<li>**更少的⽤户态与内核态的切换 **</li>
<li>**不利⽤ cpu 计算，减少 cpu 缓存伪共享 **</li>
<li><strong>零拷⻉适合⼩⽂件传输</strong></li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240621220313633-1737881543400161.png" alt="image-20240621220313633"></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240621220634318-1737881543400163.png" alt="image-20240621220634318"></p>
<p>#Linux</p>
<h2 id="1、Linux-中的硬链接和软连接是什么，⼆者有什么区别？"><a href="#1、Linux-中的硬链接和软连接是什么，⼆者有什么区别？" class="headerlink" title="1、Linux 中的硬链接和软连接是什么，⼆者有什么区别？"></a>1、Linux 中的硬链接和软连接是什么，⼆者有什么区别？</h2><h3 id="硬链接（Hard-Link）和软链接（Soft-Link）："><a href="#硬链接（Hard-Link）和软链接（Soft-Link）：" class="headerlink" title="硬链接（Hard Link）和软链接（Soft Link）："></a><strong>硬链接（Hard Link）和软链接（Soft Link）</strong>：</h3><p>在 Linux 中，<strong>硬链接和软链接（符号链接）是两种实现文件链接的方式，它们用于指向文件系统中的文件或目录</strong>。</p>
<hr>
<h3 id="1-硬链接（Hard-Link）："><a href="#1-硬链接（Hard-Link）：" class="headerlink" title="1. 硬链接（Hard Link）："></a><strong>1. 硬链接（Hard Link）：</strong></h3><ul>
<li>硬链接是指向文件在存储设备上的物理位置（即 inode）的引用。</li>
<li>创建硬链接后，多个文件名（路径）<strong>共享</strong>同一个 inode。</li>
<li><strong>文件的内容在所有硬链接中是相同的，删除任何一个硬链接不会影响其余链接的访问</strong>。</li>
<li><strong>只有当所有硬链接被删除后，文件的内容才会从存储设备中移除。</strong></li>
<li>inode值会记录硬链接的个数</li>
</ul>
<h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a><strong>特点：</strong></h4><ol>
<li><strong>共享 inode</strong>：硬链接文件共享相同的 inode 号。</li>
<li><strong>不能跨文件系统</strong>：硬链接必须在同一文件系统内。</li>
<li><strong>不能对目录创建硬链接</strong>：为了避免循环引用。</li>
<li><strong>数据安全</strong>：即使删除了原始文件名，硬链接依然可以访问文件内容。</li>
</ol>
<h4 id="创建方式："><a href="#创建方式：" class="headerlink" title="创建方式："></a><strong>创建方式：</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> source_file hard_link_name</span><br></pre></td></tr></table></figure>

<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a><strong>示例：</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;Hello, world&quot;</span> &gt; original.txt</span><br><span class="line">$ <span class="built_in">ln</span> original.txt hardlink.txt</span><br><span class="line">$ <span class="built_in">ls</span> -li</span><br><span class="line">123456 -rw-r--r-- 2 user group 14 Nov 26 12:00 hardlink.txt</span><br><span class="line">123456 -rw-r--r-- 2 user group 14 Nov 26 12:00 original.txt</span><br></pre></td></tr></table></figure>

<ul>
<li>两个文件的 inode 号相同，说明它们指向同一个文件内容。</li>
</ul>
<hr>
<h3 id="2-软链接（Soft-Link）："><a href="#2-软链接（Soft-Link）：" class="headerlink" title="2. 软链接（Soft Link）："></a><strong>2. 软链接（Soft Link）：</strong></h3><ul>
<li>软链接是一个独立的文件，包含指向目标文件的路径信息。</li>
<li>类似于 Windows 的快捷方式。</li>
<li>删除目标文件后，软链接会失效，成为“断开的链接”。</li>
<li>软链接可以跨文件系统，也可以指向目录。</li>
</ul>
<h4 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a><strong>特点：</strong></h4><ol>
<li><strong>独立 inode</strong>：软链接文件有自己的 inode，不与目标文件共享。</li>
<li><strong>可以跨文件系统</strong>：因为它只保存目标文件的路径。</li>
<li><strong>可以指向目录</strong>：软链接可以指向文件或目录。</li>
<li><strong>路径依赖</strong>：如果目标文件被移动或删除，软链接会失效。</li>
</ol>
<h4 id="创建方式：-1"><a href="#创建方式：-1" class="headerlink" title="创建方式："></a><strong>创建方式：</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s source_file soft_link_name</span><br></pre></td></tr></table></figure>

<h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a><strong>示例：</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;Hello, world&quot;</span> &gt; original.txt</span><br><span class="line">$ <span class="built_in">ln</span> -s original.txt softlink.txt</span><br><span class="line">$ <span class="built_in">ls</span> -li</span><br><span class="line">123456 -rw-r--r-- 1 user group 14 Nov 26 12:00 original.txt</span><br><span class="line">789012 lrwxrwxrwx 1 user group 14 Nov 26 12:00 softlink.txt -&gt; original.txt</span><br></pre></td></tr></table></figure>

<ul>
<li><code>softlink.txt</code> 指向 <code>original.txt</code>，但它们的 inode 不同。</li>
</ul>
<hr>
<h3 id="3-区别总结："><a href="#3-区别总结：" class="headerlink" title="3. 区别总结："></a><strong>3. 区别总结：</strong></h3><table>
<thead>
<tr>
<th>特性</th>
<th>硬链接</th>
<th>软链接</th>
</tr>
</thead>
<tbody><tr>
<td><strong>本质</strong></td>
<td>指向同一个 inode</td>
<td>指向目标文件路径</td>
</tr>
<tr>
<td><strong>inode 共享</strong></td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td><strong>是否独立文件</strong></td>
<td>否，共享文件</td>
<td>是，独立文件</td>
</tr>
<tr>
<td><strong>跨文件系统</strong></td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td><strong>能否指向目录</strong></td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td><strong>目标被删除影响</strong></td>
<td>不影响</td>
<td>会失效</td>
</tr>
<tr>
<td><strong>创建命令</strong></td>
<td><code>ln source_file link_name</code></td>
<td><code>ln -s source_file link_name</code></td>
</tr>
</tbody></table>
<hr>
<h3 id="实际使用场景："><a href="#实际使用场景：" class="headerlink" title="实际使用场景："></a><strong>实际使用场景：</strong></h3><ol>
<li><strong>硬链接</strong>：<ul>
<li>用于需要多个路径指向相同文件内容且文件名和内容独立管理的场景（如备份中节省空间）。</li>
<li>适合需要数据安全的场景（原始文件被删除，数据仍可通过硬链接访问）。</li>
</ul>
</li>
<li><strong>软链接</strong>：<ul>
<li>用于需要指向目录或跨文件系统链接的场景。</li>
<li>适合快捷访问文件或目录（如配置文件链接 <code>/etc/</code> 中的 <code>nginx.conf</code>）。</li>
</ul>
</li>
</ol>
<h2 id="2、CC-攻击是什么？什么叫-DDOS-攻击？什么是⽹站数据库注⼊？"><a href="#2、CC-攻击是什么？什么叫-DDOS-攻击？什么是⽹站数据库注⼊？" class="headerlink" title="2、CC 攻击是什么？什么叫 DDOS 攻击？什么是⽹站数据库注⼊？"></a>2、CC 攻击是什么？什么叫 DDOS 攻击？什么是⽹站数据库注⼊？</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240329194902277-1737881543400164.png" alt="image-20240329194902277"></p>
<h2 id="3、如何在-Linux-中查看系统资源使⽤情况？⽐如内存、CPU、⽹络端口。"><a href="#3、如何在-Linux-中查看系统资源使⽤情况？⽐如内存、CPU、⽹络端口。" class="headerlink" title="3、如何在 Linux 中查看系统资源使⽤情况？⽐如内存、CPU、⽹络端口。"></a>3、如何在 Linux 中查看系统资源使⽤情况？⽐如内存、CPU、⽹络端口。</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240329194624144-1737881543400165.png" alt="image-20240329194624144"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240329194643040-1737881543400166.png" alt="image-20240329194643040"></p>
<h2 id="4、Linux的swap-类似于Windows的虚拟内存"><a href="#4、Linux的swap-类似于Windows的虚拟内存" class="headerlink" title="4、Linux的swap  (类似于Windows的虚拟内存)"></a>4、Linux的swap  (类似于Windows的虚拟内存)</h2><p>在Linux系统中，<strong>swap（交换空间）</strong>是一种用来扩展系统虚拟内存的技术。当物理内存（RAM）不足以满足正在运行的所有程序的需求时，系统可以将一些暂时不需要的内存页移动到硬盘的swap空间，以释放物理内存用于当前需要的任务。</p>
<h3 id="swap的作用"><a href="#swap的作用" class="headerlink" title="swap的作用"></a><strong>swap的作用</strong></h3><ol>
<li><strong>扩展内存容量</strong>：当物理内存不足时，系统可以将一部分的数据存储到swap分区中，从而扩展内存容量。</li>
<li><strong>内存回收</strong>：一些将死或无用的进程的资源可以移到swap分区中，有助于优化系统。</li>
<li><strong>休眠支持</strong>：系统进入休眠（hibernate）时，会将内存中的内容保存到swap中，以便在唤醒之后，快速会恢复到之前的状态。</li>
</ol>
<h3 id="swap的类型"><a href="#swap的类型" class="headerlink" title="swap的类型"></a><strong>swap的类型</strong></h3><ol>
<li><strong>交换分区</strong>：<ul>
<li>在硬盘上划分一个固定大小的分区专门用作swap。</li>
<li>性能相对较高。</li>
</ul>
</li>
<li>交换文件：<ul>
<li>使用一个普通的文件作为swap。</li>
<li>更灵活，因为可以随时调整或创建。</li>
</ul>
</li>
</ol>
<h3 id="查看swap使用情况"><a href="#查看swap使用情况" class="headerlink" title="查看swap使用情况"></a>查看swap使用情况</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">swapon --show或者free -h</span><br></pre></td></tr></table></figure>





<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/91143a6dd3952d4207b29eaebcaba229-1737881543400167.png"></p>
<h2 id="0、介绍一下红黑树"><a href="#0、介绍一下红黑树" class="headerlink" title="0、介绍一下红黑树"></a>0、介绍一下红黑树</h2><p>红黑树是一种自平衡的<strong>二叉查找树</strong>，它在每个节点上增加了一个存储位来表示节点的颜色，可以是红色或黑色。红黑树通过以下五个性质来保持平衡，确保树的高度大致为对数级别，从而使得查找、插入和删除操作的<strong>时间复杂度最坏情况下为O(log n)：</strong></p>
<ol>
<li><p><strong>每个节点要么是红色，要么是黑色。</strong></p>
</li>
<li><p><strong>根节点是黑色。</strong></p>
</li>
<li><p>每个叶子节点（NULL节点，空节点）是黑色。</p>
</li>
<li><p>如果一个节点是红色的，则它的两个子节点都是黑色的（从每个叶子到根的所有路径上不会有两个连续的红色节点）。</p>
</li>
<li><p><strong>从任一节点到其每个叶子节点的所有路径都包含相同数目的黑色节点</strong>。</p>
<p>红黑树的这些性质确保了树的大致平衡，使得操作效率得以保证。在插入或删除节点时，为了维持这些性质，可能需要进行以下颜色变更和旋转操作：</p>
</li>
</ol>
<ul>
<li><strong>颜色变更</strong>：改变某些节点的颜色。</li>
<li><strong>左旋转</strong>：围绕某个节点向左旋转，以保持树的平衡。</li>
<li><strong>右旋转</strong>：围绕某个节点向右旋转，以保持树的平衡。<br>红黑树相较于其他自平衡二叉查找树，如AVL树，在插入和删除操作时可能更为高效，因为红黑树不需要像AVL树那样频繁地进行平衡操作。然而，红黑树的平衡标准比AVL树宽松，导致红黑树的高度可能会比AVL树稍高。</li>
</ul>
<h2 id="1、ConcurrentHashMap和Hashtable的区别"><a href="#1、ConcurrentHashMap和Hashtable的区别" class="headerlink" title="1、ConcurrentHashMap和Hashtable的区别"></a>1、ConcurrentHashMap和Hashtable的区别</h2><p><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别主要体现在实现<strong>线程安全</strong>的方式上不同。</p>
<p><strong>底层数据结构：</strong> JDK1.7 的 <code>ConcurrentHashMap</code> 底层采用 <strong>分段的数组+链表</strong>(<code>Segment</code> 数组结构（16）和 <code>HashEntry</code> 数组结构+链表数据结构) 实现，JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，数组+链表&#x2F;红黑二叉树。<code>Hashtable</code> 和 JDK1.8 之前的 <code>HashMap</code> 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</p>
<p><strong>实现线程安全的方式（重要）</strong>:</p>
<ul>
<li><p>在 JDK1.7 的时候，<code>ConcurrentHashMap</code> 对整个桶数组进行了分割分段(<code>Segment</code>，分段锁)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。</p>
</li>
<li><p>到了 JDK1.8 的时候，<code>ConcurrentHashMap</code> 已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node</code> 数组+链表+红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。（JDK1.6 以后 <code>synchronized</code> 锁做了很多优化） 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</p>
</li>
<li><p><strong><code>Hashtable</code>(同一把锁)</strong> :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</p>
</li>
</ul>
<p>**Java 8 几乎完全重写了 <code>ConcurrentHashMap</code>**，代码量从原来 Java 7 中的 1000 多行，变成了现在的 6000 多行。</p>
<p><code>ConcurrentHashMap</code> 取消了 <code>Segment</code> 分段锁，采用 <code>Node + CAS + synchronized</code> 来保证并发安全。数据结构跟 <code>HashMap</code> 1.8 的结构类似，数组+链表&#x2F;红黑二叉树。<strong>Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）</strong>。</p>
<p><strong>Java 8 中，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升。</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>ConcurrentHashMap</th>
<th>Hashtable</th>
</tr>
</thead>
<tbody><tr>
<td><strong>线程安全性</strong></td>
<td>是线程安全的，但使用了更细粒度的锁，分段锁（Java 8之后改为CAS操作）提高并发性能</td>
<td>是线程安全的，但使用了同步锁（synchronized），性能较低</td>
</tr>
<tr>
<td><strong>锁机制</strong></td>
<td>分段锁（Java 7 之前），Java 8 之后改用 CAS 操作来实现无锁化</td>
<td>全表锁（synchronized），每次操作都会锁住整个表</td>
</tr>
<tr>
<td><strong>Null键与Null值</strong></td>
<td>不允许 <code>null</code> 键和 <code>null</code> 值</td>
<td>不允许 <code>null</code> 键和 <code>null</code> 值</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>高性能，适合多线程高并发场景</td>
<td>性能较低，锁机制导致并发性能下降</td>
</tr>
<tr>
<td><strong>分割机制</strong></td>
<td>默认将数据分为多个段，减少竞争</td>
<td>无分割机制，所有数据放在一起</td>
</tr>
<tr>
<td><strong>并发度控制</strong></td>
<td>可以通过 <code>concurrencyLevel</code> 参数设置并发访问数量</td>
<td>不支持并发度控制</td>
</tr>
<tr>
<td><strong>迭代器的安全性</strong></td>
<td>迭代器为弱一致性（Weakly Consistent），不抛出 <code>ConcurrentModificationException</code></td>
<td>迭代器为快速失败（fail-fast），修改时抛出 <code>ConcurrentModificationException</code></td>
</tr>
<tr>
<td><strong>典型应用场景</strong></td>
<td>高并发读写操作的场景</td>
<td>单线程或低并发的线程安全要求的场景</td>
</tr>
<tr>
<td><strong>实现层面</strong></td>
<td>Java 8 中基于 CAS 和 Node 数组，减少锁的使用</td>
<td>基于 synchronized 锁和 Entry 数组</td>
</tr>
</tbody></table>
<p><strong>高并发：系统运行过程中遇到的一种“短时间内遇到大量操作请求”的情况，例如某个时间节点用户大量访问。服务器会承担巨大压力，会造成响应时间变慢。好的一个系统其吞吐量（单位时间内处理的请求数量）应该可以、承担每秒查询率QPS（Query Per Second)高</strong></p>
<h2 id="2、LinkedList为什么不能实现RandomAccess接口？"><a href="#2、LinkedList为什么不能实现RandomAccess接口？" class="headerlink" title="2、LinkedList为什么不能实现RandomAccess接口？"></a>2、LinkedList为什么不能实现RandomAccess接口？</h2><p>RandomAccess 是一个标记接口，用来表明实现该接口的类支持随机访问（即可以通过索引快速访问元素）。由于 LinkedList 底层数据结构是链表，内存地址不连续，只能通过指针来定位，不支持随机快速访问，所以不能实现 RandomAccess 接口。</p>
<h2 id="3、ArrayList与LinkedList区别？"><a href="#3、ArrayList与LinkedList区别？" class="headerlink" title="3、ArrayList与LinkedList区别？"></a>3、ArrayList与LinkedList区别？</h2><p>​		是否保证<strong>线程安全</strong>： ArrayList 和 LinkedList 都是不同步的，也就是<strong>不保证线程安全</strong>；<br>​		底层<strong>数据结构</strong>： ArrayList 底层使用的是 Object 数组；LinkedList 底层使用的是 双向链表 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别）<br>​		插入和删除是否受<strong>元素位置</strong>的影响：ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行add(E e)方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（add(int index, E element)），时间复杂度就为 O(n)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位&#x2F;向前移一位的操作。<br>LinkedList 采用链表存储，所以在头尾插入或者删除元素不受元素位置的影响（add(E e)、addFirst(E e)、addLast(E e)、removeFirst()、 removeLast()），时间复杂度为 O(1)，如果是要在指定位置 i 插入和删除元素的话（add(int index, E element)，remove(Object o),remove(int index)）， 时间复杂度为 O(n) ，因为需要先移动到指定位置再插入和删除。<br>​	是否支持<strong>快速随机访问</strong>： LinkedList 不支持高效的随机元素访问，而 ArrayList（实现了 RandomAccess 接口） 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。<br>​	<strong>内存空间占用</strong>： ArrayList 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</p>
<h2 id="4、ArrayList的扩容机制"><a href="#4、ArrayList的扩容机制" class="headerlink" title="4、ArrayList的扩容机制"></a>4、ArrayList的扩容机制</h2><p>以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 <strong>10</strong></p>
<p>如果ArrayList的当前大小不足以容纳新的元素，那么ArrayList就需要进行扩容操作。 在扩容操作中，ArrayList会创建一个新的数组，新数组的大小是原数组大小的1.5倍（也就是原数组大小+原数组大小的一半）。 这个1.5倍的值是在JDK的源码中定义的。 然后，ArrayList会使用 <strong>System.arraycopy</strong> 方法，将原有数组中的所有元素复制到新的数组中。</p>
<p>ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！ 奇偶不同，比如：10+10&#x2F;2 &#x3D; 15, 33+33&#x2F;2&#x3D;49。如果是奇数的话会丢掉小数。</p>
<h2 id="5、Comparable-和-Comparator-的区别"><a href="#5、Comparable-和-Comparator-的区别" class="headerlink" title="5、Comparable 和 Comparator 的区别"></a>5、Comparable 和 Comparator 的区别</h2><p>Comparable 接口和 Comparator 接口都是 Java 中用于排序的接口，它们在实现类对象之间比较大小、排序等方面发挥了重要作用：</p>
<ul>
<li><p>Comparable 接口实际上是出自java.lang包 它有一个 compareTo(Object obj)方法用来排序</p>
</li>
<li><p>Comparator接口实际上是出自 java.util 包它有一个compare(Object obj1, Object obj2)方法用来排序</p>
</li>
<li><p>Comparable接口将比较代码嵌入需要进行比较的类的自身代码中，而Comparator接口在一个独立的类中实现比较。</p>
</li>
<li><p>Comparable接口强制进行自然排序，而Comparator接口不强制进行自然排序，可以指定排序顺序</p>
</li>
</ul>
<h2 id="6、无序性和不可重复性的含义是什么"><a href="#6、无序性和不可重复性的含义是什么" class="headerlink" title="6、无序性和不可重复性的含义是什么"></a>6、无序性和不可重复性的含义是什么</h2><ul>
<li>无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据<strong>数据的哈希值</strong>决定的。</li>
<li>不可重复性是指添加的元素按照 <strong>equals()</strong> 判断时 ，返回 false，需要同时重写 <strong>equals()</strong> 方法和 <strong>hashCode()</strong> 方法</li>
</ul>
<h2 id="7、比较HashSet、LinkedHashSet和TreeSet三者的异同"><a href="#7、比较HashSet、LinkedHashSet和TreeSet三者的异同" class="headerlink" title="7、比较HashSet、LinkedHashSet和TreeSet三者的异同"></a>7、比较HashSet、LinkedHashSet和TreeSet三者的异同</h2><p>HashSet、LinkedHashSet 和 TreeSet 都是 Set 接口的实现类，都能保证元素唯一，并且都<strong>不是线程安全</strong>的。</p>
<p>HashSet、LinkedHashSet 和 TreeSet 的主要区别在于<strong>底层数据结构</strong>不同。HashSet 的底层数据结构是哈希表（基于 HashMap 实现）。LinkedHashSet 的底层数据结构是<strong>链表和哈希表</strong>，元素的插入和取出顺序满足 FIFO。TreeSet 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</p>
<p>底层数据结构不同又导致这三者的<strong>应用场景</strong>不同。<strong>HashSet 用于不需要保证元素插入和取出顺序的场景，LinkedHashSet 用于保证元素的插入和取出顺序满足 FIFO 的场景，TreeSet 用于支持对元素自定义排序规则的场景。</strong></p>
<p>HahSet集合的底层是哈希表，哈希表在JDK1.8之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。<br>JDK1.8引入红黑树大程度优化了HashMap的性能，那么对于我们来讲保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须重写hashCode和equals方法建立属于当前对象的比较方式。</p>
<h2 id="8、Queue-与-Deque-的区别"><a href="#8、Queue-与-Deque-的区别" class="headerlink" title="8、Queue 与 Deque 的区别"></a>8、Queue 与 Deque 的区别</h2><p>Queue 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 先进先出（FIFO） 规则。</p>
<p>Deque 是双端队列，在队列的两端均可以插入或删除元素。Deque <strong>扩展</strong>了 Queue 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</p>
<table>
<thead>
<tr>
<th align="center">Queue 接口</th>
<th align="center">抛出异常</th>
<th align="center">返回特殊值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">插入队尾</td>
<td align="center">add(E e)</td>
<td align="center">offer(E e)</td>
</tr>
<tr>
<td align="center">删除队首</td>
<td align="center">remove()</td>
<td align="center">poll()</td>
</tr>
<tr>
<td align="center">查询队首元素</td>
<td align="center">element()</td>
<td align="center">peek()</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center"><code>Deque</code> <strong>接口</strong></th>
<th align="center">抛出异常</th>
<th align="center">返回特殊值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">插入队首</td>
<td align="center">addFirst(E e)</td>
<td align="center">offerFirst(E e)</td>
</tr>
<tr>
<td align="center">插入队尾</td>
<td align="center">addLast(E e)</td>
<td align="center">offerLast(E e)</td>
</tr>
<tr>
<td align="center">删除队首</td>
<td align="center">removeFirst()</td>
<td align="center">pollFirst()</td>
</tr>
<tr>
<td align="center">删除队尾</td>
<td align="center">removeLast()</td>
<td align="center">pollLast()</td>
</tr>
<tr>
<td align="center">查询队首元素</td>
<td align="center">getFirst()</td>
<td align="center">peekFist()</td>
</tr>
<tr>
<td align="center">查询队尾元素</td>
<td align="center">getLast()</td>
<td align="center">peekLast()</td>
</tr>
</tbody></table>
<h2 id="9、ArrayDeque-与-LinkedList-模拟栈、队列-的区别"><a href="#9、ArrayDeque-与-LinkedList-模拟栈、队列-的区别" class="headerlink" title="9、ArrayDeque 与 LinkedList(模拟栈、队列) 的区别"></a>9、<font color=red>ArrayDeque 与 LinkedList(模拟栈、队列) 的区别</font></h2><ul>
<li><p>ArrayDeque 是基于<strong>可变长的数组和双指针</strong>来实现，而 LinkedList 则通过链表来实现。</p>
</li>
<li><p>ArrayDeque 不支持存储<strong>NULL 数据</strong>，但 LinkedList 支持。</p>
</li>
</ul>
<p>ArrayDeque 是在 JDK1.6 才被引入的，而LinkedList 早在 JDK1.2 时就已经存在。</p>
<ul>
<li>ArrayDeque 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 LinkedList 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li>
</ul>
<p>从性能的角度上，选用 ArrayDeque 来实现队列要比 LinkedList 更好。此外，ArrayDeque 也可以用于实现栈。</p>
<p>##10、PriorityQueue（初始容量（11））</p>
<ul>
<li>PriorityQueue 利用了二叉堆的数据结构来实现的，底层使用<strong>可变长的数组</strong>来存储数据</li>
<li>PriorityQueue 通过堆元素的上浮和下沉，实现了在**O(logn)**的时间复杂度内插入元素和删除堆顶元素。</li>
<li>PriorityQueue 是<strong>非线程安全</strong>的，且不支持存储 NULL 和 non-comparable 的对象。</li>
<li>PriorityQueue 默认是<strong>小顶堆</strong>，但可以接收一个 Comparator 作为构造参数，从而来自定义元素优先级的先后。</li>
</ul>
<p>PriorityQueue 在面试中可能更多的会出现在手撕算法的时候，典型例题包括<strong>堆排序、求第 K 大的数、带权图的遍历</strong>等，所以需要会熟练使用才行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//大顶堆</span></span><br><span class="line">Queue&lt;Integer&gt;A=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;()</span><br><span class="line">A=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">				<span class="comment">// TODO 自动生成的方法存根</span></span><br><span class="line">				<span class="keyword">return</span> o2-o1;</span><br><span class="line">			&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//jdk8新特性：lambda表达式</span></span><br><span class="line">B=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((x,y) -&gt; (y-x));</span><br></pre></td></tr></table></figure>

<h2 id="11、阻塞队列（BlockingQueue-阻塞队列-是一个接口，继承自-Queue）"><a href="#11、阻塞队列（BlockingQueue-阻塞队列-是一个接口，继承自-Queue）" class="headerlink" title="11、阻塞队列（BlockingQueue (阻塞队列)是一个接口，继承自 Queue）"></a>11、阻塞队列（BlockingQueue (阻塞队列)是一个接口，继承自 Queue）</h2><p>BlockingQueue阻塞的原因是其支持<strong>当队列没有元素时一直阻塞，直到有元素</strong>；还支持<strong>如果队列已满，一直等到队列可以放入新元素时再放入</strong>。</p>
<p>BlockingQueue 常用于<strong>生产者-消费者模型</strong>中，生产者线程会向队列中添加数据，而消费者线程会从队列中取出数据进行处理。</p>
<p>阻塞队列实现类：ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue、SynchronousQueue、DelayQueue….</p>
<ul>
<li><strong>ArrayBlockingQueue</strong> 和 <strong>LinkedBlockingQueue</strong> 是 Java 并发包中常用的两种阻塞队列实现，它们都是<strong>线程安全</strong>的。区别：<ul>
<li>底层实现：ArrayBlockingQueue 基于数组实现，而 LinkedBlockingQueue 基于链表实现。</li>
<li>是否有界：ArrayBlockingQueue 是有界队列，必须在创建时指定容量大小。LinkedBlockingQueue 创建时可以不指定容量大小，默认是Integer.MAX_VALUE，也就是无界的。但也可以指定队列大小，从而成为有界的。</li>
<li>锁是否分离： ArrayBlockingQueue中的锁是没有分离的，即生产和消费用的是同一个锁；LinkedBlockingQueue中的锁是分离的，即生产用的是putLock，消费是takeLock，这样可以防止生产者和消费者线程之间的锁争夺</li>
<li>内存占用：ArrayBlockingQueue 需要提前分配数组内存，而 LinkedBlockingQueue 则是动态分配链表节点内存。这意味着，ArrayBlockingQueue 在创建时就会占用一定的内存空间，且往往申请的内存比实际所用的内存更大，而LinkedBlockingQueue 则是根据元素的增加而逐渐占用内存空间。</li>
</ul>
</li>
</ul>
<h2 id="12、原生的线程安全的集合类"><a href="#12、原生的线程安全的集合类" class="headerlink" title="12、原生的线程安全的集合类"></a>12、原生的线程安全的集合类</h2><p>Vector，Stack，<strong>HashTable</strong>，<strong>Enumeration</strong>		——喂! SHE!</p>
<p>Concurrent为前缀的所有集合类：ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet、ConcurrentLinkedQueue、ConcurrentLinkedDeque……</p>
<h2 id="13、HashMap-和-Hashtable-的区别"><a href="#13、HashMap-和-Hashtable-的区别" class="headerlink" title="13、HashMap 和 Hashtable 的区别"></a>13、<font color=red>HashMap</font> 和 Hashtable 的区别</h2><ul>
<li><p><strong>线程是否安全</strong>：</p>
</li>
<li><p><strong>效率</strong>：</p>
</li>
<li><p><strong>对 Null key 和 Null value 的支持：</strong><code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；</p>
</li>
<li><p><strong>初始容量大小和每次扩充容量大小的不同</strong>： ① 创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 <strong>2n+1</strong>。<code>HashMap</code> 默认的初始化大小为 <strong>16</strong>。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 <code>Hashtable</code> <strong>会直接使用你给定的大小</strong>，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证）。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小。</p>
</li>
<li><p>负载因子 &#x3D; (哈希表中的元素数量) &#x2F; (哈希表的大小)，HashMap负载因子是0.75（泊松分布）—-&gt;扩容</p>
</li>
<li><p><strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 <strong>8</strong>）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间（后文中我会结合源码对这一过程进行分析）。<code>Hashtable</code> 没有这样的机制。</p>
<p>HashMap的put方法。</p>
</li>
<li><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240521083111049-1737881543400168.png" alt="image-20240521083111049"></p>
</li>
</ul>
<h2 id="14、HashMap和HashSet区别"><a href="#14、HashMap和HashSet区别" class="headerlink" title="14、HashMap和HashSet区别"></a>14、HashMap和HashSet区别</h2><ul>
<li><p><strong>实现接口</strong></p>
</li>
<li><p><strong>存储值</strong></p>
</li>
<li><p><strong>根据（key&#x2F;对象）计算哈希值</strong></p>
</li>
<li><p><strong>put&#x2F;add</strong></p>
</li>
</ul>
<h2 id="15、HashMap和TreeMap区别"><a href="#15、HashMap和TreeMap区别" class="headerlink" title="15、HashMap和TreeMap区别"></a>15、HashMap和TreeMap区别</h2><p><strong>综上，相比于<code>HashMap</code>来说 <code>TreeMap</code> 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力</strong></p>
<p>##16、HashMap 的底层实现</p>
<p>JDK1.8之前，<strong>数组和链表</strong></p>
<p>JDK1.8之后，数组和链表&#x2F;红黑树，链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p>
<h2 id="17、HashMap多线程操作导致死循环问题"><a href="#17、HashMap多线程操作导致死循环问题" class="headerlink" title="17、HashMap多线程操作导致死循环问题"></a>17、HashMap多线程操作导致死循环问题</h2><p>JDK1.7 头插法会导致环形链表</p>
<p>JDK1.8 尾插解决</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240521084214901-1737881543400169.png" alt="image-20240521084214901"></p>
<h2 id="18、HashMap-的长度为什么是-2-的幂次方"><a href="#18、HashMap-的长度为什么是-2-的幂次方" class="headerlink" title="18、HashMap 的长度为什么是 2 的幂次方"></a>18、HashMap 的长度为什么是 2 的幂次方</h2><ul>
<li>为了<strong>加快哈希计算</strong>以及<strong>减少哈希冲突</strong></li>
</ul>
<p>解释：（n-1）&amp;hash&#x3D;&#x3D;hash%n；hash值就是要用低位的信息，那么结合&amp;操作，&amp;的另一个数最好低位全是1，这样&amp;才有意义，否则结果就肯定是0那么&amp;就没有意义，所以需要2^n</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240521083455565-1737881543400170.png" alt="image-20240521083455565"></p>
<h2 id="19、HashMap为什么线程不安全？"><a href="#19、HashMap为什么线程不安全？" class="headerlink" title="19、HashMap为什么线程不安全？"></a>19、HashMap为什么线程不安全？</h2><p>JDK1.7 及之前版本，在多线程环境下，**<code>HashMap</code> 扩容时会造成死循环和数据丢失**的问题。</p>
<p>数据丢失这个在 JDK1.7 和 JDK 1.8 中都存在，这里以 JDK 1.8 为例进行介绍。</p>
<p>JDK 1.8 后，在 <code>HashMap</code> 中，多个键值对可能会被分配到同一个桶（bucket），并以链表或红黑树的形式存储。多个线程对 <code>HashMap</code> 的 <code>put</code> 操作会导致线程不安全，具体来说会有<strong>数据覆盖</strong>的风险</p>
<p>![image-20240521083406922](Redis.assets&#x2F;image-20240521083406922.png</p>
<h2 id="20、HashMap-常见的遍历方式"><a href="#20、HashMap-常见的遍历方式" class="headerlink" title="20、HashMap 常见的遍历方式?"></a>20、HashMap 常见的遍历方式?</h2><p><strong>存在阻塞时 parallelStream 性能最高, 非阻塞时 parallelStream 性能最低</strong> 。</p>
<h2 id="21、ConcurrentHashMap为什么key和value不能为null？"><a href="#21、ConcurrentHashMap为什么key和value不能为null？" class="headerlink" title="21、ConcurrentHashMap为什么key和value不能为null？"></a>21、ConcurrentHashMap为什么key和value不能为null？</h2><p><code>ConcurrentHashMap</code> 的 key 和 value 不能为 null 主要是<strong>为了避免二义性</strong>。null 是一个特殊的值，表示没有对象或没有引用。如果你用 null 作为键，那么你就无法区分这个键是否存在于 <code>ConcurrentHashMap</code> 中，还是根本没有这个键。同样，如果你用 null 作为值，那么你就无法区分这个值是否是真正存储在 <code>ConcurrentHashMap</code> 中的，还是因为找不到对应的键而返回的。</p>
<p>拿 get 方法取值来说，返回的结果为 null 存在两种情况：</p>
<ul>
<li>值没有在集合中 ；</li>
<li>值本身就是 null。</li>
</ul>
<p>这也就是二义性的由来。</p>
<p>多线程环境下，存在一个线程操作该 <code>ConcurrentHashMap</code> 时，其他的线程将该 <code>ConcurrentHashMap</code> 修改的情况，所以无法通过 <code>containsKey(key)</code> 来判断否存在这个键值对，也就没办法解决二义性问题了。</p>
<p>与此形成对比的是，<code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个。如果<strong>传入 null 作为参数，就会返回 hash 值为 0 的位置</strong>的值。单线程环境下，不存在一个线程操作该 HashMap 时，其他的线程将该 <code>HashMap</code> 修改的情况，所以可以通过 <code>contains(key)</code>来做判断是否存在这个键值对，从而做相应的处理，也就不存在二义性问题。</p>
<p>也就是说，<strong>多线程下无法正确判定键值对是否存在（存在其他线程修改的情况）</strong>，单线程是可以的（不存在其他线程修改的情况）。</p>
<p>如果你确实需要在 ConcurrentHashMap 中使用 null 的话，可以使用一个<strong>特殊的静态空对象来</strong>代替 null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">NULL</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>

<h2 id="22、ConcurrentHashMap能保证复合操作的原子性吗？"><a href="#22、ConcurrentHashMap能保证复合操作的原子性吗？" class="headerlink" title="22、ConcurrentHashMap能保证复合操作的原子性吗？"></a>22、ConcurrentHashMap能保证复合操作的原子性吗？</h2><p><strong><code>ConcurrentHashMap</code> 是线程安全的，意味着它可以保证多个线程同时对它进行读写操作时，不会出现数据不一致的情况</strong>，也不会导致 JDK1.7 及之前版本的 <code>HashMap</code> 多线程操作导致死循环问题。<strong>但是，这并不意味着它可以保证所有的复合操作都是原子性的，一定不要搞混了！</strong></p>
<p>复合操作是指由多个基本操作(如<code>put</code>、<code>get</code>、<code>remove</code>、<code>containsKey</code>等)组成的操作，例如先判断某个键是否存在<code>containsKey(key)</code>，然后根据结果进行插入或更新<code>put(key, value)</code>。这种操作在执行过程中可能会被其他线程打断，导致结果不符合预期。</p>
<p><code>ConcurrentHashMap</code> 提供了一些原子性的复合操作，如 <code>putIfAbsent</code>、<code>compute</code>、<code>computeIfAbsent</code> 、<code>computeIfPresent</code>、<code>merge</code>等。这些方法都可以接受一个函数作为参数，根据给定的 key 和 value 来计算一个新的 value，并且将其更新到 map 中。</p>
<h2 id="23、拓展"><a href="#23、拓展" class="headerlink" title="23、拓展"></a>23、拓展</h2><h3 id="1）Collection工具类"><a href="#1）Collection工具类" class="headerlink" title="1）Collection工具类"></a>1）Collection工具类</h3><p><strong><code>Collections</code> 工具类常用方法</strong>:</p>
<ul>
<li>排序</li>
<li>查找,替换操作</li>
<li>同步控制(不推荐，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合)****</li>
</ul>
<h4 id="排序操作"><a href="#排序操作" class="headerlink" title="排序操作"></a>排序操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(List list)</span><span class="comment">//反转</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(List list)</span><span class="comment">//随机排序</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List list)</span><span class="comment">//按自然排序的升序排序</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List list, Comparator c)</span><span class="comment">//定制排序，由Comparator控制排序逻辑</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(List list, <span class="type">int</span> i , <span class="type">int</span> j)</span><span class="comment">//交换两个索引位置的元素</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(List list, <span class="type">int</span> distance)</span><span class="comment">//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="查找，替换操作"><a href="#查找，替换操作" class="headerlink" title="查找，替换操作"></a>查找，替换操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(List list, Object key)</span><span class="comment">//对List进行二分查找，返回索引，注意List必须是有序的</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(Collection coll)</span><span class="comment">//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(Collection coll, Comparator c)</span><span class="comment">//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">fill</span><span class="params">(List list, Object obj)</span><span class="comment">//用指定的元素代替指定list中的所有元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">frequency</span><span class="params">(Collection c, Object o)</span><span class="comment">//统计元素出现次数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOfSubList</span><span class="params">(List list, List target)</span><span class="comment">//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target)</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">replaceAll</span><span class="params">(List list, Object oldVal, Object newVal)</span><span class="comment">//用新元素替换旧元素</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="同步控制（不重要）"><a href="#同步控制（不重要）" class="headerlink" title="同步控制（不重要）"></a>同步控制（不重要）</h4><p><code>Collections</code> 提供了多个<code>synchronizedXxx()</code>方法·，该方法可以将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。</p>
<p>我们知道 <code>HashSet</code>，<code>TreeSet</code>，<code>ArrayList</code>,<code>LinkedList</code>,<code>HashMap</code>,<code>TreeMap</code> 都是线程不安全的。<code>Collections</code> 提供了多个静态方法可以把他们包装成线程同步的集合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">synchronizedCollection(Collection&lt;T&gt;  c) <span class="comment">//返回指定 collection 支持的同步（线程安全的）collection。</span></span><br><span class="line">synchronizedList(List&lt;T&gt; list)<span class="comment">//返回指定列表支持的同步（线程安全的）List。</span></span><br><span class="line">synchronizedMap(Map&lt;K,V&gt; m) <span class="comment">//返回由指定映射支持的同步（线程安全的）Map。</span></span><br><span class="line">synchronizedSet(Set&lt;T&gt; s) <span class="comment">//返回指定 set 支持的同步（线程安全的）set。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>###2）<strong>选择排序</strong>，<strong>插入排序</strong>，<strong>快速排序</strong>，<strong>归并排序</strong>，<strong>冒泡排序</strong>，<strong>希尔排序</strong>，以及<strong>堆排序</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选择排序--o(n^2)--找到最小的数的索引放到第一个---比较次数为n (n - 1)/2</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] selectionSort(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; nums[minIndex]) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line">            swap(nums, i, minIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入排序--o(n^2)--从未排序的数组中选择元素插入到合适位置--n (n - 1)/2</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] insertionSort(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; current &lt; nums[j]) &#123;</span><br><span class="line">            nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j + <span class="number">1</span>] = current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快速排序---O(nlogn)---先找基准再排序不断二分</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QuickSort</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 找到基准值的位置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">pivotIndex</span> <span class="operator">=</span> partition(arr, left, right);</span><br><span class="line">            <span class="comment">// 对基准值左侧的数组进行快速排序</span></span><br><span class="line">            quickSort(arr, left, pivotIndex - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 对基准值右侧的数组进行快速排序</span></span><br><span class="line">            quickSort(arr, pivotIndex + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">// 选择最后一个元素作为基准值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[right];</span><br><span class="line">        <span class="comment">// i是小于基准值的元素的最后一个位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> left; j &lt; right; j++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前元素小于或等于基准值，就交换到前面去</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt;= pivot) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                swap(arr, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将基准值交换到正确的位置</span></span><br><span class="line">        swap(arr, i + <span class="number">1</span>, right);</span><br><span class="line">        <span class="comment">// 返回基准值的位置</span></span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//归并排序--O(nlogn)--先二分再排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] mergeSort(<span class="type">int</span>[] array) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array == <span class="literal">null</span> || array.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>[] helper = <span class="keyword">new</span> <span class="title class_">int</span>[array.length];</span><br><span class="line">    mergeSort(array, helper, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span>[] helper, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    mergeSort(array, helper, left, mid);</span><br><span class="line">    mergeSort(array, helper, mid + <span class="number">1</span>, right);</span><br><span class="line">    merge(array, helper, left, mid, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span>[] helper, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt;= right; i++) &#123;</span><br><span class="line">        helper[i] = array[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> mid + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> left;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">       <span class="keyword">if</span> (helper[i] &lt;= helper[j]) &#123;</span><br><span class="line">           array[index] = helper[i];</span><br><span class="line">           i++;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           array[index] = helper[j];</span><br><span class="line">           j++;</span><br><span class="line">       &#125;</span><br><span class="line">       index++;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">       array[index] = helper[i];</span><br><span class="line">       i++;</span><br><span class="line">       index++;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">       array[index] = helper[j];</span><br><span class="line">       j++;</span><br><span class="line">       index++;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] shellSort(<span class="type">int</span>[] array) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array == <span class="literal">null</span> || array.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> array.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> n / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[i];</span><br><span class="line">            <span class="keyword">while</span> (j - gap &gt;= <span class="number">0</span> &amp;&amp; array[j - gap] &gt; temp)&#123;</span><br><span class="line">                array[j] = array[j - gap];</span><br><span class="line">                j -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            array[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//堆排序---O(nlogn)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] heapSort(<span class="type">int</span>[] array) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array == <span class="literal">null</span> || array.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> array.length;</span><br><span class="line">    <span class="comment">// 建一个大顶堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        heapify(array, i, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将未排序部分的最大数交换至已排序部分，再进行一次堆化以保持堆的结构</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        swap(array, <span class="number">0</span>, n - <span class="number">1</span> - i);</span><br><span class="line">        heapify(array, <span class="number">0</span>, n - <span class="number">1</span> - i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> i, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> i;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; length &amp;&amp; array[left] &gt; array[largest]) &#123;</span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; length &amp;&amp; array[right] &gt; array[largest]) &#123;</span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        swap(array, i, largest);</span><br><span class="line">        heapify(array, largest, length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//桶排序-----&gt;&gt;&gt;&gt;&gt;应用：基数排序，计数排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BucketSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bucketSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 找到最大值和最小值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt; max) &#123;</span><br><span class="line">                max = num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num &lt; min) &#123;</span><br><span class="line">                min = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 确定桶的数量，这里假设桶的数量为10</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">bucketCount</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; buckets = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bucketCount; i++) &#123;</span><br><span class="line">            buckets.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 将每个元素分配到桶中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (num - min) / (max - min + <span class="number">1</span>) * (bucketCount - <span class="number">1</span>);</span><br><span class="line">            buckets.get(index).add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4. 对每个桶进行排序</span></span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; bucket : buckets) &#123;</span><br><span class="line">            Collections.sort(bucket);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5. 合并桶中的数据</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; bucket : buckets) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> num : bucket) &#123;</span><br><span class="line">                arr[index++] = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基数排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RadixSort</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 找到最大值，确定最大位数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt; max) &#123;</span><br><span class="line">                max = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxDigits</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (max != <span class="number">0</span>) &#123;</span><br><span class="line">            max /= <span class="number">10</span>;</span><br><span class="line">            maxDigits++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 初始化10个桶</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; buckets = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            buckets.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 根据每个位上的数字进行排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> <span class="number">0</span>; digit &lt; maxDigits; digit++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">                <span class="comment">// 计算当前位的数字</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">currentDigit</span> <span class="operator">=</span> (num / (<span class="type">int</span>) Math.pow(<span class="number">10</span>, digit)) % <span class="number">10</span>;</span><br><span class="line">                buckets.get(currentDigit).add(num);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将桶中的数据重新收集到原数组中</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (List&lt;Integer&gt; bucket : buckets) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> num : bucket) &#123;</span><br><span class="line">                    arr[index++] = num;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 清空桶，为下一次排序做准备</span></span><br><span class="line">                bucket.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>###arrayS.sort的底层</p>
<h3 id="1-对于基本数据类型数组"><a href="#1-对于基本数据类型数组" class="headerlink" title="1. 对于基本数据类型数组"></a>1. <strong>对于基本数据类型数组</strong></h3><p>对于<code>int</code>、<code>long</code>、<code>double</code>等基本数据类型的数组，<code>Arrays.sort()</code>在Java 7及之后的版本中使用了一种称为 <strong>Dual-Pivot Quicksort</strong> 的算法。</p>
<ul>
<li><strong>Dual-Pivot Quicksort</strong>：双轴快速排序是一种快速排序的改进版本，它通过选择两个基准元素（pivot）将数组分成三个部分（小于第一个基准、大于第一个基准且小于第二个基准、大于第二个基准），然后对每个部分递归排序。</li>
<li><strong>时间复杂度</strong>：在大多数情况下，时间复杂度为 O(nlog⁡n)O(n \log n)O(nlogn)。但在最坏情况下，它的时间复杂度可能达到 O(n2)O(n^2)O(n2)，不过由于选择了两个基准点，发生最坏情况的概率较小。</li>
<li><strong>空间复杂度</strong>：Dual-Pivot Quicksort是一种原地排序算法，空间复杂度为 O(log⁡n)O(\log n)O(logn)，因为它的递归调用栈较小。</li>
</ul>
<p>这种算法在实际性能中优于单轴快速排序，因此Java在7及以后的版本采用了这种排序方法。</p>
<h3 id="2-对于对象类型数组"><a href="#2-对于对象类型数组" class="headerlink" title="2. 对于对象类型数组"></a>2. <strong>对于对象类型数组</strong></h3><p>对于<code>String</code>、<code>Integer</code>等对象类型的数组，<code>Arrays.sort()</code>在Java 7及之后的版本中采用了 <strong>Timsort</strong> 算法。</p>
<ul>
<li><strong>Timsort</strong>：Timsort是一种混合排序算法，结合了 <strong>归并排序</strong> 和 <strong>插入排序</strong> 的思想。Timsort首先对数组进行分块，将数组划分为多个已排序的“run”（一个有序的子数组），然后对这些子数组进行归并。</li>
<li><strong>稳定性</strong>：Timsort是稳定的排序算法，保证了相等元素的相对顺序不变。</li>
<li><strong>时间复杂度</strong>：Timsort在最优和平均情况下的时间复杂度是 O(nlog⁡n)O(n \log n)O(nlogn)，在接近排序的数组上表现得更好，接近 O(n)O(n)O(n)。</li>
<li><strong>适应性</strong>：Timsort适用于部分有序的数组，在这种情况下性能非常优越。</li>
</ul>
<p>Timsort被选用是因为它在实际应用中表现非常高效，尤其是对于大型对象数组。Timsort在Python中也被广泛使用。</p>
<h3 id="3-小规模数组的优化"><a href="#3-小规模数组的优化" class="headerlink" title="3. 小规模数组的优化"></a>3. <strong>小规模数组的优化</strong></h3><p>无论是基本数据类型还是对象数组，<code>Arrays.sort()</code>在处理小规模数组时可能会直接采用 <strong>插入排序</strong>。对于小数组（一般是10-20个元素以下），插入排序比快速排序、归并排序等更有效，因为它的简单性和较低的常数时间开销。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>基本数据类型数组</strong>：采用 <strong>Dual-Pivot Quicksort</strong>，时间复杂度为 O(nlog⁡n)O(n \log n)O(nlogn)。</li>
<li><strong>对象类型数组</strong>：采用 <strong>Timsort</strong>，结合了归并和插入排序，时间复杂度为 O(nlog⁡n)O(n \log n)O(nlogn)，在部分有序数组上性能接近 O(n)O(n)O(n)。</li>
<li><strong>小规模数组</strong>：一般采用 <strong>插入排序</strong> 进行优化。</li>
</ul>
<p><code>Arrays.sort()</code> 的底层实现充分考虑了更优的性能表现。</p>
<p>考察基础会问：<strong>不稳定：选择、快速、希尔、堆</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20241029102236611-1737881543400172.png" alt="image-20241029102236611"></p>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="1、什么是数据库事务？讲⼀下事务的-ACID-特性？"><a href="#1、什么是数据库事务？讲⼀下事务的-ACID-特性？" class="headerlink" title="1、什么是数据库事务？讲⼀下事务的 ACID 特性？"></a>1、什么是数据库事务？讲⼀下事务的 ACID 特性？</h2><p><strong>数据库事务是指数据库管理系统（DBMS）中的⼀个操作序列，这些操作必须作为⼀个不可分割的单元执⾏，即要么全部执行成功，要么全部失败回滚。</strong></p>
<p>事务的 ACID 特性指四个关键特征：原⼦性（Atomicity）、⼀致性（Consistency）、隔离性（Isolation）和持久性（Durability）。 </p>
<pre><code>1. 原⼦性（Atomicity）：**事务是⼀个原⼦操作，要么全部提交，要么全部回滚。**当⼀个事务执⾏期间发⽣故障，操作系统会⾃动将其回滚到事务执⾏之前的状态，保证数据的⼀致性。
2. ⼀致性（Consistency）：**在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。**在事务执⾏期间，数据库中的数据可以处于中间状态，但在事务完成时必须保证数据的⼀致性。 
3. 隔离性（Isolation）：**多个事务并发访问时，事务之间是隔离的，⼀个事务不应该影响其它事务运⾏效果。** **在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。**由并发事务所做的修改 必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另⼀事务修改它之前的状态，要么是另⼀事务修改它之后的状态，**事务不会查看到中间状态的数据。** 事务最复杂问题都是由事务隔离性引起的。完全的隔离性是不现实的，完全的隔离性要求数据库同⼀时间只执⾏⼀ 条事务，这样会严重影响性能。
4. 持久性（Durability）：**⼀旦事务提交，其所做的修改必须永久保存到数据库中。**即使系统发⽣故障或宕机， 数据也能够保持不变。
</code></pre>
<p>有四种隔离级别： </p>
<p>第⼀种隔离级别：**Read uncommitted(读未提交) **解决了更新丢失，但还是可能会出现脏读 </p>
<p>第⼆种隔离级别：<strong>Read committed(读提交)</strong> 解决了更新丢失和脏读问题 </p>
<p>第三种隔离级别：**Repeatable read(可重复读取) **解决了更新丢失、脏读、不可重复读、但是还会出现幻读 </p>
<p>第四种隔离级别：**Serializable(可序化)**解决了更新丢失、脏读、不可重复读、幻读(虚读)</p>
<hr>
<p>转[7](##7、MySQL ⽇志有了解过吗？binlog、redolog、undolog 分别有什么作 ⽤、有什么区别？)和[8](##8、MVCC 是什么？InnoDB 是如何实现 MVCC 机制的？)</p>
<p><strong>在MySQL  InnoDB存储引擎下，RC、RR基于MVCC（多版本并发控制）进行并发事务控制，MVCC是基于数据版本对并发事务进行访问。</strong></p>
<p>ReadView是什么?</p>
<p><strong>ReadView是“快照读”sql执行时MVCC提取数据的依据，快照读就是最普通的Select查询SQl语句，当前读指代执行下列语句时数据读取的方式：Insert、Update、Delete、Select…for update、Select…lock in share mode。需要注意的是，连续两个快照读中出现当前读不一定会出现幻读，得看当前读有没有覆盖到其他事务新增的数据，如果没的话，则不会出现幻读。</strong></p>
<p>Undolog版本链不是被立即删除，MySQL确保版本链数据不再被“引用”后再进行删除。</p>
<h2 id="2、数据库索引是什么，有什么作⽤，什么场景适合使⽤索引？"><a href="#2、数据库索引是什么，有什么作⽤，什么场景适合使⽤索引？" class="headerlink" title="2、数据库索引是什么，有什么作⽤，什么场景适合使⽤索引？"></a>2、数据库索引是什么，有什么作⽤，什么场景适合使⽤索引？</h2><p><strong>数据库索引是⼀种数据结构，⽤于提高数据库表的查询效率。</strong> 索引可以帮助数据库快速定位和检索存储在表中的数据，从⽽加快数据查询的速度。在数据量⽐较⼤时，使⽤索引可以极⼤地提⾼数据检索的效率。</p>
<p><strong>索引的作用是通过构建⼀个额外的数据结构（B-tree、哈希表等）来加速数据的检索。</strong>索引可以包含⼀个或多个列，可以使⽤单列索引、组合索引、全⽂索引等多种⽅式来创建。</p>
<p>适合使⽤索引的场景包括： </p>
<ul>
<li><p>频繁查询的列，如主键、外键等。</p>
</li>
<li><p>经常作为查询条件的列，如 **WHERE、ORDER BY、GROUP BY **等语句中的列。 </p>
</li>
<li><p>经常需要连接的列，如**多表联合查询时的列。 **</p>
</li>
<li><p>数据量较⼤的表，通过索引可以加快数据检索速度。</p>
</li>
</ul>
<p>但是索引也有⼀些缺点，包括： </p>
<ul>
<li><p>占⽤额外的存储空间，增加了存储成本。</p>
</li>
<li><p>建⽴索引需要时间，增加了系统的开销。 </p>
</li>
<li><p>数据库的更新操作（增删改）会导致索引的重建，影响系统的性能。</p>
</li>
</ul>
<p><strong>字段上有主键和unique的会自动添加索引对象</strong>，在mysql当中，索引是一个单独的对象，不同的存储引擎以不同的形式存在，在MyISAM存储引擎中，索引存储在一个.myi文件中.在InnoDB存储引擎中索引存储在一个逻辑名称叫做表空间的当中。在内存(Memory)存储引擎当中索引被存储在内存当中。不管索引存储在哪里，索引在mysql当中都是一个树的形式存在。(自平衡二叉树:B-Tree)</p>
<h2 id="3、MySQL-中的索引是怎么实现的？B-树是什么，B-树和-B-树的区别，-为什么-MySQL-要⽤-B-树？"><a href="#3、MySQL-中的索引是怎么实现的？B-树是什么，B-树和-B-树的区别，-为什么-MySQL-要⽤-B-树？" class="headerlink" title="3、MySQL 中的索引是怎么实现的？B+ 树是什么，B 树和 B+ 树的区别， 为什么 MySQL 要⽤ B+ 树？"></a>3、MySQL 中的索引是怎么实现的？B+ 树是什么，B 树和 B+ 树的区别， 为什么 MySQL 要⽤ B+ 树？</h2><p>MySQL 中的索引<strong>是通过 B+ 树</strong>实现的。B+ 树是⼀种<strong>多叉树</strong>，它可以将数据按照⼀定的顺序组织起来，从⽽提⾼查询效率。 </p>
<p><strong>B+ 树与 B 树的区别在于</strong>，</p>
<p>B+树 </p>
<ul>
<li>叶⼦节点存数据</li>
</ul>
<p>B树 </p>
<ul>
<li>所有节点都存数据</li>
</ul>
<p>B+ 树的所有数据都存储在叶⼦节点上，⽽⾮叶⼦节点只存储索引，这样可以提⾼数据查询效率。</p>
<p>why choose B+ </p>
<ul>
<li>INSERT &#x2F; DELETE</li>
</ul>
<p>B树由于所有节点都保存所有数据，每当插⼊⼀条数据，哪怕是⾃增的，都可能造成整个树的<strong>⾃旋重构</strong>，当数据量很⼤的时候，这个时间成本和⻛险是巨⼤的 </p>
<p>B+树使⽤叶⼦节点保存数据，插⼊⼀条数据只会在叶⼦节点上插⼊，⼀般不会影响树的结构 </p>
<ul>
<li>SELECT</li>
</ul>
<p>B+树⽀持<strong>范围查找，同时查询更高效</strong> </p>
<p>why ？因为叶⼦节点中，⻚与⻚之间是双向链表，⽽簇于簇之间有单向指针连接。</p>
<p>在 MySQL 中，B+ 树的实现主要是通过 InnoDB 存储引擎来实现的。InnoDB 存储引擎中的索引主要有<strong>聚簇索引和 辅助索引</strong>两种类型，聚簇索引是根据主键创建的索引，⽽辅助索引是根据⾮主键列创建的索引。</p>
<p>##索引失效</p>
<ol>
<li><strong>模糊查询</strong>索引会失效</li>
<li>使用<strong>or</strong>（or两边都有索引才会走索引，减少使用or）</li>
<li><strong>复合索引</strong>（不使用左边的列，不走索引）</li>
<li>索引列参加<strong>数学运算</strong>&#x2F;索引使用函数</li>
</ol>
<table>
<thead>
<tr>
<th>索引失效原因</th>
<th>说明</th>
<th>示例代码</th>
<th>解决办法</th>
</tr>
</thead>
<tbody><tr>
<td>查询条件中使用了函数或表达式</td>
<td>在查询条件中对列使用了函数、运算符或表达式，MySQL不会使用索引</td>
<td><code>SELECT * FROM users WHERE LEFT(name, 3) = &#39;Tom&#39;;</code></td>
<td>避免对索引列进行操作</td>
</tr>
<tr>
<td>使用 <code>!=</code>、<code>&lt;&gt;</code>、<code>NOT</code> 等不等于操作</td>
<td>索引主要用于范围查找，不等于操作会导致全表扫描</td>
<td><code>SELECT * FROM users WHERE age != 30;</code></td>
<td>尽量避免不等于操作</td>
</tr>
<tr>
<td><code>OR</code> 条件下的索引使用</td>
<td>使用 <code>OR</code> 条件时，除非所有字段都有索引，否则索引失效</td>
<td><code>SELECT * FROM users WHERE age = 25 OR name = &#39;Tom&#39;;</code></td>
<td>为所有字段建立索引，或使用 <code>UNION</code> 替代</td>
</tr>
<tr>
<td>隐式类型转换</td>
<td>字段类型和查询条件类型不一致会导致类型转换，索引失效</td>
<td><code>SELECT * FROM users WHERE phone = 1234567890;</code>  （phone 为字符串类型）</td>
<td>确保字段类型与查询条件类型一致</td>
</tr>
<tr>
<td>使用 <code>IS NULL</code> 或 <code>IS NOT NULL</code></td>
<td>某些情况下使用 <code>IS NULL</code> 或 <code>IS NOT NULL</code> 会导致索引失效</td>
<td><code>SELECT * FROM users WHERE age IS NULL;</code></td>
<td>检查索引适用性或避免使用空值查询</td>
</tr>
<tr>
<td><code>LIKE</code> 通配符在开头</td>
<td><code>LIKE</code> 操作中通配符在开头（如 <code>&#39;%keyword&#39;</code>），索引失效</td>
<td><code>SELECT * FROM users WHERE name LIKE &#39;%Tom&#39;;</code></td>
<td>避免前置通配符，或使用全文索引</td>
</tr>
<tr>
<td>复合索引的顺序不匹配</td>
<td>使用复合索引时必须按照字段创建的顺序，否则索引失效</td>
<td>创建索引 <code>(age, name)</code>，查询 <code>SELECT * FROM users WHERE name = &#39;Tom&#39;;</code></td>
<td>遵循复合索引的字段顺序</td>
</tr>
<tr>
<td>数据量过少</td>
<td>数据量过少时，MySQL可能会自动放弃索引</td>
<td>仅几行数据的表中查询时放弃索引</td>
<td>数据量少时通常不需要优化</td>
</tr>
<tr>
<td>更新频繁的字段</td>
<td>频繁更新的字段建立索引会增加开销，MySQL可能放弃使用索引</td>
<td>针对更新频繁的列使用索引时性能下降</td>
<td>避免对频繁更新的字段建立索引</td>
</tr>
<tr>
<td>范围查询后续字段索引失效</td>
<td>在复合索引中使用范围查询（如 <code>BETWEEN</code>、<code>&gt;</code>、<code>&lt;</code>），后续字段索引失效</td>
<td>创建索引 <code>(age, name)</code>，查询 <code>SELECT * FROM users WHERE age &gt; 20 AND name = &#39;Tom&#39;;</code></td>
<td>尽量将范围查询放到末尾或调整查询逻辑</td>
</tr>
</tbody></table>
<h2 id="4、MySQL-⽀持哪些存储引擎？默认使⽤哪个？MyISAM-和-InnoDB-引擎有什么区别，如何选择？"><a href="#4、MySQL-⽀持哪些存储引擎？默认使⽤哪个？MyISAM-和-InnoDB-引擎有什么区别，如何选择？" class="headerlink" title="4、MySQL ⽀持哪些存储引擎？默认使⽤哪个？MyISAM 和 InnoDB 引擎有什么区别，如何选择？"></a>4、MySQL ⽀持哪些存储引擎？默认使⽤哪个？MyISAM 和 InnoDB 引擎有什么区别，如何选择？</h2><p>MySQL ⽀持多种存储引擎，包括 InnoDB、MyISAM、MEMORY、CSV 等。默认情况下，MySQL 使⽤的存储引擎是 InnoDB。</p>
<p>其中最常⽤的是 <strong>InnoDB 和 MyISAM</strong>，他们有以下区别： </p>
<ul>
<li><p>InnoDB ⽀持<strong>事务操作</strong>，⽽ MyISAM 不⽀持事务 </p>
</li>
<li><p>InnoDB ⽀持<strong>外键</strong>，⽽ MyISAM 不⽀持外键 </p>
</li>
<li><p>InnoDB ⽀持<strong>行级锁，表级锁</strong>，⽽ MyISAM 只⽀持表级锁 </p>
</li>
<li><p>InnoDB ⽀持<strong>数据库异常崩溃后的安全恢复</strong>（redo log），⽽ MyISAM 不⽀持 </p>
</li>
<li><p>InnoDB 性能⽐MyISAM 更强，不管是在读写混合模式下还是只读模式下，随着 CPU 核数的增加，InnoDB 的<strong>读写能力呈线性增⻓</strong>。MyISAM 因为读写不能并发，它的处理能⼒跟核数没关系。</p>
</li>
<li><p>InnoDB 和 MyISAM 实现索引都是使⽤ B+ 树，但实现⽅式不同（需要深入了解，否则不要回答）</p>
</li>
</ul>
<p>如何选择？</p>
<ul>
<li>在读密集的情况下，如果你不需要事务，也不需要保证数据库的崩溃回复，可以选择 MyISAM 其他时候⼤可放心使⽤ InnoDB</li>
</ul>
<h2 id="5、意向锁是什么？有什么作⽤？它是表级锁还是⾏级锁？"><a href="#5、意向锁是什么？有什么作⽤？它是表级锁还是⾏级锁？" class="headerlink" title="5、意向锁是什么？有什么作⽤？它是表级锁还是⾏级锁？"></a>5、意向锁是什么？有什么作⽤？它是表级锁还是⾏级锁？</h2><p><strong>表级锁</strong>： 每次操作锁住整张表。开销小，加锁快；不会出现死锁；锁定粒度大，发生<strong>锁冲突的概率最高</strong>，并发度最低；</p>
<p><strong>行级锁</strong>： 每次操作锁住一行数据。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高；</p>
<p><strong>MyISAM和MEMORY存储引擎</strong>采用的是表级锁（table-level locking）；<strong>InnoDB存储引擎</strong>既支持行级锁（ row-level locking），也支持表级锁，但默认情况下是采用行级锁。</p>
<p><strong>不加索引情况下，update语句是表锁 ，加索引的情况下，update语句是行锁。</strong>普通的 select 是不会加⾏级锁的，普通的 select 语句是利⽤ MVCC 实现⼀致性读，是⽆锁的。注意，加索引的情况下，不一定走的是行锁，索引也有失效的时候。很多时候即使用了索引也有可能会走全表扫描，这是因为 MySQL 优化器的原因。</p>
<p>常见的各种锁：</p>
<ul>
<li><p>悲观锁</p>
<p>悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，在获取数据的时候先加锁，确保数据的安全性。<br>锁实现：关键字synchronized、Lock接口的实现<br>使用场景：写操作比较多，先加锁可以保证写操作时数据正确</p>
<p>传统的关系型数据库使用这种锁机制，比如行锁、表锁、读锁、写锁等，都是在操作之前先上锁</p>
</li>
<li><p>乐观锁</p>
</li>
</ul>
<p>乐观锁认为自己在使用数据的时候不会被别的线程修改，所以不会添加锁，只是在更新的时候去判断之前有没有别的线程更改过这个数据<br>        锁实现：CAS算法，例如<strong>AtomicInteger类的原子自增底层</strong>是通过CAS实现的<br>        使用场景：读多，不加锁的特点能够使读的性能大幅度提升</p>
<ul>
<li>读锁（共享锁）</li>
</ul>
<p>事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</p>
<p>场景：用于不更改或不更新数据的操作（只读操作），如 SELECT 语句。</p>
<ul>
<li>写锁（排他锁）</li>
</ul>
<p>事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）。</p>
<p>场景：用于数据修改操作，例如 INSERT、UPDATE 或 DELETE。确保不会同时同一资源进行多重更新。</p>
<ul>
<li>页锁</li>
</ul>
<p>页锁即对组加锁，对相邻数据加锁，数据库中介于表锁和行锁之间的锁，开销和加锁速度介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般<br>        实现：BDB（存储引擎）</p>
<ul>
<li>互斥锁（重量级锁或阻塞同步、悲观锁）</li>
</ul>
<p>互斥锁是一个互斥的同步对象，意味着同一时间有且仅有一个线程可以获取它，互斥锁可适用于<strong>一个共享资源每次只能被一个线程</strong>访问的情况</p>
<ul>
<li>自旋锁（CAS）</li>
</ul>
<p>自旋锁在申请资源但是申请不到的情况下并不会挂起，而是会选择持续申请。这种锁结果适用于<strong>每个线程占用较少时间</strong>的锁，并且线程阻塞状态切换的代价远高于等待的代价时使用。</p>
<ul>
<li>分布式锁</li>
</ul>
<p>在很多场景中，我们为了保证数据的最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁等。有的时候，我们需要保证一个方法在同一时间内只能被同一个线程执行。</p>
<p>实现：<strong>数据库实现分布式锁； 缓存（Redis等）实现分布式锁； Zookeeper实现分布式锁；</strong></p>
<ul>
<li>区间锁（分段锁）</li>
</ul>
<p><strong>ConcurrentHashMap <strong>jdk1.7使用了分段锁来保证线程安全，效率比起使用</strong>synchronized的HashTable</strong>要高的很多。每个集合都可以看作是一个存储东西的房子，HashTable与ConcurrentHashMap存储的都是HashEntry数组（每个数组里面是链表，暂且忽略，知道就好）</p>
<p>本题回答：</p>
<p><strong>意向锁是什么：</strong></p>
<p>在使⽤ InnoDB 引擎的表⾥时对某些记录加上「共享锁」之前，需要先在表级别加上⼀个「意向共享锁」 </p>
<p>在使⽤ InnoDB 引擎的表⾥时对某些记录加上「独占锁」之前，需要先在表级别加上⼀个「意向独占锁」 </p>
<p>也就是，当执⾏插⼊、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。</p>
<p><strong>作用：</strong></p>
<p>为了快速判断表⾥是否有记录被加锁，可以提⾼数据库并发性能，防⽌死锁的发⽣。它是表级锁，⽽不是⾏级锁。</p>
<p>表锁和⾏锁是满⾜<strong>读读共享、读写互斥、写写互斥的</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240313095020577-1737881543400171.png" alt="image-20240313095020577"></p>
<h2 id="6、InnoDB有哪几类行锁？"><a href="#6、InnoDB有哪几类行锁？" class="headerlink" title="6、InnoDB有哪几类行锁？"></a>6、InnoDB有哪几类行锁？</h2><p>InnoDB 行锁是通过对索引数据页上的记录加锁实现的，MySQL InnoDB 支持三种行锁定方式：</p>
<p><strong>记录锁（Record Lock）</strong>：也被称为记录锁，属于单个行记录上的锁。<br><strong>间隙锁（Gap Lock）</strong>：锁定一个范围，不包括记录本身。<br><strong>临键锁（Next-Key Lock）</strong>：Record Lock+Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题（MySQL 事务部分提到过）。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</p>
<p><strong>在 InnoDB 默认的隔离级别 REPEATABLE-READ 下，行锁默认使用的是 Next-Key Lock。但是，如果操作的索引是唯一索引或主键，InnoDB 会对 Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围。</strong></p>
<h2 id="7、MySQL-日志有了解过吗？binlog、redolog、undolog-分别有什么作用、有什么区别？"><a href="#7、MySQL-日志有了解过吗？binlog、redolog、undolog-分别有什么作用、有什么区别？" class="headerlink" title="7、MySQL 日志有了解过吗？binlog、redolog、undolog 分别有什么作用、有什么区别？"></a>7、MySQL 日志有了解过吗？binlog、redolog、undolog 分别有什么作用、有什么区别？</h2><p>binlog：即<strong>存档⽇志，是 Server 层⽣成的的⽇志，主要用于数据库之间的主从同步</strong>； </p>
<p>redolog：即<strong>前滚⽇志，是 Innodb 存储引擎层的⽇志，是 Mysql 实现持久性的重要保证，主要⽤于事务回归</strong>、数据库事故故障恢复； 		</p>
<p>uodolog：即<strong>回滚⽇志，是 Innodb 存储引擎层的⽇志，是 Mysql 实现原子性的重要保证，主要⽤于</strong>MVCC；</p>
<p>**⼀条记录的 uodolog 格式由 trx_ 事务 id + roll_pointer 指针串成⼀个链表，即版本链。此外在读提交和可重复读隔离级别中，它和快照 readView 实现了 MVCC。 **（⾸先当我们执⾏⼀条增删改 sql 语句（没⽤begin）时，mysql 会隐式开启事务执⾏该条语句，在执⾏完毕后  mysql 会⾃动提交事务，我们就能看⻅增删改的实际结果，但是如果在事务执⾏中，mysql 在没提交事务的时候崩溃了，那么数据有问题了，此时就需要回滚到事务之前的数据，它本质就是⽤于撤销回退的⽇志（ctrl+z），在事务没提交之前，mysql 会记录更新前的数据到 undolog 中，当事务回滚时，就利⽤ uodolog ⽇志进⾏回滚。）</p>
<p>然后是 <strong>redolog</strong>，是为了<strong>防⽌机器故障导致数据丢失</strong>的物理⽇志，它将<strong>内存写入磁盘的随机读写方式转换成顺序读写的方式</strong>写⼊磁盘。需要注意的是，<strong>当需要数据恢复的时候才会进行此操作（先顺序IO再随机IO，只有随机IO出现问题时才会使用redolog进行数据恢复）</strong>。           它和 uodolog 区别是：redolog 记录了 此次事务完成后的数据状态，记录的是更新之后的值；undolog 记录了此次事务开始前的数据状态，记录的是更新之前的值；它保证了数据的持久性。 </p>
<p><strong>binlog 是存档⽇志，在完成⼀条更新操作后，server 层会⽣成 binlog，等事务提交时，将此事务运⾏中产⽣的所有DDL记录通过追加写统⼀写⼊ binlog ⽇志⽂件，保存的是全量的⽇志</strong>，⽤于备份恢复和主从复制。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240313092244490-1737881543400173.png" alt="image-20240313092244490"></p>
<p><strong>两阶段提交保证两台机器之间的同步</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240313094402856-1737881543400174.png" alt="image-20240313094402856"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240314102825513-1737881543400176.png" alt="image-20240314102825513"></p>
<h2 id="8、MVCC-是什么？InnoDB-是如何实现-MVCC-机制的？"><a href="#8、MVCC-是什么？InnoDB-是如何实现-MVCC-机制的？" class="headerlink" title="8、MVCC 是什么？InnoDB 是如何实现 MVCC 机制的？"></a>8、MVCC 是什么？InnoDB 是如何实现 MVCC 机制的？</h2><p>MVCC（Multi-Version Concurrency Control）是<strong>⼀种并发控制机制，它通过为每个读操作创建⼀个视图（readview）来实现读写分离，保证了多个事务同时读写同⼀个数据时的⼀致性和并发性</strong>。 </p>
<p>InnoDB 是 MySQL 数据库中的⼀种存储引擎，它通过使⽤ <strong>MVCC 实现了⾼度并发的事务处理</strong>。 </p>
<p>MVCC 的具体实现，依赖于数据库记录中的<strong>隐式字段、undolog ⽇志、readView</strong>。 </p>
<p>在内部实现中，InnoDB 通过(数据⾏的 DB_TRX_ID(<strong>最近更新的事务id) 和 Read View</strong>) 来判断数据的可⻅性，如不可⻅，则通过<strong>undolog 版本链中的 DB_ROLL_PTR(回滚指针) 找到数据的历史版本</strong>。——————-快照读 </p>
<p>每个事务读到的数据版本可能是不⼀样的，<strong>在同⼀个事务中，⽤户只能看到该事务创建 Read View 之前已经提交的修改和该事务本身做的修改</strong></p>
<hr>
<p><strong>拓展：</strong></p>
<p>**MVCC 是怎么解决不可重复读的 **</p>
<p><strong>在 RC 读已提交下, 在事务中每⼀次执⾏快照读时⽣成 ReadView, 这也就造成了每次读取就有不同 ReadView, 那么 就会读到已提交的事务修改的内容, 造成不可重复读的问题。</strong></p>
<p><strong>解决 RR 不可重复读主要靠 readview, 在隔离级别为可重复读时, 仅在事务中第⼀次执⾏快照读时⽣成 ReadView,  后续复⽤该 ReadView</strong>。 由于后续<strong>复⽤了 ReadView, 所以数据对当前事务的可⻅性和第⼀次是⼀样的</strong>, 一般来说从 undolog 中读到的数据快照 和第⼀次是⼀样的, 但是需要注意在两次快照读中间出现当前读的情况，若当前读覆盖了其他事务新增的数据，则会重新生成readview，出现幻读的现象。</p>
<p>**MVCC是怎么防⽌幻读的 **</p>
<p>**InnoDB 存储引擎在 RR 级别下通过 MVCC 和 Next-key Lock(临键锁) 来解决幻读问题 **。</p>
<p>1、执⾏普通 select，此时会以 MVCC 快照读的⽅式读取数据 </p>
<ul>
<li>快照读: <strong>避免加锁通过 MVCC 来进⾏控制, 使其他事务所做的更新对当前事务不可⻅, 从⽽防⽌幻读</strong>.</li>
</ul>
<p>在快照读的情况下，RR 隔离级别只会在事务开启后的第⼀次查询⽣成 Read View ，并使⽤⾄事务提交。所以在⽣成 Read View 之后其它事务所做的更新、插⼊记录版本对当前事务并不可⻅，实现了可重复读和防⽌快照读下的  “幻读” </p>
<p>2、执⾏ select…for update&#x2F;lock in share mode、insert、update、delete 等当前读 </p>
<ul>
<li>当前读: **通过临键锁 next-key-lock 锁住空隙, 防⽌其他事务在查询的范围内插⼊数据, 从⽽防⽌幻读. **</li>
</ul>
<p>在当前读下，读取的都是最新的数据，如果其它事务有插⼊新的记录，并且刚好在当前事务查询范围内，就会产⽣幻读！InnoDB 使⽤ <strong>Next-key Lock 临键锁</strong>来防⽌这种情况。当执⾏当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防⽌其它事务在查询范围内插⼊数据。<strong>只要我不让你插⼊，就不会发⽣幻读</strong></p>
<h2 id="9、覆盖索引和联合索引是什么？讲⼀下索引的最左前缀匹配原则。"><a href="#9、覆盖索引和联合索引是什么？讲⼀下索引的最左前缀匹配原则。" class="headerlink" title="9、覆盖索引和联合索引是什么？讲⼀下索引的最左前缀匹配原则。"></a>9、覆盖索引和联合索引是什么？讲⼀下索引的最左前缀匹配原则。</h2><p>对于Innodb来讲，主键索引（聚簇索引）一定是存在的。</p>
<p><strong>覆盖索引</strong> </p>
<p><strong>一个索引包含了（或覆盖了）满足查询结果的数据</strong>就叫做覆盖索引。</p>
<p>是指<strong>SQL 中 query 的所有字段，在索引 B+ Tree 的叶⼦节点上都能找得到的那些索引，从$\textcolor{red}{⼆级索引（普通索引）}$中查询得到记录</strong>，⽽不需要通过<strong>聚簇索引</strong>查询获得，可以$\textcolor{red}{避免回表}$的操作</p>
<p><strong>联合索引</strong></p>
<p>通过将<strong>多个字段组合成⼀个索引</strong>，该索引就被称为联合索引</p>
<p><strong>最左前缀匹配原则</strong></p>
<p>使⽤<strong>联合索引时，存在最左匹配原则，也就是按照最左优先的⽅式进⾏索引的匹配。在使⽤联合索引进⾏查询的时候，如果不遵循「最左匹配原则</strong>，联合索引会失效，这样就⽆法利⽤到索引快速查询的特性了</p>
<p>综上所示，联合索引的最左匹配原则，在遇到<strong>范围查询</strong>（如 &gt;、&lt;）的时候，就会停⽌匹配，也就是范围查询的字段可以⽤到联合索引，但是在范围查询字段的后⾯的字段⽆法⽤到联合索引。注意，对于 <strong>&gt;&#x3D;、&lt;&#x3D;、BETWEEN、 like 前缀匹配的范围查询</strong>，并不会停⽌匹配。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240315101935578-1737881543400175.png" alt="image-20240315101935578"></p>
<h2 id="10、MySQL查询慢-除了索引还能因为什么？"><a href="#10、MySQL查询慢-除了索引还能因为什么？" class="headerlink" title="10、MySQL查询慢,除了索引还能因为什么？"></a>10、MySQL查询慢,除了索引还能因为什么？</h2><p>###<strong>1、MySQL优化器选错索引，使用explain</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/b6662cb786730bff72697e090700d906.png"></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/6bcbc66371700f539945c4d94a17fee7.png" style="zoom:50%;" />

<p>id列的值是select查询中的序号，比如：1、2、3、4等，它决定了表的执行顺序。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/eb11436348cc1850cf2bed8f573a629b.png" style="zoom: 67%;" />

<p>类型	含义<br>SIMPLE	简单SELECT查询，不包含子查询和UNION<br>PRIMARY	复杂查询中的最外层查询，表示主要的查询<br>SUBQUERY	SELECT或WHERE列表中包含了子查询<br>DERIVED	FROM列表中包含的子查询，即衍生<br>UNION	UNION关键字之后的查询<br>UNION RESULT	从UNION后的表获取结果集<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/42b8c1306879cbdd6165d8026bdf0132.png" style="zoom: 67%;" /></p>
<p>ref列</p>
<p>该列表示索引命中的列或者常量。</p>
<p>rows列</p>
<p>该列表示MySQL认为执行查询必须检查的行数。</p>
<p>索引优化的过程<br>   1.先用慢查询日志定位具体需要优化的sql</p>
<p>   2.使用explain执行计划查看索引使用情况</p>
<p>   3.重点关注：</p>
<pre><code>   key（查看有没有使用索引）

   key_len（查看索引使用是否充分）

   type（查看索引类型）

   Extra（查看附加信息：排序、临时表、where条件为false等）
</code></pre>
<p>   一般情况下根据这4列就能找到索引问题。</p>
<p>   4.根据上1步找出的索引问题优化sql</p>
<p>   5.再回到第2步<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/wufaqidong1/article/details/126863575?ops_request_misc=%7B%22request_id%22:%22C5D78AC3-2F5A-475E-A877-9BD85FEEFB10%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=C5D78AC3-2F5A-475E-A877-9BD85FEEFB10&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-126863575-null-null.142%5Ev100%5Epc_search_result_base2&utm_term=explain&spm=1018.2226.3001.4187">【最全最详细explain讲解】explain | 索引优化的这把绝世好剑，你真的会用吗？_检查索引的使用情况 expian-CSDN博客</a></p>
<p>###2、连接数</p>
<p>1、修改MySQL默认连接数（100）</p>
<p>2、增加客户端连接数</p>
<h3 id="3、Buffer-Pool-放的是数据页"><a href="#3、Buffer-Pool-放的是数据页" class="headerlink" title="3、Buffer Pool(放的是数据页)"></a>3、Buffer Pool(放的是数据页)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">命令：show status like &#x27;Innodb_buffer_pool_%&#x27;</span><br></pre></td></tr></table></figure>

<p>查看Buffer pool的命中率（低于99%就有问题）</p>
<p>##11、mysql索引为什么选择B+树而不是跳表？</p>
<p>B+树是个多叉平衡树，每个节点是个16k的数据页，每个索引页能指出1000多子页，3层左右可以存储2kw左右的数据</p>
<p>而跳表想要存储这么多数据，层高需要24层左右，最坏情况下，24层分散在不同的数据页中，查一次数据需要24次磁盘 IO</p>
<p>B+树的查询性能高，跳表写入高</p>
<p>##12、Redis为什么不用B+树而是跳表？</p>
<p>因为跳表更好实现，而且没有平衡树的旋转开销。至于跳表层数的io问题，redis是内存存储又不是磁盘到内存，io开销小</p>
<p>用B树需要6层，需要6次磁盘的IO。</p>
<p>先分析下B-树将行数据存在非叶子节点上的情况是怎么样的，假设每个数据页还是16KB，掐头去尾每页剩15KB，并且一条数据表行数据还是占1KB，就算不考虑各种页指针的情况下，也只能放个15条数据。数据页扇出明显变少了。而B-树将行数据存在叶子节点上的情况就跟B+树的几乎一样。 所以计算可承载的总行数的公式也变成了一个等比数列。15 + 15^2 +15^3 + … + 15^z , 其中z还是层数的意思。 为了能放2kw左右的数据，需要z&gt;&#x3D;6。也就是树需要有6层，查一次要访问6个页。假设这6个页并不连续，为了查询其中一条数据，最坏情况大概需要进行6次磁盘IO。 而B+树同样情况下放2kw数据左右，查一次大概是3次磁盘IO。 磁盘IO越多则越慢，这两者在性能上差距略大。 为此，B+树比B-树更适合成为mysql的索引。</p>
<p>##13、数据库分库分表是啥？读扩散又是啥？</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1wM4y1t7wx/?spm_id_from=333.788&vd_source=03235a8277a4e1950048927a7c975e38">玩原神学编程-数据库分库分表是啥？读扩散又是啥？_哔哩哔哩_bilibili</a></p>
<p>读写热点问题：id取模分表（id&#x2F;总数据量向下取整）和id范围分表</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240916154744270-1737881543400177.png" alt="image-20240916154744270"></p>
<p>水平分库：不同库中会对应同一个表的数据。</p>
<p>##14、数据库三范式</p>
<p>三范式（Third Normal Form, 3NF）是数据库设计中的一种规范化原则，用于消除数据冗余和避免数据更新异常。三范式是关系数据库设计中的一个重要概念，它建立在第一范式（1NF）和第二范式（2NF）的基础上。</p>
<h3 id="第一范式（1NF）"><a href="#第一范式（1NF）" class="headerlink" title="第一范式（1NF）"></a>第一范式（1NF）</h3><p>第一范式要求数据库表的每一列都是不可分割的原子值，即每一列只能包含一个值，不能包含多个值或集合。</p>
<h3 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h3><p>在满足第一范式的基础上，第二范式要求数据库表中的非主键字段必须完全依赖于主键，而不是部分依赖于主键。换句话说，非主键字段必须完全依赖于主键，而不是依赖于主键的一部分。</p>
<h3 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a>第三范式（3NF）</h3><p>在满足第二范式的基础上，第三范式要求数据库表中的非主键字段必须直接依赖于主键，而不能依赖于非主键字段。这意味着非主键字段之间不应该存在相互依赖的关系。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240916154922582-1737881543400178.png" alt="image-20240916154922582"></p>
<h1 id="SSM—-Spring、SpringMVC、MyBatis-SpringBoot"><a href="#SSM—-Spring、SpringMVC、MyBatis-SpringBoot" class="headerlink" title="SSM—&gt;Spring、SpringMVC、MyBatis   +    SpringBoot"></a>SSM—&gt;Spring、SpringMVC、MyBatis   +    SpringBoot</h1><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>Spring 各个模块的依赖关系：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/20200902100038.png"></p>
<ul>
<li><p><strong>spring-core</strong>：Spring 框架基本的核心工具类。</p>
</li>
<li><p><strong>spring-beans</strong>：提供对 bean 的创建、配置和管理等功能的支持。</p>
</li>
<li><p><font color=red><strong>spring-context</strong>:</font>提供对<strong>国际化、事件传播、资源加载</strong>等功能的支持。**</p>
<p><code>spring-context</code>是一个核心模块，它提供了Spring应用程序上下文（Application Context）的功能。<strong>这个模块定义了Spring的IoC（控制反转）容器</strong>，<strong>并提供了与Spring应用程序上下文相关的服务。</strong></p>
</li>
<li><p><strong>spring-expression</strong>：提供对表达式语言（Spring Expression Language） SpEL 的支持，只依赖于 core 模块，不依赖于其他模块，可以单独使用</p>
<p>AOP：</p>
</li>
<li><p><strong>spring-aspects</strong>：该模块为与 AspectJ 的集成提供支持。</p>
</li>
<li><p><strong>spring-aop</strong>：提供了面向切面的编程实现。</p>
</li>
<li><p><strong>spring-instrument</strong>：提供了为 JVM 添加代理（agent）的功能。 具体来讲，它为 Tomcat 提供了一个织入代理，能够为 Tomcat 传递类文 件，就像这些文件是被类加载器加载的一样。没有理解也没关系，这个模块的使用场景非常有限</p>
</li>
</ul>
<p>​		Data Access&#x2F;Integration：</p>
<ul>
<li><p><strong>spring-jdbc</strong>：提供了对数据库访问的抽象 JDBC。不同的数据库都有自己独立的 API 用于操作数据库，而 Java 程序只需要和 JDBC API 交互，这样就屏蔽了数据库的影响。</p>
</li>
<li><p><strong>spring-tx</strong>：提供对事务的支持。</p>
</li>
<li><p><strong>spring-orm</strong>：提供对 Hibernate、JPA、iBatis 等 ORM 框架的支持。</p>
</li>
<li><p><strong>spring-oxm</strong>：提供一个抽象层支撑 OXM(Object-to-XML-Mapping)，例如：JAXB、Castor、XMLBeans、JiBX 和 XStream 等。</p>
</li>
<li><p><strong>spring-jms</strong> : 消息服务。自 Spring Framework 4.1 以后，它还提供了对 spring-messaging 模块的继承。</p>
</li>
</ul>
<p>​		Spring Web：</p>
<ul>
<li><p><strong>spring-web</strong>：对 Web 功能的实现提供一些最基础的支持。</p>
</li>
<li><p><strong>spring-webmvc</strong>：提供对 Spring MVC 的实现。</p>
</li>
<li><p><strong>spring-websocket</strong>：提供了对 WebSocket 的支持，WebSocket 可以让客户端和服务端进行双向通信。</p>
</li>
<li><p><strong>spring-webflux</strong>：提供对 WebFlux 的支持。WebFlux 是 Spring Framework 5.0 中引入的新的响应式框架。与 Spring MVC 不同，它不需要 Servlet API，是完全异步。</p>
</li>
</ul>
<p>​		Messaging：</p>
<ul>
<li><strong>spring-messaging</strong> 是从 Spring4.0 开始新加入的一个模块，主要职责是为 Spring 框架集成一些基础的报文传送应用。</li>
</ul>
<p>​		Spring  Test:</p>
<ul>
<li><p>Spring 团队提倡测试驱动开发（TDD）。有了控制反转 (IoC)的帮助，单元测试和集成测试变得更简单。</p>
</li>
<li><p>Spring 的测试模块对 JUnit（单元测试框架）、TestNG（类似 JUnit）、Mockito（主要用来 Mock 对象）、PowerMock（解决 Mockito 的问题比如无法模拟 final, static， private 方法）等等常用的测试框架支持的都比较好。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/1663726169861-b5acb757-17e0-4d3d-a811-400eb7edd1b3.png"></p>
</li>
</ul>
<p>**Spring,Spring MVC,Spring Boot 之间什么关系?**（总结的不好—后面要改）</p>
<ul>
<li><p>Spring MVC 是 Spring 中的一个很重要的模块，主要赋予 Spring 快速构建 MVC 架构的 Web 程序的能力。MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。</p>
</li>
<li><p>使用 Spring 进行开发各种配置过于麻烦比如开启某些 Spring 特性时，需要用 XML 或 Java 进行显式配置。于是，Spring Boot 诞生了！</p>
</li>
</ul>
<ol>
<li><p>Spring 旨在简化 J2EE 企业应用程序开发。Spring Boot 旨在简化 Spring 开发（减少配置文件，开箱即用！）。</p>
</li>
<li><p>Spring Boot 只是简化了配置，如果你需要构建 MVC 架构的 Web 程序，你还是需要使用 Spring MVC 作为 MVC 框架，只是说 Spring Boot 帮你简化了 Spring MVC 的很多配置，真正做到开箱即用！</p>
<p>SpringBoot 是基于 <strong>Spring 框架的⼀个开发框架</strong>，⽤于快速构建独⽴的、⽣产级别的 Spring 应⽤程序。<strong>它通过⾃动配置和约定优于配置的</strong>⽅式，简化了 Spring 应⽤程序的配置和开发过程。SpringBoot 集成了很多常⽤ 的第三⽅库和⼯具，例如 Spring Data、Spring Security、Thymeleaf、Logback 等，可以极⼤地提⾼开发效 率。</p>
<p>因此，SpringBoot 可以看作是在 Spring 的基础上，通过⾃动配置和约定优于配置的⽅式，提供了更加简单、快速 的开发体验。⽽ SpringMVC 则是 Spring 框架中⽤于构建 Web 应⽤程序的模块。</p>
<p> Spring Boot 内置了 Tomcat、Undertow 等服务器，不⽤像传统 SSM⼀样⾃⼰ 去搭 Tomcat 等环境了，简化了开发</p>
</li>
</ol>
<hr>
<p>依赖倒置原则(Dependence Inversion Principle)，简称DIP，主要倡导面向抽象编程，面向接口编程，不要面向具体编程，让<strong>上层</strong>不再依赖<strong>下层</strong>，下面改动了，上面的代码不会受到牵连。这样可以大大降低程序的耦合度，耦合度低了，扩展力就强了，同时代码复用性也会增强。（<strong>软件七大开发原则都是在为解耦合服务</strong>）</p>
<p>控制反转（Inversion of Control，缩写为IoC）</p>
<ul>
<li><p>控制反转是一种思想。</p>
</li>
<li><p>控制反转是为了降低程序耦合度，提高程序扩展力，达到OCP原则，达到DIP原则。</p>
</li>
<li><p>控制反转的核心是：<strong>将对象的创建权交出去，将对象和对象之间关系的管理权交出去，由第三方容器来负责创建与维护</strong>。</p>
</li>
<li><p>控制反转常见的实现方式：依赖注入（Dependency Injection，简称DI）</p>
</li>
</ul>
<p>通常，依赖注入的实现又包括两种方式（底层调用反射）：</p>
<ul>
<li><p>set方法注入（基于set方法实现的，底层会通过反射机制调用属性对应的set方法然后给属性赋值。这种方式要求属性必须对外提供set方法。）</p>
</li>
<li><p>构造方法注入（通过调用构造方法来给属性赋值。）</p>
</li>
</ul>
<p>而Spring框架就是一个实现了IoC思想的框架。</p>
<ul>
<li>在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。</li>
</ul>
<h3 id="Spring-Bean"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a>Spring Bean</h3><h4 id="1）是什么"><a href="#1）是什么" class="headerlink" title="1）是什么"></a>1）是什么</h4><p><strong>Bean 代指的就是那些被 IoC 容器所管理的对象。</strong></p>
<p>我们需要告诉 IoC 容器帮助我们管理哪些对象，这个是通过配置元数据来定义的。配置元数据可以是 XML 文件、注解或者 Java 配置类。</p>
<p>声明Bean的注解：</p>
<ul>
<li>@Component：通用的注解，可标注任意类为 Spring 组件。如果一个 Bean 不知道属于哪个层，可以使用@Component 注解标注。</li>
<li>@Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。</li>
<li>@Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</li>
<li>@Controller : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面</li>
</ul>
<h4 id="2）-Component-和-Bean-的区别是什么？"><a href="#2）-Component-和-Bean-的区别是什么？" class="headerlink" title="2）@Component 和 @Bean 的区别是什么？"></a>2）@Component 和 @Bean 的区别是什么？</h4><ul>
<li><code>@Component</code>注解作用于类，而<code>@Bean</code>注解作用于方法。</li>
<li><code>@Component</code> 通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。@Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean,@Bean告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。</li>
<li>@Bean 注解比 @Component 注解的自定义性更强，而且很多地方我们只能通过 @Bean 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 Spring容器时，则只能通过 @Bean来实现。</li>
</ul>
<p>####3）@Autowired 和@Resource的区别是什么？</p>
<p><code>@Autowired</code> 属于 <strong>Spring 内置</strong>的注解，默认的注入方式为byType（根据类型进行匹配），也就是说会优先根据接口类型去匹配并注入 Bean （接口的实现类）。</p>
<p>这会有什么问题呢？ 当一个接口存在多个实现类的话，byType这种方式就无法正确注入对象了，因为这个时候 Spring 会同时找到多个满足条件的选择，默认情况下它自己不知道选择哪一个。这种情况下，注入方式会变为 byName（根据名称进行匹配），这个名称通常就是类名（首字母小写）。</p>
<p><code>@Resource</code>属于<strong>JDK</strong>提供的注解，默认注入方式为 byName。如果无法通过名称匹配到对应的 Bean 的话，注入方式会变为byType。</p>
<p>总结：</p>
<ul>
<li>@Autowired 是 Spring 提供的注解，@Resource 是 JDK 提供的注解。</li>
<li>@Autowired 默认的注入方式为byType（根据类型进行匹配），@Resource默认注入方式为 byName（根据名称进行匹配）。</li>
<li>当一个接口存在多个实现类的情况下，@Autowired 和@Resource都需要通过名称才能正确匹配到对应的 Bean。**@Autowired 可以通过 @Qualifier 注解来显式指定名称，@Resource可以通过 name 属性来显式指定名称。**</li>
<li>@Autowired 支持在<strong>构造函数</strong>、方法、字段和<strong>参数</strong>上使用。@Resource 主要用于字段和方法上的注入，不支持在构造函数或参数上使用。</li>
</ul>
<h4 id="4）Bean的作用域是什么？"><a href="#4）Bean的作用域是什么？" class="headerlink" title="4）Bean的作用域是什么？"></a>4）Bean的作用域是什么？</h4><ul>
<li><p>singleton</p>
<ul>
<li>Spring的IoC容器中，默认情况下，<strong>Bean对象是单例的</strong>。Bean对象的创建是在初始化Spring上下文的时候就完成的。</li>
</ul>
</li>
<li><p>prototype</p>
<ul>
<li>如果想让Spring的Bean对象以多例的形式存在，可以在bean标签中指定scope属性的值为：<strong>prototype</strong>，这样Spring会在<strong>每一次执行getBean()方法的时候创建Bean对象</strong>，调用几次则创建几次。</li>
</ul>
</li>
<li><p>其它scope（共8个）</p>
<ul>
<li>singleton：默认的，单例。</li>
<li>prototype：原型。每调用一次getBean()方法则获取一个新的Bean对象。或每次注入的时候都是新对象。</li>
<li>request：一个请求对应一个Bean。<strong>仅限于在WEB应用中使用</strong>。</li>
<li>session：一个会话对应一个Bean。<strong>仅限于在WEB应用中使用</strong>。</li>
<li>global session：<strong>portlet应用中专用的</strong>。如果在Servlet的WEB应用中使用global session的话，和session一个效果。（portlet和servlet都是规范。servlet运行在servlet容器中，例如Tomcat。portlet运行在portlet容器中。）</li>
<li>application：一个应用对应一个Bean。<strong>仅限于在WEB应用中使用。</strong></li>
<li>websocket：一个websocket生命周期对应一个Bean。<strong>仅限于在WEB应用中使用。</strong></li>
<li>自定义scope：很少使用。</li>
</ul>
</li>
</ul>
<h4 id="5）bean是线程安全的吗"><a href="#5）bean是线程安全的吗" class="headerlink" title="5）bean是线程安全的吗?"></a>5）bean是线程安全的吗?</h4><p>Spring 框架中的 <strong>Bean 是否线程安全</strong>，取决于其<strong>作用域和状态</strong>。</p>
<p>我们这里以最常用的两种作用域 prototype 和 singleton 为例介绍。几乎所有场景的 Bean 作用域都是使用默认的 singleton ，重点关注 singleton 作用域即可。</p>
<p><strong>prototype 作用域下，每次获取都会创建一个新的 bean 实例，不存在资源竞争问题，所以不存在线程安全问题</strong>。<strong>singleton 作用域下，IoC 容器中只有唯一的 bean 实例，可能会存在资源竞争问题（取决于 Bean 是否有状态）。如果这个 bean 是有状态的话，那就存在线程安全问题（有状态 Bean 是指包含可变的成员变量的对象）。</strong></p>
<p>不过，大部分 Bean 实际都是无状态（没有定义可变的成员变量）的（比如 Dao、Service），这种情况下， Bean 是线程安全的。</p>
<p>对于有状态单例 Bean 的线程安全问题，常见的有两种解决办法：</p>
<ul>
<li>在 Bean 中尽量<strong>避免定义可变</strong>的成员变量。</li>
<li>在类中定义一个 <strong>ThreadLocal</strong>成员变量，将需要的可变成员变量保存在 <strong>ThreadLocal</strong> 中（推荐的一种方式）。</li>
</ul>
<p>####6）Bean的生命周期了解吗？（面试）</p>
<p>Spring其实就是一个管理Bean对象的工厂。它负责对象的创建，对象的销毁等。</p>
<p>所谓的生命周期就是：<strong>对象从创建开始到最终销毁的整个过程。</strong></p>
<ul>
<li><p>什么时候创建Bean对象？</p>
</li>
<li><p>创建Bean对象的前后会调用什么方法？</p>
</li>
<li><p>Bean对象什么时候销毁？</p>
</li>
<li><p>Bean对象的销毁前后调用什么方法？</p>
</li>
</ul>
<hr>
<p>答案：</p>
<p>Bean生命周期可以粗略的划分为五大步（<strong>粗略版</strong>）：</p>
<ul>
<li>第一步：实例化Bean</li>
<li>第二步：Bean属性赋值</li>
<li>第三步：初始化Bean</li>
<li>第四步：使用Bean</li>
<li>第五步：销毁Bean</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/1665388735200-444405f6-283d-4b3a-8cdf-8c3e01743618.png"></p>
<p>注意：</p>
<ul>
<li>第一：只有正常关闭spring容器，bean的销毁方法才会被调用。</li>
<li>第二：ClassPathXmlApplicationContext类才有close()方法。</li>
<li>第三：配置文件中的init-method指定初始化方法。destroy-method指定销毁方法</li>
</ul>
<p>Bean生命周期之7步（<strong>较详细版</strong>）（一般回答这个即可）：</p>
<p>在以上的5步中，第3步是初始化Bean，如果你还想在初始化前和初始化后添加代码，可以加入“Bean后处理器”。编写一个类实现<strong>BeanPostProcessor</strong>类，并且重写before和after方法。</p>
<p>如果加上Bean后处理器的话，Bean的生命周期就是7步了：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/1665393936765-0ea5dcdd-859a-4ac5-9407-f06022c498b9.png"></p>
<p> Bean生命周期之10步（<strong>详细版</strong>）：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/1665394697870-15de433a-8d50-4b31-9b75-b2ca7090c1c6.png"></p>
<p>Aware相关的接口包括：BeanNameAware、 、BeanFactoryAware</p>
<ul>
<li>当Bean实现了BeanNameAware，Spring会将Bean的名字传递给Bean。</li>
<li>当Bean实现了BeanClassLoaderAware，Spring会将加载该Bean的类加载器传递给Bean。</li>
<li>当Bean实现了BeanFactoryAware，Spring会将Bean工厂对象传递给Bean。</li>
</ul>
<p>####7）Bean的作用域不同，管理方式也不同</p>
<ul>
<li>对于<strong>singleton作用域的Bean</strong>，Spring 能够精确地知道该Bean何时被创建，何时初始化完成，以及何时被销毁；</li>
<li>而对于 prototype 作用域的 Bean，Spring 只负责创建，当容器创建了 Bean 的实例后，Bean 的实例就交给客户端代码管理，Spring 容器将不再跟踪其生命周期。</li>
</ul>
<h4 id="8）Bean的循环依赖问题"><a href="#8）Bean的循环依赖问题" class="headerlink" title="8）Bean的循环依赖问题"></a>8）Bean的循环依赖问题</h4><p>A对象中有B属性。B对象中有A属性。这就是循环依赖。我依赖你，你也依赖我。</p>
<p>比如：丈夫类Husband，妻子类Wife。Husband中有Wife的引用。Wife中有Husband的引用</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/1665452274046-82594b87-2974-4e08-a6ab-2218d001d14f.png"></p>
<ul>
<li><p><strong>在singleton + set注入的情况下，循环依赖是没有问题的。Spring可以解决这个问题。</strong></p>
<ul>
<li><p>构造注入是无法解决这种循环依赖的，因为构造方法注入会导致<strong>实例化对象的过程</strong>和<strong>对象属性赋值的过程</strong>没有分离开，必须在一起完成导致的。</p>
</li>
<li><p>根本的原因在于：这种方式可以做到将“实例化Bean”和“给Bean属性赋值”这两个动作分开去完成。</p>
<p>实例化Bean的时候：调用无参数构造方法来完成。<strong>此时可以先不给属性赋值，可以提前将该Bean对象“曝光”给外界。</strong></p>
</li>
<li><p><strong>Spring只能解决setter方法注入的单例bean之间的循环依赖。ClassA依赖ClassB，ClassB又依赖ClassA，形成依赖闭环。Spring在创建ClassA对象后，不需要等给属性赋值，直接将其曝光到bean缓存当中。在解析ClassA的属性时，又发现依赖于ClassB，再次去获取ClassB，当解析ClassB的属性时，又发现需要ClassA的属性，但此时的ClassA已经被提前曝光加入了正在创建的bean的缓存中，则无需创建新的的ClassA的实例，直接从缓存中获取即可。从而解决循环依赖问题。</strong></p>
</li>
</ul>
</li>
<li><p>当循环依赖的<strong>所有Bean</strong>的scope&#x3D;”prototype”的时候，产生的循环依赖，Spring是无法解决的，会出现<strong>BeanCurrentlyInCreationException</strong>异常。</p>
</li>
<li><p>如果其中一个是singleton，另一个是prototype，是没有问题的。</p>
</li>
</ul>
<h3 id="Spring-Aop-使用过吗？怎么使用？"><a href="#Spring-Aop-使用过吗？怎么使用？" class="headerlink" title="Spring Aop,使用过吗？怎么使用？"></a><font color=red>Spring Aop,使用过吗？怎么使用？</font></h3><p>IoC使软件组件松耦合。AOP让你能够捕捉系统中经常使用的功能，把它转化成组件。</p>
<p><strong>AOP（Aspect Oriented Programming）</strong>：面向切面编程，面向方面编程。（AOP是一种编程技术）</p>
<p><strong>AOP是对OOP的补充延伸。</strong></p>
<p>AOP底层使用的就是动态代理来实现的。</p>
<p>Spring的AOP使用的动态代理是：<strong>JDK动态代理 + CGLIB动态代理技术</strong>。Spring在这两种动态代理中灵活切换，如果是代理接口，会默认使用JDK动态代理，如果要代理某个类，这个类没有实现接口，就会切换使用CGLIB。当然，你也可以强制通过一些配置让Spring只使用CGLIB。</p>
<p>AOP(Aspect-Oriented Programming)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如<strong>事务处理、日志管理、权限控制</strong>等）封装起来，<strong>便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性</strong>。</p>
<p>Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 <strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/230ae587a322d6e4d09510161987d346.jpeg"></p>
<p>当然你也可以使用 <code>AspectJ </code>！Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240307224632998-1737881543400179.png" alt="image-20240307224632998"></p>
<p>Spring对AOP的实现包括以下3种方式：</p>
<ul>
<li><font color=red><strong>第一种方式：Spring框架结合AspectJ框架实现的AOP，基于注解方式。</strong></font></li>
<li><font color=red><strong>第二种方式：Spring框架结合AspectJ框架实现的AOP，基于XML方式。</strong></font></li>
<li>第三种方式：Spring框架自己实现的AOP，基于XML配置方式。</li>
</ul>
<p>实际开发中，都是Spring+AspectJ来实现AOP。所以我们重点学习第一种和第二种方式。</p>
<p>使用Spring AOP进行登录验证：</p>
<ol>
<li><p><strong>定义登录验证逻辑</strong>：首先，你需要定义一个登录验证的逻辑。这通常涉及用户名和密码的验证。</p>
</li>
<li><p><strong>创建拦截器</strong>：创建一个拦截器类，实现<code>HandlerInterceptor</code>接口，或者继承<code>HandlerInterceptorAdapter</code>类。在这个拦截器中，你可以添加登录验证逻辑。</p>
</li>
<li><p><strong>配置拦截器</strong>：在Spring配置文件中，或者使用Java配置，注册你的拦截器。你可以配置哪些URL需要拦截，哪些不需要。</p>
</li>
<li><p><strong>使用代理</strong>：Spring AOP使用代理来拦截方法调用。如果你的目标对象没有实现任何接口，Spring会使用CGLIB来创建代理。如果你的目标对象实现了接口，Spring会使用JDK动态代理。</p>
</li>
<li><p><strong>配置AOP</strong>：在Spring配置文件中，或者使用Java配置，配置AOP，包括切入点（Pointcut）和通知（Advice）。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240522211405218-1737881543400180.png" alt="image-20240522211405218"></p>
</li>
</ol>
<h4 id="1）Spring-AOP和AspectJ-AOP有什么区别？"><a href="#1）Spring-AOP和AspectJ-AOP有什么区别？" class="headerlink" title="1）Spring AOP和AspectJ AOP有什么区别？"></a>1）Spring AOP和AspectJ AOP有什么区别？</h4><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作</strong>(Bytecode Manipulation)。</p>
<p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p>
<p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多。</p>
<h4 id="2）AspectJ定义的通知类型"><a href="#2）AspectJ定义的通知类型" class="headerlink" title="2）AspectJ定义的通知类型"></a>2）AspectJ定义的通知类型</h4><ul>
<li>前置通知：@Before 目标方法执行之前的通知</li>
<li>后置通知：@AfterReturning 目标方法执行之后的通知</li>
<li>异常通知：@AfterThrowing 发生异常之后执行的通知</li>
<li>最终通知：@After 放在finally语句块中的通知</li>
<li>Around （环绕通知）：@Around 目标方法之前添加通知，同时目标方法执行之后添加通知。编程式控制目标对象的方法调用。环绕通知是<strong>所有通知类型中可操作范围最大的一种</strong>，因为它可以直接拿到目标对象，以及要执行的方法，所以环绕通知可以任意的在目标对象的方法调用前后搞事，甚至不调用目标对象的方法。</li>
</ul>
<h4 id="3）多个切面的执行顺序如何控制？"><a href="#3）多个切面的执行顺序如何控制？" class="headerlink" title="3）多个切面的执行顺序如何控制？"></a>3）多个切面的执行顺序如何控制？</h4><p>1、通常使用**@Order 注解直接定义切面顺序**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 值越小优先级越高</span></span><br><span class="line"><span class="meta">@Order(3)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> <span class="keyword">implements</span> <span class="title class_">Ordered</span> &#123;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、实现Ordered 接口重写 getOrder 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> <span class="keyword">implements</span> <span class="title class_">Ordered</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 返回值越小优先级越高</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a>Spring 事务</h3><h4 id="1）Spring实现事务的两种方式"><a href="#1）Spring实现事务的两种方式" class="headerlink" title="1）Spring实现事务的两种方式"></a>1）Spring实现事务的两种方式</h4><ul>
<li>编程式事务<ul>
<li>通过编写代码的方式来实现事务的管理。通过 <code>TransactionTemplate</code>或者 <code>TransactionManager</code> 手动管理事务，事务范围过大会出现事务未提交导致超时，因此事务要比锁的粒度更小。</li>
</ul>
</li>
<li>声明式事务<ul>
<li>基于注解方式</li>
<li>基于XML配置方式</li>
</ul>
</li>
</ul>
<p>上面两种方式实际是通过 AOP 实现（基于<code>@Transactional</code> 的全注解方式使用最多）		</p>
<h4 id="2）事务属性"><a href="#2）事务属性" class="headerlink" title="2）事务属性"></a>2）事务属性</h4><ul>
<li>事务传播行为</li>
<li>事务隔离级别</li>
<li>事务超时</li>
<li>只读事务</li>
<li>设置出现哪些异常回滚事务</li>
<li>设置出现哪些异常不回滚事务</li>
</ul>
<h4 id="3）Spring有哪几种事务传播行为"><a href="#3）Spring有哪几种事务传播行为" class="headerlink" title="3）Spring有哪几种事务传播行为"></a>3）Spring有哪几种事务传播行为</h4><p><strong>事务传播行为是为了解决业务层方法之间互相调用的事务问题</strong>。事务传播行为在spring框架中被定义为<strong>枚举类型</strong>。</p>
<p>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。</p>
<p><strong>1.<code>TransactionDefinition.PROPAGATION_REQUIRED</code></strong></p>
<p>使用的最多的一个事务传播行为，我们平时经常使用的<code>@Transactional</code>注解默认使用就是这个事务传播行为。&#x2F;&#x2F;如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</p>
<p><strong><code>2.TransactionDefinition.PROPAGATION_REQUIRES_NEW</code></strong></p>
<p>创建一个新的事务，如果当前存在事务，则把当前事务挂起。&#x2F;&#x2F;也就是说不管外部方法是否开启事务，<code>Propagation.REQUIRES_NEW</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</p>
<p><strong>3.<code>TransactionDefinition.PROPAGATION_NESTED</code></strong></p>
<p>如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于<code>TransactionDefinition.PROPAGATION_REQUIRED</code>。</p>
<p><strong>4.<code>TransactionDefinition.PROPAGATION_MANDATORY</code></strong></p>
<p>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</p>
<p>这个使用的很少。</p>
<p>若是错误的配置以下 3 种事务传播行为，事务将不会发生回滚：</p>
<p><strong><code>TransactionDefinition.PROPAGATION_SUPPORTS</code></strong>: 如果当前存在事务，则加入该事务；&#x2F;&#x2F;如果当前没有事务，则以非事务的方式继续运行。</p>
<p><strong><code>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</code></strong>: &#x2F;&#x2F;以非事务方式运行，&#x2F;&#x2F;如果当前存在事务，则把当前事务挂起。</p>
<p><strong><code>TransactionDefinition.PROPAGATION_NEVER</code></strong>: &#x2F;&#x2F;以非事务方式运行，&#x2F;&#x2F;如果当前存在事务，则抛出异常。</p>
<h4 id="4）隔离级别"><a href="#4）隔离级别" class="headerlink" title="4）隔离级别"></a>4）隔离级别</h4><p><strong><code>TransactionDefinition.ISOLATION_DEFAULT</code></strong> :使用后端数据库默认的隔离级别，MySQL 默认采用的 <code>REPEATABLE_READ</code> 隔离级别 Oracle 默认采用的 <code>READ_COMMITTED</code> 隔离级别.</p>
<p><strong><code>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</code></strong> :最低的隔离级别，使用这个隔离级别很少，因为它允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong></p>
<p><strong><code>TransactionDefinition.ISOLATION_READ_COMMITTED</code></strong> : 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></p>
<p><strong><code>TransactionDefinition.ISOLATION_REPEATABLE_READ</code></strong> : 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></p>
<p><strong><code>TransactionDefinition.ISOLATION_SERIALIZABLE</code></strong> : 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</p>
<p>####5）@Transactional（rollbackFor&#x3D;Exception.class）注解了解吗？<font color='RED'>**</font></p>
<p><code>Exception</code> 分为运行时异常 <code>RuntimeException</code> 和非运行时异常。事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以保证数据的一致性。</p>
<p>当 <code>@Transactional</code> 注解作用于类上时，<strong>该类的所有 public 方法将都具有该类型的事务属性</strong>，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。</p>
<p><code>@Transactional</code> 注解默认回滚策略是<strong>只有在遇到<code>RuntimeException</code>(运行时异常) 或者 <code>Error</code> 时才会回滚事务，而不会回滚 <code>Checked Exception</code>（受检查异常）</strong>。<strong>这是因为 Spring 认为<code>RuntimeException</code>和 Error 是不可预期的错误，而受检异常是可预期的错误，可以通过业务逻辑来处理。</strong></p>
<p>如果想要修改默认的回滚策略，可以使用 <code>@Transactional</code> 注解的 <code>rollbackFor</code> 和 <code>noRollbackFor</code> 属性来指定哪些异常需要回滚，哪些异常不需要回滚。例如，如果想要让所有的异常都回滚事务，可以使用如下的注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// some business logic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想要让某些特定的异常不回滚事务，可以使用如下的注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(noRollbackFor = CustomException.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// some business logic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240522212252002-1737881543400181.png" alt="image-20240522212252002"></p>
<p><strong>AOP失效：内部调用不会触发AOP、必须走代理</strong></p>
<h4 id="6）Spring-Data-JPA（6，7没有接触过）"><a href="#6）Spring-Data-JPA（6，7没有接触过）" class="headerlink" title="6）Spring Data JPA（6，7没有接触过）"></a>6）Spring Data JPA（6，7没有接触过）</h4><p>JPA 重要的是实战，这里仅对小部分知识点进行总结</p>
<h5 id="1）如何使用JPA在数据库中非持久化一个字段"><a href="#1）如何使用JPA在数据库中非持久化一个字段" class="headerlink" title="1）如何使用JPA在数据库中非持久化一个字段"></a>1）如何使用JPA在数据库中非持久化一个字段</h5><p>假如我们有下面一个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity(name=&quot;USER&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.AUTO)</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;ID&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name=&quot;USER_NAME&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name=&quot;PASSWORD&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String secrect;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果我们想让<code>secrect</code> 这个字段不被持久化，也就是不被数据库存储怎么办？我们可以采用下面几种方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> String transient1; <span class="comment">// not persistent because of static</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">transient2</span> <span class="operator">=</span> <span class="string">&quot;Satish&quot;</span>; <span class="comment">// not persistent because of final</span></span><br><span class="line"><span class="keyword">transient</span> String transient3; <span class="comment">// not persistent because of transient</span></span><br><span class="line"><span class="meta">@Transient</span></span><br><span class="line">String transient4; <span class="comment">// not persistent because of @Transient</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一般使用后面两种方式比较多，我个人使用注解的方式比较多。</p>
<h5 id="2-JPA的审计功能是做什么的？有什么用？"><a href="#2-JPA的审计功能是做什么的？有什么用？" class="headerlink" title="2)JPA的审计功能是做什么的？有什么用？"></a>2)JPA的审计功能是做什么的？有什么用？</h5><p>审计功能主要是帮助我们记录数据库操作的具体行为比如某条记录是谁创建的、什么时间创建的、最后修改人是谁、最后修改时间是什么时候。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@MappedSuperclass</span></span><br><span class="line"><span class="meta">@EntityListeners(value = AuditingEntityListener.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractAuditBase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CreatedDate</span></span><br><span class="line">    <span class="meta">@Column(updatable = false)</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> Instant createdAt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@LastModifiedDate</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> Instant updatedAt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CreatedBy</span></span><br><span class="line">    <span class="meta">@Column(updatable = false)</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> String createdBy;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@LastModifiedBy</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> String updatedBy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>@CreatedDate</code>: 表示该字段为创建时间字段，在这个实体被 insert 的时候，会设置值</p>
<p><code>@CreatedBy</code> :表示该字段为创建人，在这个实体被 insert 的时候，会设置值</p>
<p><code>@LastModifiedDate</code>、<code>@LastModifiedBy</code>同理</p>
<h5 id="3）实体之间的关键关系注解有哪些？"><a href="#3）实体之间的关键关系注解有哪些？" class="headerlink" title="3）实体之间的关键关系注解有哪些？"></a>3）实体之间的关键关系注解有哪些？</h5><ul>
<li><code>@OneToOne</code> : 一对一。</li>
<li><code>@ManyToMany</code>：多对多。</li>
<li><code>@OneToMany</code> : 一对多。</li>
<li><code>@ManyToOne</code>：多对一。</li>
</ul>
<p>利用 <code>@ManyToOne</code> 和 <code>@OneToMany</code> 也可以表达多对多的关联关系。</p>
<h4 id="7）Spring-Security"><a href="#7）Spring-Security" class="headerlink" title="7）Spring Security"></a>7）Spring Security</h4><p>Spring Security 重要的是实战，这里仅对小部分知识点进行总结。</p>
<h5 id="1）有哪些控制请求访问权限的方法？"><a href="#1）有哪些控制请求访问权限的方法？" class="headerlink" title="1）有哪些控制请求访问权限的方法？"></a>1）有哪些控制请求访问权限的方法？</h5><p><code>permitAll()</code>：无条件允许任何形式访问，不管你登录还是没有登录。</p>
<p><code>anonymous()</code>：允许匿名访问，也就是没有登录才可以访问。</p>
<p><code>denyAll()</code>：无条件决绝任何形式的访问。</p>
<p><code>authenticated()</code>：只允许已认证的用户访问。</p>
<p><code>fullyAuthenticated()</code>：只允许已经登录或者通过 remember-me 登录的用户访问。</p>
<p><code>hasRole(String)</code> : 只允许指定的角色访问。</p>
<p><code>hasAnyRole(String)</code> : 指定一个或者多个角色，满足其一的用户即可访问。</p>
<p><code>hasAuthority(String)</code>：只允许具有指定权限的用户访问</p>
<p><code>hasAnyAuthority(String)</code>：指定一个或者多个权限，满足其一的用户即可访问。</p>
<p><code>hasIpAddress(String)</code> : 只允许指定 ip 的用户访问</p>
<h5 id="2）有哪些控制请求访问权限的方法？"><a href="#2）有哪些控制请求访问权限的方法？" class="headerlink" title="2）有哪些控制请求访问权限的方法？"></a>2）有哪些控制请求访问权限的方法？</h5><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/GTNOa2k9_n_H0w24upClRw">Spring Security 中的 hasRole 和 hasAuthority 有区别吗？</a></p>
<h5 id="3）有哪些控制请求访问权限的方法？"><a href="#3）有哪些控制请求访问权限的方法？" class="headerlink" title="3）有哪些控制请求访问权限的方法？"></a>3）有哪些控制请求访问权限的方法？</h5><p>如果我们需要保存密码这类敏感数据到数据库的话，需要先加密再保存。</p>
<p>Spring Security 提供了多种加密算法的实现，开箱即用，非常方便。这些加密算法实现类的父类是 <code>PasswordEncoder</code> ，如果你想要自己实现一个加密算法的话，也需要继承 <code>PasswordEncoder</code>。</p>
<p><code>PasswordEncoder</code> 接口一共也就 3 个必须实现的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PasswordEncoder</span> &#123;</span><br><span class="line">    <span class="comment">// 加密也就是对原始密码进行编码</span></span><br><span class="line">    String <span class="title function_">encode</span><span class="params">(CharSequence var1)</span>;</span><br><span class="line">    <span class="comment">// 比对原始密码和数据库中保存的密码</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(CharSequence var1, String var2)</span>;</span><br><span class="line">    <span class="comment">// 判断加密密码是否需要再次进行加密，默认返回 false</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">upgradeEncoding</span><span class="params">(String encodedPassword)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="4-如何优雅更换系统使用的加密算法"><a href="#4-如何优雅更换系统使用的加密算法" class="headerlink" title="4)如何优雅更换系统使用的加密算法"></a>4)如何优雅更换系统使用的加密算法</h5><p>如果我们在开发过程中，突然发现现有的加密算法无法满足我们的需求，需要更换成另外一个加密算法，这个时候应该怎么办呢？</p>
<p>推荐的做法是通过 <code>DelegatingPasswordEncoder</code> 兼容多种不同的密码加密方案，以适应不同的业务需求。</p>
<p>从名字也能看出来，<code>DelegatingPasswordEncoder</code> 其实就是一个代理类，并非是一种全新的加密算法，它做的事情就是代理上面提到的加密算法实现类。在 Spring Security 5.0 之后，默认就是基于 <code>DelegatingPasswordEncoder</code> 进行密码加密的。</p>
<p><strong>当一个 HTTP 请求到达 Spring 框架时，它会经历一系列的处理步骤。以下是详细的过程</strong>：</p>
<ol>
<li><p><strong>请求到达服务器</strong>：</p>
<ul>
<li>客户端发起一个 HTTP 请求，请求通过网络到达服务器。</li>
</ul>
</li>
<li><p><strong>DNS 解析</strong>：</p>
<ul>
<li>服务器接收到请求后，会根据请求的域名解析出对应的 IP 地址。</li>
</ul>
</li>
<li><p><strong>TCP 连接</strong>：</p>
<ul>
<li>服务器使用解析出的 IP 地址与客户端建立 TCP 连接。</li>
</ul>
</li>
<li><p><strong>发送 HTTP 请求</strong>：</p>
<ul>
<li>服务器接收到请求后，会解析请求头（Request Header），包括请求方法（GET、POST 等）、请求路径、请求参数等。</li>
</ul>
</li>
<li><p><strong>请求转发</strong>：</p>
<ul>
<li>如果请求需要被转发，服务器会将请求转发到相应的后端服务。</li>
</ul>
</li>
<li><p><strong>Spring 容器初始化</strong>：</p>
<ul>
<li>Spring 容器（ApplicationContext）根据配置文件（如 <code>application.properties</code> 或 <code>application.yml</code>）和类路径下的 Bean 定义文件（如 <code>spring.factories</code>）加载 Bean。</li>
</ul>
</li>
<li><p><strong>请求映射</strong>：</p>
<ul>
<li>Spring 容器中的 DispatcherServlet（或类似的组件，如 Spring MVC 的其他前端控制器）会根据请求的 URL 映射到相应的 Controller 方法。</li>
</ul>
</li>
<li><p><strong>执行 Controller 方法</strong>：</p>
<ul>
<li>DispatcherServlet 会调用相应的 Controller 方法，并将请求参数和上下文信息传递给该方法。</li>
</ul>
</li>
<li><p><strong>业务逻辑处理</strong>：</p>
<ul>
<li>在 Controller 方法中，业务逻辑会被执行。这可能包括访问数据库、调用其他服务、处理文件上传等。</li>
</ul>
</li>
<li><p><strong>响应构建</strong>：</p>
<ul>
<li>Controller 方法执行完毕后，会构建一个 HTTP 响应。这个响应包括响应头（Response Header）和响应体（Response Body）。</li>
</ul>
</li>
<li><p><strong>响应发送</strong>：</p>
<ul>
<li>DispatcherServlet 将构建好的 HTTP 响应发送回客户端。</li>
</ul>
</li>
<li><p><strong>TCP 连接关闭</strong>：</p>
<ul>
<li>服务器发送完响应后，关闭 TCP 连接。</li>
</ul>
</li>
<li><p><strong>客户端接收响应</strong>：</p>
<ul>
<li>客户端接收到响应后，根据响应头和响应体进行相应的处理。</li>
</ul>
</li>
</ol>
<p>###8、Bean是线程安全的吗？</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20241105205306388-1737881543400182.png" alt="image-20241105205306388" style="zoom:67%;" />







<h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a><font color=red>SpringMVC</font></h2><p>MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20210809181452421.png"></p>
<p>Spring MVC的核心组件：</p>
<p>记住了下面这些组件，也就记住了 SpringMVC 的工作原理。</p>
<ul>
<li><strong><code>DispatcherServlet</code><strong>：</strong>核心的中央处理器</strong>，负责接收请求、分发，并给予客户端响应。</li>
<li><strong><code>HandlerMapping</code><strong>：</strong>处理器映射器</strong>，根据 URL 去匹配查找能处理的 <code>Handler</code> ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</li>
<li><strong><code>HandlerAdapter</code><strong>：</strong>处理器适配器</strong>，根据 <code>HandlerMapping</code> 找到的 <code>Handler</code> ，适配执行对应的 <code>Handler</code>；</li>
<li><strong><code>Handler</code><strong>：</strong>请求处理器</strong>，处理实际请求的处理器。</li>
<li><strong><code>ViewResolver</code><strong>：</strong>视图解析器</strong>，根据 <code>Handler</code> 返回的逻辑视图 &#x2F; 视图，解析并渲染真正的视图，并传递给 <code>DispatcherServlet</code> 响应客户端</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/de6d2b213f112297298f3e223bf08f28.png"></p>
<p><strong>流程说明（重要）：</strong></p>
<ol>
<li>客户端（浏览器）发送请求， <code>DispatcherServlet</code>拦截请求。</li>
<li><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code> 。<code>HandlerMapping</code> 根据 URL 去匹配查找能处理的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器） ，并会将<strong>请求涉及到的拦截器和 <code>Handler</code> 一起封装。</strong></li>
<li><code>DispatcherServlet</code> 调用 <code>HandlerAdapter</code>适配器执行 <code>Handler</code> 。</li>
<li><code>Handler</code> 完成对用户请求的处理后，会返回一个 <code>ModelAndView</code> 对象给<code>DispatcherServlet</code>，<code>ModelAndView</code> 顾名思义，包含了数据模型以及相应的视图的信息。<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</li>
<li><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</li>
<li><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</li>
<li>把 <code>View</code> 返回给请求者（浏览器)</li>
</ol>
<p>统一异常处理怎么做？</p>
<p><strong>推荐使用注解的方式统一异常处理</strong>，具体会使用到 <code>@ControllerAdvice</code> + <code>@ExceptionHandler</code> 这两个注解 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(BaseException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;?&gt; handleAppException(BaseException ex, HttpServletRequest request) &#123;</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = ResourceNotFoundException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;ErrorReponse&gt; <span class="title function_">handleResourceNotFoundException</span><span class="params">(ResourceNotFoundException ex, HttpServletRequest request)</span> &#123;</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这种异常处理方式下，会给所有或者指定的 <code>Controller</code> 织入异常处理的逻辑（AOP），当 <code>Controller</code> 中的方法抛出异常的时候，由被<code>@ExceptionHandler</code> 注解修饰的方法进行处理。</p>
<p><code>ExceptionHandlerMethodResolver</code> 中 <code>getMappedMethod</code> 方法决定了异常具体被哪个 <code>@ExceptionHandler</code> 注解修饰的方法处理异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">  <span class="keyword">private</span> Method <span class="title function_">getMappedMethod</span><span class="params">(Class&lt;? extends Throwable&gt; exceptionType)</span> &#123;</span><br><span class="line">    List&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt;&gt; matches = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//找到可以处理的所有异常信息。mappedMethods 中存放了异常和处理异常的方法的对应关系</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;? <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt; mappedException : <span class="built_in">this</span>.mappedMethods.keySet()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mappedException.isAssignableFrom(exceptionType)) &#123;</span><br><span class="line">        matches.add(mappedException);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不为空说明有方法处理异常</span></span><br><span class="line">    <span class="keyword">if</span> (!matches.isEmpty()) &#123;</span><br><span class="line">      <span class="comment">// 按照匹配程度从小到大排序</span></span><br><span class="line">      matches.sort(<span class="keyword">new</span> <span class="title class_">ExceptionDepthComparator</span>(exceptionType));</span><br><span class="line">      <span class="comment">// 返回处理异常的方法</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.mappedMethods.get(matches.get(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从源代码看出：**<code>getMappedMethod()</code>会首先找到可以匹配处理异常的所有方法信息，然后对其进行从小到大的排序，最后取最小的那一个匹配的方法(即匹配度最高的那个)。**</p>
<h2 id="1）-对SpringMVC的理解"><a href="#1）-对SpringMVC的理解" class="headerlink" title="1）*对SpringMVC的理解"></a>1）<font color='red'>*</font>对SpringMVC的理解</h2><p>1、把传统MVC框架里前的Controller控制器做了拆分，分成了前端控制器Dispatcherservlet和后端控制器Controller</p>
<p>2、把Model模型拆分成业务层Service和数据访问层Repository</p>
<p>3、在视图层，可以以支持不同的视图品如Freemark、velocity、JSP等等</p>
<h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><h2 id="1）-和-的区别是什么？"><a href="#1）-和-的区别是什么？" class="headerlink" title="1）#{}和${}的区别是什么？"></a>1）#{}和${}的区别是什么？</h2><p>${} 是字符串拼接，通过${}可以将<strong>传入的内容拼接在sql中且不进行jdbc类型转换</strong>。</p>
<p>#{} 是占位符，相当于<strong>PreparedStatement使用占位符去替换参数，自动进行java类型和jdbc类型转换，可以防止sql注入</strong>。</p>
<p>所以**${}字符串拼接可以拼接表名执行sql语句，但 #{}占位符只能站位参数，而不是站位表名，所以不可以执行sql语句。**</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/JOB-md.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1cnVhbnNodW4=,size_16,color_FFFFFF,t_70.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/JOB-md.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1cnVhbnNodW4=,size_16,color_FFFFFF,t_70-17378815432781.png"></p>
<h2 id="2）xml-映射文件中，除了常见的-select、insert、update、delete-标签之外，还有哪些标签"><a href="#2）xml-映射文件中，除了常见的-select、insert、update、delete-标签之外，还有哪些标签" class="headerlink" title="2）xml 映射文件中，除了常见的 select、insert、update、delete 标签之外，还有哪些标签?"></a>2）xml 映射文件中，除了常见的 select、insert、update、delete 标签之外，还有哪些标签?</h2><p>还有很多其他的标签，**&lt;resultMap&gt;、 &lt;parameterMap&gt;、&lt;sql&gt;、&lt;include&gt;<strong>、&lt;selectKey&gt;，加上动态 sql的9个标签，</strong>trim|where|set|foreach|if|choose|when|otherwise|bind **等，其中&lt;sql&gt;为sql片段标签，通过&lt;include&gt;标签引入sql片段，&lt;selectkey〉为不支持自增的主键生成策略标签。</p>
<p>##3）Dao 接口的工作原理是什么?Dao 接口里的方法，参数不同时，方法能重载吗?</p>
<p>答：最佳实践中，<strong>通常一个 xml 映射文件，都会写一个 Dao 接口与之对应。Dao 接口就是常说的 <code>Mapper</code> 接口</strong>，接口的全限名，就是映射文件中的 namespace 的值，接口的方法名，就是映射文件中 <code>MappedStatement</code> 的 id 值，接口方法内的参数，就是传递给 sql 的参数。 <code>Mapper</code> 接口是没有实现类的，<strong>当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个 <code>MappedStatement</code></strong> 。</p>
<p>举例：<code>com.mybatis3.mappers. StudentDao.findStudentById</code> ，可以唯一找到 namespace 为 <code>com.mybatis3.mappers. StudentDao</code> 下面 <code>id = findStudentById</code> 的 <code>MappedStatement</code> 。在 MyBatis 中，每一个 <code>&lt;select&gt;</code>、 <code>&lt;insert&gt;</code>、 <code>&lt;update&gt;</code>、 <code>&lt;delete&gt;</code> 标签，都会被解析为一个 <code>MappedStatement</code> 对象</p>
<p><strong>Dao 接口里的方法可以重载，但是 Mybatis 的 xml 里面的 ID 不允许重复。</strong></p>
<p><strong>Mybatis 的 Dao 接口可以有多个重载方法，但是多个接口对应的映射必须只有一个，否则启动会报错。</strong></p>
<p>Dao 接口的工作原理是 JDK 动态代理，MyBatis 运行时会使用 JDK 动态代理为 Dao 接口生成代理 proxy 对象，代理对象 proxy 会拦截接口方法，转而执行 <code>MappedStatement</code> 所代表的 sql，然后将 sql 执行结果返回。</p>
<p>Dao 接口方法可以重载，但是需要满足以下条件：</p>
<ol>
<li>仅有一个无参方法和一个有参方法</li>
<li>多个有参方法时，参数数量必须一致。且使用相同的 <code>@Param</code> ，或者使用 <code>param1</code> 这种</li>
</ol>
<h2 id="4）MyBatis-是如何进行分页的？分页插件的原理是什么？"><a href="#4）MyBatis-是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="4）MyBatis 是如何进行分页的？分页插件的原理是什么？"></a>4）MyBatis 是如何进行分页的？分页插件的原理是什么？</h2><p>答：**(1)** <strong>MyBatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页</strong>，而非物理分页；</p>
<p>​        <strong>(2)</strong> <strong>可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能；</strong></p>
<p>​        <strong>(3)</strong> <strong>也可以使用分页插件来完成物理分页。</strong></p>
<p>分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql，根据select语句，添加对应的物理分页语句和物理分页参数。</p>
<p>举例：<code>select _ from student</code> ，拦截 sql 后重写为：<code>select t._ from （select \* from student）t limit 0，10</code></p>
<h2 id="5）简述-MyBatis-的插件运行原理，以及如何编写一个插件"><a href="#5）简述-MyBatis-的插件运行原理，以及如何编写一个插件" class="headerlink" title="5）简述 MyBatis 的插件运行原理，以及如何编写一个插件**"></a>5）简述 MyBatis 的插件运行原理，以及如何编写一个插件**</h2><p>答：MyBatis 仅可以编写针对 <code>ParameterHandler</code>、 <code>ResultSetHandler</code>、 <code>StatementHandler</code>、 <code>Executor</code> 这 4 种接口的插件，MyBatis 使用 JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 <code>InvocationHandler</code> 的 <code>invoke()</code> 方法，当然，只会拦截那些你指定需要拦截的方法。</p>
<p>实现 MyBatis 的 <code>Interceptor</code> 接口并复写 <code>intercept()</code> 方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</p>
<h2 id="6）MyBatis-执行批量插入，能返回数据库主键列表吗？"><a href="#6）MyBatis-执行批量插入，能返回数据库主键列表吗？" class="headerlink" title="6）MyBatis 执行批量插入，能返回数据库主键列表吗？"></a>6）MyBatis 执行批量插入，能返回数据库主键列表吗？</h2><p>答：能，JDBC 都能，MyBatis 当然也能。</p>
<h2 id="7）MyBatis-动态-sql-是做什么的？都有哪些动态-sql？能简述一下动态-sql-的执行原理不？"><a href="#7）MyBatis-动态-sql-是做什么的？都有哪些动态-sql？能简述一下动态-sql-的执行原理不？" class="headerlink" title="7）MyBatis 动态 sql 是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？"></a>7）MyBatis 动态 sql 是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？</h2><p>MyBatis 动态 sql 可以让我们在 xml 映射文件内，以标签的形式编写动态 sql，完成逻辑判断和动态拼接 sql 的功能。其执行原理为，使用 <strong>OGNL 从 sql 参数对象中计算表达式的值，根据表达式的值动态拼接 sql，以此来完成动态 sql 的功能</strong>。</p>
<p>MyBatis 提供了 9 种动态 sql 标签:</p>
<ul>
<li><code>&lt;if&gt;&lt;/if&gt;</code></li>
<li><code>&lt;where&gt;&lt;/where&gt;(trim,set)</code></li>
<li><code>&lt;choose&gt;&lt;/choose&gt;（when, otherwise）</code></li>
<li><code>&lt;foreach&gt;&lt;/foreach&gt;</code></li>
<li><code>&lt;bind/&gt;</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000039335704">Mybatis 系列全解（八）：Mybatis 的 9 大动态 SQL 标签你知道几个？</a></p>
<h2 id="8）MyBatis-是如何将-sql-执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#8）MyBatis-是如何将-sql-执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="8）MyBatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>8）MyBatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？</h2><p>第一种是使用 <strong><code>&lt;resultMap&gt;</code> 标签，逐一定义列名和对象属性名之间的映射关系</strong>。</p>
<p>第二种是使用 <strong>sql 列的别名功能，将列别名书写为对象属性名</strong>，比如 T_NAME AS NAME，对象属性名一般是 name，小写，但是列名不区分大小写，MyBatis 会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成 T_NAME AS NaMe，MyBatis 一样可以正常工作。</p>
<p><strong>有了列名与属性名的映射关系后，MyBatis 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回</strong>，那些找不到映射关系的属性，是无法完成赋值的。</p>
<h2 id="9）MyBatis-能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别"><a href="#9）MyBatis-能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别" class="headerlink" title="9）MyBatis 能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别"></a>9）MyBatis 能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别</h2><p>能，MyBatis 不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，</p>
<p>多对一查询，其实就是一对一查询</p>
<ul>
<li>多种方式，常见的包括三种：<ul>
<li>第一种方式：<strong>一条SQL语句，级联属性映射。</strong></li>
<li>第二种方式：<strong>一条SQL语句，association。</strong></li>
<li>第三种方式：<strong>两条SQL语句，分步查询。（这种方式常用：优点一是可复用。优点二是支持懒加载。）</strong></li>
</ul>
</li>
</ul>
<p>多对多查询，其实就是一对多查询。一对多的实现通常包括两种实现方式：</p>
<ul>
<li>第一种方式：<strong>collection</strong></li>
<li>第二种方式：<strong>分步查询</strong></li>
</ul>
<h2 id="10）MyBatis-是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#10）MyBatis-是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="10）MyBatis 是否支持延迟加载？如果支持，它的实现原理是什么？"></a>10）MyBatis 是否支持延迟加载？如果支持，它的实现原理是什么？</h2><p>MyBatis 仅支持 <strong>association 关联对象和 collection 关联集合对象</strong>的延迟加载，association 指的就是一对一&#x2F;多对一，collection 指的就是一对多查询。在 MyBatis 配置文件中，可以配置是否启用延迟加载 <code>lazyLoadingEnabled=true|false</code></p>
<p>它的原理是，使用 <code>CGLIB</code> 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如<strong>调用 <code>a.getB().getName()</code> ，拦截器 <code>invoke()</code> 方法发现 <code>a.getB()</code> 是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 <code>a.getB().getName()</code> 方法的调用</strong>。这就是延迟加载的基本原理。</p>
<p>当然了，不光是 MyBatis，几乎所有的包括 Hibernate，支持延迟加载的原理都是一样的。</p>
<h2 id="11）MyBatis-的-xml-映射文件中，不同的-xml-映射文件，id-是否可以重复？"><a href="#11）MyBatis-的-xml-映射文件中，不同的-xml-映射文件，id-是否可以重复？" class="headerlink" title="11）MyBatis 的 xml 映射文件中，不同的 xml 映射文件，id 是否可以重复？"></a>11）MyBatis 的 xml 映射文件中，不同的 xml 映射文件，id 是否可以重复？</h2><p>不同的 xml 映射文件，<strong>如果配置了 namespace，那么 id 可以重复；如果没有配置 namespace，那么 id 不能重复，</strong>毕竟 namespace 不是必须的，只是最佳实践而已。 </p>
<p>原因就是 <strong>namespace+id 是作为 <code>Map&lt;String, MappedStatement&gt;</code> 的 key 使用的，如果没有 namespace，就剩下 id，那么，id 重复会导致数据互相覆盖。</strong>有了 namespace，自然 id 就可以重复，namespace 不同，namespace+id 自然也就不同。</p>
<h2 id="12）MyBatis-中如何执行批处理？"><a href="#12）MyBatis-中如何执行批处理？" class="headerlink" title="12）MyBatis 中如何执行批处理？"></a>12）MyBatis 中如何执行批处理？</h2><p>答：使用 <strong>BatchExecutor</strong> 完成批处理。</p>
<h2 id="13）MyBatis-都有哪些-Executor-执行器？它们之间的区别是什么？"><a href="#13）MyBatis-都有哪些-Executor-执行器？它们之间的区别是什么？" class="headerlink" title="13）MyBatis 都有哪些 Executor 执行器？它们之间的区别是什么？"></a>13）MyBatis 都有哪些 Executor 执行器？它们之间的区别是什么？</h2><p>MyBatis 有三种基本的 <code>Executor</code> 执行器：</p>
<ul>
<li><strong><code>SimpleExecutor</code>(默认)：</strong> 每执行一次 update 或 select，就开启一个 Statement 对象，用完立刻关闭 Statement 对象。</li>
<li><strong><code>ReuseExecutor</code>：</strong> 执行 <strong>update 或 select，以 sql 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后，不关闭 Statement 对象，而是放置于 Map&lt;String, Statement&gt;内，供下一次使用。</strong>简言之，就是重复使用 Statement 对象。</li>
<li><strong><code>BatchExecutor</code><strong>：执行 update（没有 select，JDBC 批处理不支持 select），将所有 sql 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它</strong>缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理</strong>。与 JDBC 批处理相同。</li>
</ul>
<p>作用范围：<code>Executor</code> 的这些特点，都<strong>严格限制在 SqlSession 生命周期范围内</strong>。</p>
<h2 id="14）MyBatis-中如何指定使用哪一种-Executor-执行器？"><a href="#14）MyBatis-中如何指定使用哪一种-Executor-执行器？" class="headerlink" title="14）MyBatis 中如何指定使用哪一种 Executor 执行器？"></a>14）MyBatis 中如何指定使用哪一种 Executor 执行器？</h2><p>答：在 MyBatis 配置文件中，可以指定默认的 <strong><code>ExecutorType</code> 执行器类型</strong>，也可以手动给 <code>DefaultSqlSessionFactory</code> 的创建 SqlSession 的方法传递 <code>ExecutorType</code> 类型参数。</p>
<h2 id="14-谈谈你对SqlsessionFactory的理解"><a href="#14-谈谈你对SqlsessionFactory的理解" class="headerlink" title="14) 谈谈你对SqlsessionFactory的理解"></a>14) 谈谈你对SqlsessionFactory的理解</h2><p>它是个单个数据库映射关系经过编译后的内存镜像。</p>
<p>SqlSessionFactory对象的实例可以通过SqlSessionFactoryBuilder对象类获得，而<strong>SqlSessionFactoryBuilder则可以从XML配置文件或一个预先定制的Configuration的实例构建出SqlSessionFactory的实例</strong>。每一个MyBatis的应用程序都以一个SqlSessionFactory对象的实例为核心。</p>
<p>同时<strong>SqlSessionFactory也是线程安全的,SqlSessionFactory一旦被创建,应该在应用执行期间都存在。在应用运行期间不要重复创建多次，建议使用单例模式。SqlSessionFactory是创建SqlSession的工厂</strong>。</p>
<h2 id="15）谈谈你对SqiSession的理解"><a href="#15）谈谈你对SqiSession的理解" class="headerlink" title="15）谈谈你对SqiSession的理解"></a>15）谈谈你对SqiSession的理解</h2><p>SqlSession是mybatis中非常核心的一个API：作用是通过<strong>相关API来实现对应的数据库数据的操作</strong>。</p>
<p>SqlSession对象的获取需要通过<strong>SqlSessionFactory</strong>来实现。</p>
<p><strong>是一个会话级别的</strong>。</p>
<p><strong>当一个新的会话到来时，我们需要新建一个SqlSession对象来处理。当一个会话结束后我们需要关闭相关的会话资源。</strong>处理请求的方式：</p>
<ul>
<li>通过相关的增删改查的API来处理</li>
<li>可以通过getMapper（XXX.class）来获取相关的Mapper接口的代理对象来处理</li>
</ul>
<h2 id="16）MyBatis-是否可以映射-Enum-枚举类？"><a href="#16）MyBatis-是否可以映射-Enum-枚举类？" class="headerlink" title="16）MyBatis 是否可以映射 Enum 枚举类？"></a>16）MyBatis 是否可以映射 Enum 枚举类？</h2><p>答：<strong>MyBatis 可以映射枚举类，不单可以映射枚举类，MyBatis 可以映射任何对象到表的一列上</strong>。</p>
<p>映射方式为自定义一个 <strong><code>TypeHandler</code></strong> ，实现**<code>TypeHandler</code> 的 <code>setParameter()</code> 和 <code>getResult()</code>** 接口方法。 <code>TypeHandler</code>有两个作用：</p>
<ul>
<li>一是完成从 javaType 至 jdbcType 的转换；</li>
<li>二是完成 jdbcType 至 javaType 的转换，体现为 <code>setParameter()</code> 和 <code>getResult()</code> 两个方法，分别代表设置<strong>sql 问号占位符参数和获取列查询</strong>结果。</li>
</ul>
<h2 id="17）MyBatis-映射文件中，如果-A-标签通过-include-引用了-B-标签的内容，请问，B-标签能否定义在-A-标签的后面，还是说必须定义在-A-标签的前面？"><a href="#17）MyBatis-映射文件中，如果-A-标签通过-include-引用了-B-标签的内容，请问，B-标签能否定义在-A-标签的后面，还是说必须定义在-A-标签的前面？" class="headerlink" title="17）MyBatis 映射文件中，如果 A 标签通过 include 引用了 B 标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在 A 标签的前面？"></a>17）MyBatis 映射文件中，如果 A 标签通过 include 引用了 B 标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在 A 标签的前面？</h2><p><strong>虽然 MyBatis 解析 xml 映射文件是按照顺序解析的，但是，被引用的 B 标签依然可以定义在任何地方，MyBatis 都可以正确识别。</strong></p>
<p>原理是，MyBatis 解析 A 标签，发现 A 标签引用了 B 标签，但是 B 标签尚未解析到，尚不存在，此时，MyBatis 会<strong>将 A 标签标记为未解析状态</strong>，然后继续解析余下的标签，包含 B 标签，待所有标签解析完毕，<strong>MyBatis 会重新解析那些被标记为未解析的标签</strong>，此时再解析 A 标签时，B 标签已经存在，A 标签也就可以正常解析完成了。</p>
<h2 id="18）简述-MyBatis-的-xml-映射文件和-MyBatis-内部数据结构之间的映射关系？"><a href="#18）简述-MyBatis-的-xml-映射文件和-MyBatis-内部数据结构之间的映射关系？" class="headerlink" title="18）简述 MyBatis 的 xml 映射文件和 MyBatis 内部数据结构之间的映射关系？"></a>18）简述 MyBatis 的 xml 映射文件和 MyBatis 内部数据结构之间的映射关系？</h2><p>答：<strong>MyBatis 将所有 xml 配置信息都封装到 All-In-One 重量级对象 Configuration 内部</strong>。</p>
<p>在 xml 映射文件中， <code>&lt;parameterMap&gt;</code> 标签会被解析为 <strong><code>ParameterMap</code></strong> 对象，其每个子元素会被解析为 <strong>ParameterMapping</strong> 对象。 </p>
<p><code>&lt;resultMap&gt;</code> 标签会被解析为 <strong><code>ResultMap</code></strong> 对象，其每个子元素会被解析为 <strong><code>ResultMapping</code></strong> 对象。</p>
<p>每一个 <code>&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;</code> 标签均会被解析为 **<code>MappedStatement</code>**对象，标签内的 sql 会被解析为 **BoundSql **对象。</p>
<p>##19）为什么说 MyBatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？</p>
<p>答：</p>
<p>Hibernate 属于全自动 ORM 映射工具，使用 Hibernate <strong>查询关联对象或者关联集合对象</strong>时，可以根据<strong>对象关系模型</strong>直接获取，所以它是全自动的。</p>
<p>而 MyBatis 在<strong>查询关联对象或关联集合对象</strong>时，需要**手动编写 sql **来完成，所以，称之为半自动 ORM 映射工具。</p>
<h2 id="20）Mybatis的一级、二级缓存，何时使用？有什么缺点？"><a href="#20）Mybatis的一级、二级缓存，何时使用？有什么缺点？" class="headerlink" title="20）Mybatis的一级、二级缓存，何时使用？有什么缺点？"></a>20）<font color="red">Mybatis的一级、二级缓存，何时使用？有什么缺点？</font></h2><p><strong>二级缓存：</strong>mybatis默认是没有开启二级缓存的，二级缓存需要我们手动开启，它是mapper级别的缓存；</p>
<p>使用的是<code>CachingExecutor</code>对象，它是对<code>Executor</code>的一个封装，在一级缓存之前，会先进行二级缓存查询。二级缓存被多个SqlSesion共享，是一个全局缓存。</p>
<p><strong>二级缓存是建立在同一个namespace下的，如果对某一个表的操作查询可能有多个namespace</strong>，那么会得到脏数据。</p>
<p><strong>一级缓存：</strong>一级缓存是默认开启的；不同sqlsession之间缓存互不影响。</p>
<p>在sqlsession里面有个Executor对象，每个Executor对象都会有一个LocalCache的一个对象，用户发起查询时，Mybatis根据查询语句去Local Cache里面去查询，如果没有命中的话，再去查询数据库，并且写入到Local Cache里面，否则直接返回。如果在多个sqlsession或者分布式环境下，会出现脏数据（数据一致性问题）。</p>
<p>———&gt;&gt;&gt;当多个SQL会话同时操作数据库时，可能会出现脏数据的问题。这是因为每个会话都有自己的缓存，如果某个会话更新了数据库中的数据，其他会话的缓存可能仍然包含旧的数据。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240522174956355-1737881543400183.png" alt="image-20240522174956355" style="zoom: 67%;" />

<p><strong>改进？</strong></p>
<p>统一使用第三方插件来做缓存，如redis，mamcache等，<br>关闭mybatis的一级缓存和二级缓存，<br>mybatis仅仅只限于orm框架，数据库和对象的映射，以及操作sql。</p>
<p>##21）执行流程</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20241106110349717-1737881543400184.png" alt="image-20241106110349717" style="zoom: 67%;" />







<h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><h2 id="1-Spring-Boot-有哪些特点？"><a href="#1-Spring-Boot-有哪些特点？" class="headerlink" title="1. Spring Boot 有哪些特点？"></a><strong>1. Spring Boot 有哪些特点？</strong></h2><ul>
<li><strong>自动配置</strong></li>
</ul>
<p>这是 Spring Boot 最重要的特性。这极大地消除了手动配置。基础框架附带了一个名为 auto-configure 的内置库，它为我们完成了这项工作。它检测某些类的存在以及类路径上的存在，并为我们自动配置它们。</p>
<p>例如：— 当我们在项目中添加spring-boot-starter-web依赖项时，Spring Boot 自动配置会查找 Spring MVC 是否在类路径中。它自动配置dispatcherServlet、默认错误页面和web jars。— 同样，当我们添加spring-boot-starter-data-jpa依赖项时，我们会看到 Spring Boot 自动配置，自动配置一个数据源和一个实体管理器。</p>
<ul>
<li><strong>嵌入式 Tomcat Web 服务器</strong></li>
</ul>
<p>Spring Boot 默认随 Tomcat 服务器一起提供。因此，我们不需要配置服务器来运行应用程序（如果我们的首选服务器是 Tomcat）。</p>
<ul>
<li><strong>入门 POM</strong></li>
</ul>
<p>Spring Boot 本身提供了许多启动 POM 来完成开发生活中最常见的任务。我们可以依赖它们和框架本身，而不需要去第三方库。</p>
<h2 id="2、“-SpringBootApplication”注解在内部是如何工作的"><a href="#2、“-SpringBootApplication”注解在内部是如何工作的" class="headerlink" title="2、“@SpringBootApplication”注解在内部是如何工作的"></a><strong>2、“@SpringBootApplication”注解在内部是如何工作的</strong></h2><p>启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：</p>
<ul>
<li><ul>
<li><strong>@SpringBootConfiguration</strong>：组合了 @Configuration 注解，实现配置文件的功能。</li>
<li><strong>@EnableAutoConfiguration</strong>：打开自动配置的功能，也可以关闭某个自动配置的选项， 例如：java 如关闭数据源自动配置功能： @SpringBootApplication(exclude &#x3D; { DataSourceAutoConfiguration.class })。</li>
<li><strong>@ComponentScan</strong>：Spring组件扫描。</li>
</ul>
</li>
</ul>
<h2 id="3-什么是-Bean？"><a href="#3-什么是-Bean？" class="headerlink" title="3. 什么是 Bean？"></a><strong>3. 什么是 Bean？</strong></h2><p>Bean 只是普通的 Java 对象。在 Spring Boot 上下文中，它们被视为 Java 对象 + 在应用程序启动时自动初始化并由 Spring IOC 容器管理的对象。我们有“@Bean”注解来实现这一点。</p>
<p>##<font color=red><strong>4、 什么是Spring中的控制反转（IOC）？</strong></font></p>
<p>##<strong>5、我们如何在Spring Boot中实现依赖注入？</strong></p>
<p>将对象作为依赖项传递给另一个对象</p>
<p>在 Spring Boot 中，我们可以使用“@Autowired”注解来实现这一点。然后 Spring IOC 容器将代表我们创建对象。通常，在控制器层我们注入服务，在服务层我们注入存储库来使用这个注解。</p>
<p>##<strong>6、Spring Boot微服务有哪些层？</strong></p>
<p>​		控制器层：所有具有 API 端点定义方法的控制器。类使用“@RestController”注解进行注解。<br>​		Repository&#x2F;DAO层：所有repository接口都包含在这一层中，用于查询已选择的数据库（SQL&#x2F;no SQL）。接口使用“@Repository”注解进行注解。<br>​		服务层：所有业务逻辑都包含在这里。通常在该层访问DAO层以执行一些操作。类使用“@Service”注解进行注解。<br>​		实体层：映射到现实世界的所有类都包含在该层中。通常所有与 ORM 相关的注释都放在这些类中。— 如果它与 MySQL 连接，我们用“@Entity”注释表名。— 如果它连接到 MongoDB，我们用“@Document”注释集合名称<br>此外，我们可以使用 Lombok 之类的库在此处定义 getter 和 setter。</p>
<h2 id="7、-如何使用-Spring-Boot-连接数据库？"><a href="#7、-如何使用-Spring-Boot-连接数据库？" class="headerlink" title="7、 如何使用 Spring Boot 连接数据库？"></a>7、 <strong>如何使用 Spring Boot 连接数据库？</strong></h2><p>通常我们不需要创建单例数据库类、连接池方法和任何其他实现。SpringBoot AutoConfiguration 将为我们完成所有这些类和配置设置。只需要设置。</p>
<p>将数据库（MySQL&#x2F;MongoDB&#x2F;Redis）的启动器依赖项添加到 POM。<br>在 application.properties&#x2F;yml 文件中定义配置 - 例如：数据库 URL 和凭据</p>
<p>##8、<strong>如何在DAO层编写自定义查询？</strong></p>
<p>##9、<strong>Spring Boot 中如何处理事务？使用的任何注释？</strong></p>
<p>Spring Boot 提供了一个名为“@Transactional”的注解来管理事务。</p>
<p>##10、<strong>我们需要在哪里使用“@Qualifier”注解？</strong></p>
<p>此注解用于专门告诉 Spring Boot 从其所有可用实现 bean 中获取特定类。@Qualifier注解与“ @Autowired”注解一起用于依赖注入。</p>
<p>显示指定注入那个实现类</p>
<p>##11、<strong>Spring Boot项目中可以替换Tomcat服务器吗？</strong></p>
<p>是的。如果需要，我们可以通过在 POM 中添加 maven 排除来删除 Tomcat 服务器。实际上，Web 服务器捆绑在started-web Spring Boot starter 依赖项中。应该添加排除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt; </span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; </span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; </span><br><span class="line">  &lt;exclusions&gt; </span><br><span class="line">    &lt;exclusion&gt; </span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; </span><br><span class="line">      &lt;artifactId&gt; spring-boot-starter-tomcat&lt;/artifactId&gt; </span><br><span class="line">    &lt;/exclusion&gt; </span><br><span class="line">  &lt;/exclusions&gt; </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;/dependency&gt;&lt;dependency&gt; </span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; </span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; <span class="comment">//添加jetty服务器</span></span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>##12、<strong>“@PathVariable”和“@RequestParam”有什么区别？</strong></p>
<p>PathVariable - 当我们设置 API 端点时使用以“&#x2F;”分隔的参数。restful风格</p>
<p>RequestParam - 当我们设置 API 端点时使用，查询参数以“&amp;”分隔并以“？”开头。</p>
<p>##13、<strong>“@Primary”注解有什么用？</strong></p>
<p>@Primary表示当多个候选者有资格自动连接单值依赖项时，应优先考虑 bean。</p>
<p>##14、<strong>如何验证传入的请求并将错误通知给用户</strong>?</p>
<p>将启动器验证依赖项添加到 POM 中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt; </span><br><span class="line">   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; </span><br><span class="line">   &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt; </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>在“RequestBody”注解前添加“@Valid”注解。</p>
<p>为要显示验证约束消息的请求创建单独的 DTO。</p>
<p>使用“@RestControllerAdvice”创建全局异常处理程序，并在单独的方法中处理<br>MethodArgumentNotValidException 。</p>
<p>创建逻辑以根据需要将错误返回给最终用户。我们可以在这个 logic.es 中提取异常消息</p>
<p>##15、<strong>什么是Spring Boot Actuator？</strong></p>
<p>简单地说，Spring Boot 框架的一个子项目，它使用 HTTP 端点来公开有关任何正在运行的应用程序的操作信息。</p>
<p>这些信息包括应用程序指标、连接的数据库状态、应用程序状态、bean 信息、请求跟踪等。</p>
<p>它可作为启动器依赖项使用。我们可以通过安装以下依赖项来使用该库。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt; </span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; </span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>##16、<strong>Spring Boot微服务中的异常如何处理？</strong></p>
<p>我们需要一个全局配置类，为每个异常类预定义异常处理方法。我们也可以使用处理程序本身定义返回的 HTTP 状态代码。</p>
<ul>
<li><p>使用“@RestControllerAdvice”创建一个全局异常处理程序，并在单独的方法中处理每个异常。</p>
</li>
<li><p>创建逻辑以根据需要将错误返回给最终用户。我们可以在这个逻辑中提取异常消息</p>
</li>
</ul>
<p>##17、<strong>“@Entity”和“@Table”注解有什么区别？</strong></p>
<p>@Entity实体表示将在程序中使用的类，@Table表示将通过程序访问的实际数据库表。</p>
<p>##18、讲讲SpringBoot的启动过程</p>
<ol>
<li><p><strong>启动类和@SpringBootApplication注解</strong>：</p>
<ul>
<li>首先，Spring Boot 应用程序有一个启动类，该类包含了一个 main 方法。</li>
<li>在启动类上，通常会使用 <code>@SpringBootApplication</code> 注解。这个注解是一个组合注解，它整合了 <code>@Configuration</code>、<code>@EnableAutoConfiguration</code> 和 <code>@ComponentScan</code>。</li>
</ul>
</li>
<li><p><strong>执行 SpringApplication.run() 方法</strong>：</p>
<ul>
<li>在 main 方法中，通过调用 <code>SpringApplication.run()</code> 方法来启动 Spring Boot 应用程序。</li>
</ul>
</li>
<li><p><strong>创建 SpringApplication 实例</strong>：</p>
<ul>
<li><code>SpringApplication</code> 类负责启动 Spring 应用程序。在调用 <code>run</code> 方法之前，会创建一个 <code>SpringApplication</code> 实例。</li>
<li>在这个过程中，会进行一些初始化操作，比如确定应用程序的类型（REACTIVE、SERVLET 等）。</li>
</ul>
</li>
<li><p><strong>准备环境（Environment）</strong>：</p>
<ul>
<li>Spring Boot 会配置和准备应用程序运行的环境，这包括创建 <code>Environment</code> 对象，该对象包含了各种属性源，比如系统属性、环境变量、application.properties 或 application.yml 文件中的属性。</li>
</ul>
</li>
<li><p><strong>创建ApplicationContext</strong>：</p>
<ul>
<li>根据 <code>SpringApplication</code> 实例中的信息，创建相应的 <code>ApplicationContext</code>（类型可能是 <code>AnnotationConfigServletWebServerApplicationContext</code>、<code>AnnotationConfigReactiveWebServerApplicationContext</code> 等）。</li>
<li><code>ApplicationContext</code> 是 Spring 的核心概念，负责应用程序的创建、配置和管理。</li>
</ul>
</li>
<li><p><strong>执行 Initializers</strong>：</p>
<ul>
<li>调用 <code>ApplicationContextInitializer</code> 的 <code>initialize</code> 方法，这些初始化器是在创建 <code>ApplicationContext</code> 之前用来执行一些初始化操作的。</li>
</ul>
</li>
<li><p><strong>执行 Listeners</strong>：</p>
<ul>
<li>在 <code>ApplicationContext</code> 准备好之后，但是创建任何 beans 之前，会通知 <code>ApplicationListener</code> 事件。</li>
</ul>
</li>
<li><p><strong>刷新 ApplicationContext</strong>：</p>
<ul>
<li>调用 <code>ApplicationContext</code> 的 <code>refresh</code> 方法，这个步骤是 Spring 容器启动的核心。</li>
<li>在这个阶段，Spring Boot 会加载所有单例 beans，并执行相关的生命周期回调。</li>
</ul>
</li>
<li><p><strong>调用 CommandLineRunner 和 ApplicationRunner</strong>：</p>
<ul>
<li>如果定义了任何 <code>CommandLineRunner</code> 或 <code>ApplicationRunner</code> beans，Spring Boot 将在这里调用它们。</li>
<li>这通常用于在应用程序启动后执行一些特定的代码。</li>
</ul>
</li>
<li><p><strong>启动 Web Server</strong>（如果有的话）：</p>
<ul>
<li>如果应用程序是一个 Web 应用，Spring Boot 会启动嵌入的 Web 服务器（比如 Tomcat、Jetty 或 Undertow）。</li>
</ul>
</li>
</ol>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1cr4y1671t/?vd_source=03235a8277a4e1950048927a7c975e38">https://www.bilibili.com/video/BV1cr4y1671t/?vd_source=03235a8277a4e1950048927a7c975e38</a></p>
<p>配合：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1cr4y1671t/?vd_source=03235a8277a4e1950048927a7c975e38">https://www.bilibili.com/video/BV1cr4y1671t/?vd_source=03235a8277a4e1950048927a7c975e38</a></p>
<p>E:\java\mybatis\respository\org\apache\maven\maven-model-builder\3.1.0222</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240508193113664-1737881543401185.png" alt="image-20240508193113664"></p>
<h2 id="1、什么是-Redis？Redis-有哪些特点？Redis-有哪些常⻅的应⽤场景？"><a href="#1、什么是-Redis？Redis-有哪些特点？Redis-有哪些常⻅的应⽤场景？" class="headerlink" title="1、什么是 Redis？Redis 有哪些特点？Redis 有哪些常⻅的应⽤场景？"></a>1、什么是 Redis？Redis 有哪些特点？Redis 有哪些常⻅的应⽤场景？</h2><p>Redis 是基于内存的键值型（key - value）的 NoSQL 数据库（⾮关系型数据库）。key ⼀般是 String 类型，⽽  value ⽀持丰富的数据类型，包括<strong>String、Hash、List、Set、SortedSet</strong> 这五种基本类型，此外还有 <strong>GEO、 BitMap、HyperLogLog</strong> 等其他类型。</p>
<p>Redis 有哪些特点？</p>
<ul>
<li><p>读写性能优异</p>
<ul>
<li><strong>基于内存，内存的访问速度是⽐磁盘快很多的</strong></li>
<li><strong>采⽤单线程模型，不存在多线程的上下⽂切换，不需要考虑锁的问题</strong></li>
<li>使⽤ IO 多路复⽤模型，让 <strong>Redis 不需要创建额外的线程来监听客户端的大量请求</strong>，减少性能的消耗</li>
<li>内置了多种优化过的数据结构实现</li>
</ul>
</li>
<li><p>所有<strong>操作命令都是原⼦性的</strong></p>
</li>
<li><p>⽀持事务</p>
<ul>
<li>允许多个命令按顺序执⾏并不会被打断</li>
<li>不⽀持回滚</li>
</ul>
</li>
<li><p>⽀持数据持久化</p>
<ul>
<li><strong>RDB：通过创建快照来获得存储在内存⾥⾯的数据在某个时间点上的副本</strong></li>
<li><strong>AOF：执⾏完更改数据的命令后，会将该命令记录到⽇志中</strong></li>
</ul>
</li>
<li><p>⽀持分布式部署</p>
</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240329204556712-1737881543401186.png" alt="image-20240329204556712" style="zoom: 67%;" />

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240329204624087-1737881543401187.png" alt="image-20240329204624087" style="zoom:67%;" />

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240329204700860-1737881543401188.png" alt="image-20240329204700860"></p>
<h2 id="2、讲⼀下-Redis-的单线程模型，IO-多路复⽤是什么？"><a href="#2、讲⼀下-Redis-的单线程模型，IO-多路复⽤是什么？" class="headerlink" title="2、讲⼀下 Redis 的单线程模型，IO 多路复⽤是什么？"></a>2、讲⼀下 Redis 的单线程模型，IO 多路复⽤是什么？</h2><p>单线程</p>
<hr>
<p>​    <strong>Redis</strong>它采用单线程模型来处理客户端请求。<strong>这里的单线程指的是</strong>Redis服务器进程中<strong>只有一个主线程来处理所有的网络I&#x2F;O、数据读写、命令执行等任务</strong>，而不是像传统的多线程服务器一样，每个连接都会创建一个新的线程来处理。</p>
<p>​    Redis采用<strong>单线程模型的主要原因是为了避免多线程带来的线程切换、锁竞争等开销，从而提高系统的吞吐量和响应速度</strong>。此外，单线程模型还可以简化系统的设计和实现，减少出错的概率。</p>
<p>IO多路复用</p>
<hr>
<p><strong>同时监听多个文件描述符</strong>（sockets或者文件等），能够有效地管理多个IO事件并在事件发生时作出相应的处理。在Redis中，IO多路复用机制通常是<strong>通过select、poll、epoll这些系统调用来实现</strong>的，具体选择哪种机制取决于操作系统和性能需求。这些机制都可以监视多个文件描述符，并在有事件发生时通知应用程序，从而实现同时管理多个IO事件的能力。</p>
<p>通过IO多路复用机制，Redis可以在<strong>一个线程中同时监听多个客户端连接的IO事件</strong>，当有数据到达或连接就绪时，Redis可以立即作出响应，而不需要为每个连接创建一个单独的线程或进程，从而减少了系统资源的开销，<strong>提高了IO处理的效率。（redis快的原因之一）</strong></p>
<p>  总的来说，Redis使用IO多路复用机制可以更高效地处理多个IO事件，提高系统的性能和响应速度，是一种常见的IO处理方式，尤其适用于需要高效处理大量并发IO请求的场景。</p>
<hr>
<p>###1.1 文件描述符（sockets或者文件等）是什么？</p>
<p> 文件描述符是<strong>操作系统中</strong>用来<strong>标识</strong>打开文件、网络连接或其他<strong>I&#x2F;O资源的整数值</strong>。在Unix和类Unix系统中，一切皆文件的思想下，文件描述符可以用来唯一标识一个打开的文件、<strong>套接字（sockets）</strong>、<strong>管道等</strong>I&#x2F;O资源。</p>
<p> 在Redis中，文件描述符主要用来标识与客户端的网络连接，以便进行数据读写操作。Redis使用文件描述符来管理多个客户端连接，实现高效的IO多路复用。</p>
<h3 id="1-2-套接字（sockets）是什么？"><a href="#1-2-套接字（sockets）是什么？" class="headerlink" title="1.2 套接字（sockets）是什么？"></a>1.2 套接字（sockets）是什么？</h3><p>套接字（sockets）是在网络编程中用于实现网络通信的一种机制。<strong>套接字是由IP地址和端口号组合而成的</strong>，通过套接字可以在网络中传输数据。在网络编程中，<strong>客户端和服务器通过套接字进行通信</strong>。客户端通过创建一个套接字并连接到服务器的套接字来发起请求，而服务器则监听特定的套接字，接受客户端的连接请求，并与客户端进行通信。</p>
<p>  <strong>套接字</strong>可以<strong>分为两种类型</strong>：流套接字（SOCK_STREAM）和数据报套接字（SOCK_DGRAM）。流套接字提供面向连接的、可靠的数据传输，如TCP协议；数据报套接字提供无连接的、不可靠的数据传输，如UDP协议。</p>
<p>  在Redis中，套接字常用于表示与客户端建立的网络连接。Redis服务器通过套接字与客户端进行通信，接收客户端的请求并返回响应。通过套接字，Redis实现了与客户端之间的数据交换和通信，支持网络访问和操作。</p>
<h3 id="1-3-I-O资源中的管道是什么意思？"><a href="#1-3-I-O资源中的管道是什么意思？" class="headerlink" title="1.3 I&#x2F;O资源中的管道是什么意思？"></a>1.3 I&#x2F;O资源中的管道是什么意思？</h3><p>I&#x2F;O资源中的<strong>管道（Pipe）是</strong>一种在<strong>Unix和类Unix操作系统</strong>中用于<strong>进程间通信</strong>的机制。</p>
<p>  管道是由操作系统内核维护的一个缓冲区，它可以连接两个进程，其中<strong>一个进程的输出会直接成为另一个进程的输入</strong>。这样，通过管道可以实现进程之间的数据交换和通信，而无需借助临时文件等额外的存储介质。</p>
<p>  在Unix系统中，管道通常使用竖线符号（|）来连接两个命令，例如，<code>command1 | command2</code> 就表示将 <code>command1</code> 的输出作为 <code>command2</code> 的输入。</p>
<h3 id="1-4-Unix和类Unix操作系统是什么意思？"><a href="#1-4-Unix和类Unix操作系统是什么意思？" class="headerlink" title="1.4 Unix和类Unix操作系统是什么意思？"></a>1.4 Unix和类Unix操作系统是什么意思？</h3><p>Unix和类Unix操作系统指的是一类操作系统，它们的设计灵感来自于原始的Unix操作系统，或者在设计上借鉴了Unix的特性和思想，因此被称为“类Unix”操作系统。</p>
<p>类Unix操作系统通常具有以下<strong>特点</strong>：</p>
<ol>
<li>遵循Unix操作系统设计思想：包括一切皆文件、小即是美、可编程接口等。</li>
<li>提供类似Unix的命令行界面和工具：如shell、grep、awk等。</li>
<li>支持类Unix的标准：如POSIX标准（Portable Operating System Interface）等。</li>
</ol>
<p><strong>常见的</strong>类Unix操作系统包括但不限于：</p>
<ul>
<li>Linux：最知名的开源类Unix操作系统，由Linus Torvalds发起并得到全球开发者社区的支持。</li>
<li>MacOS：苹果公司基于BSD Unix开发的操作系统。</li>
<li>Solaris：甲骨文公司开发的商用Unix操作系统。</li>
<li>BSD（Berkeley Software Distribution）：源自加州大学伯克利分校的Unix衍生版操作系统。</li>
</ul>
<p>###1.5 在计算机系统中，<strong>I&#x2F;O资源包括</strong>：</p>
<ol>
<li><p>各种<strong>外部设备</strong>（如硬盘、键盘、鼠标、打印机等）</p>
</li>
<li><p><strong>网络接口</strong> :</p>
<p>网络接口：网络接口用于连接计算机系统与网络之间进行数据传输。计算机系统通过网络接口可以访问 Internet、局域网或广域网等。例如，无线网卡用于连接无线网络，以实现无线上网功能。</p>
</li>
<li><p><strong>数据传输的通道和总线</strong> </p>
<p>数据传输通道和总线用于在计算机内部和外部设备之间进行数据传输和通信。总线是计算机内部各个组件之间的数据传输通道，不同类型的总线用于连接 CPU、内存、显卡等设备。例如，PCI Express 总线用于连接显卡和主板，实现高速数据传输。</p>
</li>
</ol>
<h3 id="1-6-IO多路复用机制中select、poll、epoll这些系统调用分别是什么？"><a href="#1-6-IO多路复用机制中select、poll、epoll这些系统调用分别是什么？" class="headerlink" title="1.6 IO多路复用机制中select、poll、epoll这些系统调用分别是什么？"></a>1.6 IO多路复用机制中select、poll、epoll这些系统调用分别是什么？</h3><p><strong>select</strong>:</p>
<ul>
<li><code>select</code>是早期的I&#x2F;O多路复用系统调用，它允许程序监视一组文件描述符，等待其中一个或多个变得“就绪”（可读、可写或有异常）。</li>
<li><code>select</code>的主要缺点是它<strong>支持的文件描述符数量有限</strong>（通常受限于<code>FD_SETSIZE</code>），并且每次调用都需要重新传递整个文件描述符集合和对应的感兴趣事件，这导致在高并发情况下性能较差。</li>
<li><code>select</code>在多核处理器上扩展性不好，因为它只能在一个线程中运行</li>
</ul>
<p><strong>poll</strong>:</p>
<ul>
<li><code>poll</code>系统调用与<code>select</code>类似，但它<strong>没有文件描述符数量的限制</strong>，因为它是通过一个数组来传递文件描述符和事件信息的，这个数组的长度可以自由设置。</li>
<li><code>poll</code>解决了<code>select</code>在文件描述符数量上的限制问题，但在处理大量文件描述符时，性能仍然是一个问题，因为每次<strong>调用都需要遍历整个数组</strong>。</li>
</ul>
<p><strong>epoll</strong>:</p>
<ul>
<li><code>epoll</code>是Linux特有的I&#x2F;O多路复用机制，它提供了比<code>select</code>和<code>poll</code>更高效的解决方案。</li>
<li><code>epoll</code>通过一个称为<strong>“事件表”的数据结构来管理文件描述符，这使得它可以非常快速地检测到就绪的文件描述符</strong>，不需要像<code>select</code>和<code>poll</code>那样每次调用都遍历所有文件描述符。</li>
<li><code>epoll</code>支持<strong>边缘触发（ET）和水平触发（LT）</strong>两种模式，边缘触发模式在性能上更有优势，因为它只在状态变化时通知，而不是在每次可读或可写时都通知。</li>
<li><code>epoll</code>还可以与线程池结合使用，以充分利用多核处理器的性能。</li>
</ul>
<p><strong>epoll_ctl，将要监听的fd加到红黑树中，并使用回调函数监听，发生事件，内核去准备好数据，数据就绪，就将这些fd添加到链表，然后复制到用户空间，用户态就知道哪些fd准备好了，再把对应的数据取出来进行响应</strong></p>
<p>##3、Redis 基础类型中的 String 底层实现是什么？</p>
<p>String 底层实现是 SDS，也就是<strong>动态字符串</strong>。 </p>
<p>Redis当中的动态字符串主要是<strong>对C语⾔中的做了⼀个封装</strong>，使得SDS具有<strong>动态扩容、O(1)复杂度的⻓度计算</strong>的特点。 并且避免了C字符串<strong>缓冲区溢出</strong>（C字符串不记录⾃身⻓度）。</p>
<p>当 <strong>SDS API 需要对 SDS 进⾏修改时，API 会先检查 SDS 的空间是否满⾜修改所需的要求，如果不满⾜的话，API 会⾃动将 SDS 的空间扩展⾄执⾏修改所需的⼤⼩</strong></p>
<p>SDS主要由三个部分组成：</p>
<ul>
<li><p>len <strong>实际使⽤</strong>⻓度 —-&gt;查询</p>
</li>
<li><p>free buf数组中<strong>未使⽤字节</strong>的数量 —-&gt;动态扩容</p>
<ul>
<li><p>空间预分配</p>
<p>空间预分配用于优化 SDS 的字符串增长操作： 当 SDS 的 API 对一个 SDS 进行修改， 并且需要对 SDS 进行空间扩展的时候， 程序不仅会为 SDS 分配修改<strong>所必须要的空间， 还会为 SDS 分配额外的未使用空间</strong></p>
<ul>
<li>&lt;1MB,程序分配和 <code>len</code> 属性同样大小的未使用空间， 这时 SDS <code>len</code> 属性的值将和 <code>free</code> 属性的值相同。</li>
<li>&gt;&#x3D;1MB,那么程序会分配 <code>1 MB</code> 的未使用空间。</li>
</ul>
</li>
<li><p>惰性空间释放</p>
<p>惰性空间释放用于优化 SDS 的字符串缩短操作： 当 SDS 的 API 需要缩短 SDS 保存的字符串时， 程序并不立即使用内存重分配来回收缩短后多出来的字节， 而是使用 <code>free</code> 属性将<strong>这些字节的数量记录起来， 并等待将来使用。</strong></p>
<p> SDS 也提供了相应的 API ， 让我们可以在有需要时， <strong>真正地释放 SDS 里面的未使用空间</strong>。</p>
</li>
</ul>
</li>
<li><p>char buf[] ⽤于<strong>保存字符串</strong></p>
</li>
</ul>
<p>##4、如何使用Redis 实现⼀个排⾏榜？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240421095820604-1737881543401189.png" alt="image-20240421095820604"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240421095841967-1737881543401190.png" alt="image-20240421095841967"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240421095854810-1737881543401191.png" alt="image-20240421095854810"></p>
<h2 id="5、Redis-的持久化机制有哪些？说说各⾃的优缺点和应⽤场景？"><a href="#5、Redis-的持久化机制有哪些？说说各⾃的优缺点和应⽤场景？" class="headerlink" title="5、Redis 的持久化机制有哪些？说说各⾃的优缺点和应⽤场景？"></a>5、Redis 的持久化机制有哪些？说说各⾃的优缺点和应⽤场景？</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240421095644996-1737881543401192.png" alt="image-20240421095644996"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240421095700009-1737881543401193.png" alt="image-20240421095700009"></p>
<p>##6、如何⽤ Redis 实现分布式 Session？</p>
<p>分布式 session 指在多个服务器间共享 session，我们可以使⽤ redis 来存储 session 来实现该功能。</p>
<p>在 redis 中我们通常使⽤ Hash 来存储 session。</p>
<p>具体的步骤如下：</p>
<ol>
<li><p>⽤户登录成功后，将 Session 存到 redis 中 </p>
</li>
<li><p>将key设置为⼀个全局 id，格式可以采⽤“session:token”，其中 token 为 sessiond 的唯⼀标识。 </p>
</li>
<li><p>将 session 的唯⼀标识 token 以 cookie 的形式返回给客户端，客户端在后续请求中都会携带这个 cookie。 </p>
</li>
<li><p>后续请求中，服务器拿到客户端传来的 cookie，并根据它的值，也就是 token，去 <strong>redis</strong> 找对应的 session  数据。 </p>
</li>
<li><p>⽤户退出登录后，将 session 删除。</p>
<p>可以使⽤ Redis 的 <strong>EXPIRE</strong> 命令来设置 <strong>Session 数据的过期时间</strong>，这样可以⾃动删除<strong>已经过期的 Session</strong> 数据。</p>
<p>同时，还需要注意保护 Redis 中的 Session  数据不被恶意攻击者窃取，⼀般可以通过设置 Session 数据的前缀和使 ⽤随机的 Session ID 等⽅式来提⾼安全性。</p>
</li>
</ol>
<h2 id="7、讲⼀下-Redis-中的内存淘汰机制、有哪些内存淘汰策略？"><a href="#7、讲⼀下-Redis-中的内存淘汰机制、有哪些内存淘汰策略？" class="headerlink" title="7、讲⼀下 Redis 中的内存淘汰机制、有哪些内存淘汰策略？"></a>7、讲⼀下 Redis 中的内存淘汰机制、有哪些内存淘汰策略？</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240421095340309-1737881543401194.png" alt="image-20240421095340309"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240421095356981-1737881543401195.png" alt="image-20240421095356981"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240421095456550-1737881543401196.png" alt="image-20240421095456550"></p>
<h2 id="8、Redis-6-0-之后为何引入了多线程？6-0-之前为什么不使⽤多线程？"><a href="#8、Redis-6-0-之后为何引入了多线程？6-0-之前为什么不使⽤多线程？" class="headerlink" title="8、Redis 6.0 之后为何引入了多线程？6.0 之前为什么不使⽤多线程？"></a>8、Redis 6.0 之后为何引入了多线程？6.0 之前为什么不使⽤多线程？</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240421095126205-1737881543401197.png" alt="image-20240421095126205"></p>
<p>主二，+充分利用了<strong>CPU多核的计算能力</strong>。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240509094608084-1737881543401198.png" alt="image-20240509094608084" style="zoom: 50%;" />

<p>##9、Redis 有哪些数据类型？基础数据结构有⼏种？你还知道哪些 Redis  的⾼级数据结构？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240421094954859-1737881543401199.png" alt="image-20240421094954859"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240421095014099-1737881543401200.png" alt="image-20240421095014099"></p>
<p>##10、Redis 为什么快？</p>
<p><strong>1、纯内存操作</strong> </p>
<p>Redis 是基于内存的数据存储系统，绝⼤部分请求是纯粹的内存操作。 </p>
<p><strong>2、单线程操作，避免了频繁的上下⽂切换</strong> </p>
<p>Redis 的单线程操作是指，Redis 使⽤⼀个主线程来处理所有的客户端请求和数据操作，不会创建新的线程来处理请求。这种单线程模型的优点是可以避免多线程并发访问共享数据时的竞争和死锁问题，从⽽提⾼了 Redis 的性能和稳定性。此外，由于 Redis 的内存访问速度⾮常快，因此单线程处理请求也能够保证⾜够的性能。 </p>
<p><strong>3、采⽤了非阻塞 I&#x2F;O 多路复⽤机制</strong> </p>
<p>为了实现单线程模型，Redis 使⽤了 IO 多路复⽤技术。IO 多路复⽤是指操作系统提供的⼀种 IO 模型，可以让<strong>⼀个进程同时监听多个 IO 事件（如读写事件）</strong>，并在有事件发⽣时通知进程，从⽽实现并发处理 IO 事件。 具体来说，在 Redis 中，客户端的请求是由⼀个单线程来处理的，⽽ IO 操作却是通过 <strong>epoll 多路复⽤技术实现</strong> 的。</p>
<p>Redis 单线程情况下，内核会⼀直监听 socket 上的连接请求或者数据请求，⼀旦有请求到达就交给 Redis 线程处理，这就实现了⼀个 Redis 线程处理多个 IO 流的效果。 select&#x2F;epoll 提供了基于事件的回调机制，即针对不同事件的发⽣，调⽤相应的事件处理器。所以 Redis ⼀直在处理事件，提升 Redis 的响应性能。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240417224837032-1737881543401201.png" alt="image-20240417224837032"></p>
<p>##11、如何使⽤ Redis 实现分布式锁？</p>
<p>基于 Redis 的分布式锁实现思路：</p>
<ul>
<li><p>利⽤ <strong>setnx 获取锁，并设置过期时间，保存线程标识</strong></p>
<ul>
<li><strong>uuid+ 线程 id 因为不同服务器线程 id 有可能⼀样, 所以拼接 uuid</strong></li>
</ul>
</li>
<li><p><strong>释放锁时先判断线程标识是否与⾃⼰⼀致，⼀致则删除锁</strong></p>
<ul>
<li><strong>判断锁是否为⾃⼰的然后再释放, 这个过程必须是原⼦性的否则有可能释放别⼈的锁, 这就需要 lua 脚本</strong>。</li>
</ul>
</li>
</ul>
<p>特性：</p>
<ul>
<li>利⽤ set nx 满⾜互斥性</li>
<li>利⽤ set ex 保证故障时锁依然能释放，避免死锁，提⾼安全性</li>
<li>利⽤ Redis集群保证⾼可⽤和⾼并发特性</li>
</ul>
<p><strong>可重⼊</strong></p>
<ul>
<li><p>和 jdk 的可重⼊锁的原理是⼀致的</p>
</li>
<li><p>使⽤ hash类型, key 为 userId 或者商品 id , field 为线程 id, value 为数字。 加锁解锁都需要使⽤ lua 脚本</p>
<ul>
<li><p>加锁</p>
<ul>
<li>判断 key 是否存在, 不存在则直接加锁, 加<strong>过期时间</strong> (key 为 userId 或者商品 id , field 为线程 id,  value 为 1)</li>
<li>存在则说明有⽅法已经加了锁，此时判断 field 的线程 id 是否则⾃⼰⼀致(是否为同⼀线程)，不同则返回, 相同则 value+1, 然后设置过期时间</li>
</ul>
</li>
<li><p>加锁后执⾏流程</p>
<ul>
<li>⽅法 1 加锁后, value&#x3D;1, ⽅法1调⽤⽅法2</li>
<li>⽅法 2 加锁, redisson 判断锁标识是否是⾃⼰(field 字段是否为同⼀线程)，若是则 value++，value 为  2</li>
<li>同理, ⽅法 3 加锁，value&#x3D;3</li>
</ul>
</li>
</ul>
</li>
<li><p>释放锁	</p>
<ul>
<li><p>判断锁是否是⾃⼰线程的. 不是则退出。是则 value-1</p>
</li>
<li><p>判断重复次数 value 是否为 0, 如果为 0 则释放锁。不为 0 说明锁其他⼈还在⽤, 则重置有效期</p>
</li>
</ul>
</li>
<li><p>释放锁执⾏流程</p>
<ul>
<li>⽅法 3 执⾏完毕， 释放锁，value–， value&#x3D;2</li>
<li>⽅法 2 释放锁，value&#x3D;1</li>
<li>⽅法 1 释放锁， value&#x3D;0，此时删除 redis 的该数据，锁完全释放</li>
<li><strong>可重试</strong>：<strong>利⽤信号量和 redis 的 pubsub 发布订阅机制实现等待、唤醒，获取锁失败的重试机制</strong></li>
</ul>
</li>
<li><p>先直接获取锁, 如果获取失败, 并不是直接重试， 因为现在⽴即重试⼤概率其他线程正在执⾏业务，获取锁失败会先暂时等待。 (CPU 占⽤率不会很⾼, 性能不错)</p>
</li>
<li><p>获取锁成功的线程在释放锁时会发布⼀条消息。</p>
</li>
<li><p>当其他线程得到该消息时, 就会重新获取锁，如果再次获取锁失败，就会再次等待.</p>
</li>
<li><p>但是不是⽆限制的等待, 因为他会有⼀个等待时间, 超过该时间则不重试直接返回 false</p>
</li>
</ul>
<p><strong>超时续约</strong>：利⽤ watchDog，每隔⼀段时间(releaseTime&#x2F;3)，重置超时时间</p>
<ul>
<li>看⻔狗机制会创建⼀个守护线程, 当锁快到期但是业务线程没执⾏完时为锁增加时间 (续命). </li>
<li>当然看⻔狗也不会⽆限地增加超时时间, redisson ⼀个参数⽤来设置加锁的时间, 超过这个时间后锁便⾃动解开了，不会延⻓锁的有效期。</li>
</ul>
<p>主从⼀致性问题：使⽤多个独⽴的 Redis 节点</p>
<ul>
<li>获取锁时, 往每⼀个 redis 节点都写⼊ key。即便其中⼀台 redis 宕机, 其他 redis 依旧有锁信息.</li>
<li>并且必须在所有节点都获取到锁, 才算获取锁成功. </li>
<li>Redisson 分布式联锁 RedissonMultiLock 对象可以将多个 RLock 锁对象关联为⼀个联锁, 可以把⼀组锁当作 ⼀个锁来加锁和释放。</li>
</ul>
<p>##12、如何⽤ Redis 中的 HyperLogLog 统计⻚⾯ UV?</p>
<p>HyperLogLog 是⽤于做基数统计的结构，在输⼊量⾮常⼤的时候,⾮常好⽤</p>
<ul>
<li>12k的⼤⼩可以记录 2^64 次⽅个不同元素 </li>
<li>误差极⼩ 0.81%</li>
</ul>
<p>我⽤的可是上流的 SpringBoot,为什么要⽤ Jedis? 使⽤ <strong>HyperLogLog统计 UV</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240421090943401-1737881543401202.png" alt="image-20240421090943401"></p>
<h2 id="13、Redis与MySQL双写一致性如何保证？"><a href="#13、Redis与MySQL双写一致性如何保证？" class="headerlink" title="13、Redis与MySQL双写一致性如何保证？"></a>13、Redis与MySQL双写一致性如何保证？</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240509132603722-1737881543401203.png" alt="image-20240509132603722"></p>
<p>缓存更新—-主动更新策略</p>
<ul>
<li><p>Cache-Aside Pattern，即旁路缓存模式，它的提出是为了尽可能地解决缓存与数据库的数据不一致问题。</p>
</li>
<li><p>Read-Through&#x2F;Write-Through（读写穿透）</p>
</li>
</ul>
<p>Read&#x2F;Write-Through模式中，服务端把<strong>缓存作为主要数据存储</strong>。应用程序跟数据库缓存交互，都是通过<strong>抽象缓存层</strong>完成的</p>
<p>Write-behind 跟Read-Through&#x2F;Write-Through有相似的地方，都是由Cache Provider来负责缓存和数据库的读写。它们又有个很大的不同：Read&#x2F;Write-Through是同步更新缓存和数据的，Write-Behind则是只更新缓存，<strong>不直接更新数据库，通过批量异步的方式来更新数据库</strong>。</p>
<p>这种方式下，缓存和数据库的一致性不强，对一致性要求高的系统要谨慎使用。但是它适合频繁写的场景，MySQL的<strong>InnoDB Buffer Pool机制</strong>就使用到这种模式。</p>
<p><strong>操作缓存的时候，到底是删除缓存呢，还是更新缓存？</strong></p>
<p>更新缓存，会出现缓存和数据库数据不一致的问题。</p>
<p><strong>双写的情况下，先操作数据库还是先操作缓存？</strong></p>
<p>先操作数据库再删除缓存。</p>
<p><strong>数据库和缓存数据保持强一致，可以嘛</strong>？</p>
<p>实际上，没办法做到数据库与缓存绝对的一致性。<strong>追求绝对一致性的业务场景，不适合引入缓存。</strong></p>
<p>3种方案保证数据库与缓存的一致性</p>
<ul>
<li><strong>缓存延时双删</strong>（第二次删除缓存失败）</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="JOB-md.assets/4273535059bf3e82101669d77bde93e6.png" style="zoom:33%;" />

<ul>
<li><strong>删除缓存重试机制</strong>（会造成好多业务代码入侵）</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="JOB-md.assets/18a1fc6486b9a9db81c9d526532438a3.png" style="zoom: 50%;" />

<ul>
<li>读取binlog异步删除缓存</li>
</ul>
<p>通过数据库的binlog来<strong>异步淘汰key</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="JOB-md.assets/dfbcd20d018b190bcf26b597ec81de9f.png" style="zoom: 50%;" />

<ul>
<li>可以使用阿里的<strong>canal将binlog日志采集发送到MQ队列里面然后通过ACK机制确认处理这条更新消息，删除缓存</strong>，保证数据缓存一致性</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&mid=2653557285&idx=1&sn=6eedd04eac05b1e531b8096ccd6e7cf9&chksm=813983bdb64e0aabf8bbcbb8e991b9045f7c675752debf966d53017ec4a0e495310dcc4cd4ac&mpshare=1&srcid=1016Yl8anhxtWuKI8SKLYEDr&sharer_sharetime=1634364868193&sharer_shareid=2bf0d8899ef3c7501d20b3a21b816303&from=singlemessage&scene=1&subscene=10000&clicktime=1634779662&enterid=1634779662&ascene=1&devicetype=android-30&version=28000f39&nettype=ctnet&abtest_cookie=AAACAA==&lang=zh_CN&exportkey=AaOaGL1BPofOCZG/+V0VCBM=&pass_ticket=WXDx5OHa+YvJJHI4xgzF39p1DeTynkPBL8GPqqTd+rnn0A+htLS9JGW8Hv7IowSZ&wx_header=1"></a></p>
<h2 id="14、缓存穿透"><a href="#14、缓存穿透" class="headerlink" title="14、缓存穿透"></a><font color=red>14、缓存穿透</font></h2><p>客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240407190003945-1737881543401204.png" alt="image-20240407190003945"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240407190635220-1737881543402206.png" alt="image-20240407190635220"></p>
<h2 id="15、缓存雪崩"><a href="#15、缓存雪崩" class="headerlink" title="15、缓存雪崩"></a><font color=red>15、缓存雪崩</font></h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240407191944439-1737881543402205.png" alt="image-20240407191944439"></p>
<h2 id="16、缓存击穿"><a href="#16、缓存击穿" class="headerlink" title="16、缓存击穿"></a><font color=red>16、缓存击穿</font></h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240509095605280-1737881543402208.png" alt="image-20240509095605280"></p>
<h2 id="黑马点评逻辑"><a href="#黑马点评逻辑" class="headerlink" title="黑马点评逻辑"></a>黑马点评逻辑</h2><p>（缓存击穿）互斥锁&#x2F;逻辑过期 ：下边两个在获取锁成功后，都需要再次查询缓存，若缓存中数据符合条件直接返回。</p>
<p>| <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240510190321576-1737881543402207.png" alt="image-20240510190321576" style="zoom: 50%;" /> | <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240510190517735.png" alt="image-20240510190517735" style="zoom: 50%;" /> |</p>
<p>优惠券秒杀（全局唯一ID生成器—基于Redis）：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240512104853058-1737881543402210.png" alt="image-20240512104853058"></p>
<p>redission可重入&#x2F;可重试：</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240512085222453.png" alt="image-20240512085222453" style="zoom: 50%;" />  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240512105816975-1737881543402212.png" alt="image-20240512105816975" style="zoom: 67%;" /> |</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240512105239705.png" alt="image-20240512105239705" style="zoom: 67%;" /> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240512105522335-1737881543402213.png" alt="image-20240512105522335" style="zoom: 67%;" /> </p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240513110518195-1737881543402215.png" alt="image-20240513110518195"> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240513112918248-1737881543402216.png" alt="image-20240513112918248"> </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240513114043883-1737881543402217.png" alt="image-20240513114043883"></p>
<p>小功能：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240514090917016-1737881543402218.png" alt="image-20240514090917016"></p>
<p>缓存穿透—布隆</p>
<p><strong>布隆过滤器的基本原理：</strong></p>
<ol>
<li><strong>位数组（Bit Array）</strong>：布隆过滤器使用一个包含大量二进制位的位数组，初始时所有位都被置为0。这个位数组通常会消耗一定数量的内存空间。</li>
<li><strong>多个哈希函数（Hash Functions）</strong>：布隆过滤器会预先定义若干个哈希函数，这些哈希函数可以将输入的元素映射到位数组中的不同位置。通常情况下，这些哈希函数会是独立且均匀分布的。</li>
<li><strong>插入操作：当一个新的元素需要加入布隆过滤器时，该元素会经过多个哈希函数计算得到多个哈希值，然后将位数组中对应的位置设为1。</strong> </li>
<li><strong>成员存在性检查</strong>：当需要检查一个元素是否在布隆过滤器中时，同样会对这个元素进行多次哈希计算，然后检查对应位置上的值。如果所有的位置都为1，则认为该元素可能存在于集合中；如果存在任何一个位置为0，则可以肯定该元素不存在于集合中。</li>
</ol>
<p><strong>需要注意的是，由于多个元素可能映射到位数组中的相同位置，因此布隆过滤器可能会出现“误伤”的情况，即某个元素被错误地判断为存在于集合中（false positive）。这种误判主要是由于哈希冲突引起的。</strong></p>
<p><strong>总的来说，布隆过滤器通过牺牲一定的准确性来换取内存占用和查询速度上的优势，因此在设计和使用时需要权衡误判率和内存消耗。</strong></p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240508202826128-1737881543402219.png" alt="image-20240508202826128"></p>
<h2 id="17、Redis的跳表是怎么实现的，性能如何，层高怎么生成的"><a href="#17、Redis的跳表是怎么实现的，性能如何，层高怎么生成的" class="headerlink" title="17、Redis的跳表是怎么实现的，性能如何，层高怎么生成的"></a>17、Redis的跳表是怎么实现的，性能如何，层高怎么生成的</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240823105627304-1737881543402220.png" alt="image-20240823105627304"></p>
<p><a target="_blank" rel="noopener" href="https://huangz.works/redisbook1e/preview/skiplist/datastruct.html">链接</a></p>
<p>每次创建一个新跳跃表节点的时候， 程序都根据幂次定律 （<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Power_law">power law</a>，越大的数出现的概率越小） 随机生成一个介于 <code>1</code> 和 <code>32</code> 之间的值作为 <code>level</code> 数组的大小， 这个大小就是层的“高度”；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="comment">// 成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">// 跨度</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="comment">// 表头节点和表尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="comment">// 表中节点的数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    <span class="comment">// 表中层数最大的节点的层数</span></span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>

<p><strong>在同一个跳跃表中， 各个节点保存的成员对象必须是唯一的， 但是多个节点保存的分值却可以是相同的： 分值相同的节点将按照成员对象在字典序中的大小来进行排序， 成员对象较小的节点会排在前面（靠近表头的方向）， 而成员对象较大的节点则会排在后面（靠近表尾的方向）。</strong></p>
<p>##18、Redis主从、哨兵、集群架构优缺点比较</p>
<p>主节点主要用于写数据，从节点主要用于读数据。</p>
<p>管理员为Sentinel（哨兵），不用负责数据的读写。管理员可能为几个。哨兵每隔10秒问候主节点</p>
<h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1><p>路由工厂：读取路由的判断规则，而后把他解析成对应的判断条件，等请求进来做判断。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240427205552841-1737881543402221.png" alt="image-20240427205552841" style="zoom: 67%;" />

<p>计算热点数据用到的方法：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240501095229051-1737881543402222.png" alt="image-20240501095229051" style="zoom:50%;" />

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240501095328905-1737881543402223.png" alt="image-20240501095328905"></p>
<p>##1、什么是分布式？为什么需要分布式</p>
<p>分布式是指在多台计算机上协同⼯作的系统，这些计算机通过⽹络连接在⼀起，共同完成⼀个任务。 </p>
<p>分布式系统能够有效地解决单台计算机处理能⼒不⾜、系统容易宕机、数据存储容量有限等问题，同时能够提⾼系统的可靠性、可⽤性和性能，适⽤于数据量较⼤、并发量⾼、访问频繁的场景。  </p>
<p>在分布式系统中，由于数据和计算任务被分布在多台计算机上，不同计算机之间需要进⾏通信和协调，因此需要解决分布式⼀致性、负载均衡、故障恢复、数据共享和安全等问题，同时需要考虑数据的⼀致性和可靠性。因此，分布式系统的设计和实现⽐单机系统更加复杂和困难，需要考虑到多个因素的综合影响。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240514092604609-1737881543402224.png" alt="image-20240514092604609" style="zoom:50%;" />

<p>##2、什么是⽹关，⽹关有哪些作⽤？</p>
<p>⽹关（Gateway）是连接<strong>两个或多个不同⽹络的设备</strong>，可以实现<strong>协议的转换、数据的转发和安全策略的实现</strong>等功能。简单来说，⽹关是<strong>设备与路由器之间的桥梁</strong>，由它将不同的⽹络间进⾏访问的控制，转换，交接等等</p>
<p>常⻅的⽹关有<strong>应⽤⽹关、协议⽹关、安全⽹关</strong>等。</p>
<p>应⽤⽹关：⽤于应⽤层协议的处理，如 HTTP、SMTP 等。 </p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240427201934526-1737881543402225.png" alt="image-20240427201934526" style="zoom: 67%;" />

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240427201001789-1737881543402226.png" alt="image-20240427201001789" style="zoom: 67%;" />

<p>网关是基于webflux实现的。 </p>
<p>跨域问题：浏览器禁止请求的发起者与服务端发生跨域Ajax请求，请求被浏览器拦截的问题。</p>
<p>解决：CROS</p>
<h2 id="3、Dubbo-是什么？是否了解过它的架构设计？"><a href="#3、Dubbo-是什么？是否了解过它的架构设计？" class="headerlink" title="3、Dubbo 是什么？是否了解过它的架构设计？"></a>3、Dubbo 是什么？是否了解过它的架构设计？</h2><p>Apache Dubbo 是⼀款⾼性能的 <strong>Java RPC</strong> 框架。其前身是阿⾥巴巴公司开源的⼀个⾼性能、轻量级的开源 Java  RPC 框架，可以和 Spring 框架⽆缝集成。</p>
<p><strong>什么是RPC？</strong></p>
<p>RPC 全称为 remote procedure call，即远程过程调⽤。 ⽐如两台服务器 A 和 B，A 服务器上部署⼀个应⽤，B 服务器上部署⼀个应⽤，A 服务器上的应⽤想调⽤B 服务器 上的应⽤提供的⽅法，由于两个应⽤不在⼀个内存空间，不能直接调⽤，所以需要通过⽹络来表达调⽤的语义和传达调⽤的数据。</p>
<p>Dubbo 架构图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240514094033367-1737881543402227.png" alt="image-20240514094033367"></p>
<p>各节点⻆⾊说明：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240514094100061-1737881543402228.png" alt="image-20240514094100061"></p>
<p><strong>调⽤关系说明：</strong></p>
<ol>
<li><p>服务容器负责启动，加载，运⾏服务提供者。 </p>
</li>
<li><p>服务提供者在启动时，向注册中⼼注册⾃⼰提供的服务。 </p>
</li>
<li><p>服务消费者在启动时，向注册中⼼订阅⾃⼰所需的服务。</p>
</li>
<li><p>注册中⼼返回服务提供者地址列表给消费者，如果有变更，注册中⼼将基于⻓连接推送变更数据给消费者。 </p>
</li>
<li><p>服务消费者，从提供者地址列表中，基于负载均衡算法，选⼀台提供者进⾏调⽤，如果调⽤失败，再选另⼀台调⽤。</p>
</li>
<li><p>服务消费者和提供者，在内存中累计调⽤次数和调⽤时间，定时每分钟发送⼀次统计数据到监控中⼼。</p>
</li>
</ol>
<p>##4、什么是分布式的 CAP 理论？</p>
<p>CAP 理论是指⼀个分布式系统中，不可能同时满⾜以下三个条件：</p>
<ul>
<li><strong>⼀致性（Consistency）</strong>：所有节点在同⼀时间的看到的数据是⼀致的，即写<strong>数据操作时要同时更新相关副本</strong>，保证<strong>强⼀致性</strong> </li>
<li><strong>可⽤性（Availability）</strong>：系统中能正常接收请求的节点都能在合理时间内返回结果，即<strong>系统在某些节点失效下仍能对外提供服务</strong></li>
<li><strong>分区容错性（Partition Tolerance）</strong>：什么是分区？分布式系统中存在很多节点，这些节点之间通过⽹络进⾏通信，<strong>当节点间的通信出了问题（如⽹络故障、机器故障等），就称系统出现了分区。⽽分区容错性就是出现分区问题时，系统还能继续对外提供服务</strong></li>
</ul>
<p>根据 CAP 理论，分布式系统只能满⾜其中的两个特性。然⽽实际上，<strong>分区容错性是⼀定要满⾜的</strong>，因为不可能只 要出现分区问题时整个系统就完全⽆法使⽤。因此，在分布式系统中，我们需要考虑的是当出现分区问题时，<strong>选择的是⼀致性还是可⽤性，即 CP 还是 AP。</strong></p>
<ul>
<li><p><strong>CP 架构</strong>：当系统出现分区故障时，客户端发送的任意请求都会被卡死或超时，保证数据的<strong>强⼀致性</strong>。如  <strong>Zookeeper</strong></p>
</li>
<li><p><strong>AP 架构</strong>：当系统出现分区故障时，<strong>客户端依旧能获取数据，但有的是新数据，有的是旧数据</strong>。如 <strong>Eureka</strong></p>
</li>
</ul>
<h2 id="5、什么是-RPC？⽬前有哪些常⻅的-RPC-框架？实现-RPC-框架的核⼼原理-是什么？"><a href="#5、什么是-RPC？⽬前有哪些常⻅的-RPC-框架？实现-RPC-框架的核⼼原理-是什么？" class="headerlink" title="5、什么是 RPC？⽬前有哪些常⻅的 RPC 框架？实现 RPC 框架的核⼼原理 是什么？"></a>5、什么是 RPC？⽬前有哪些常⻅的 RPC 框架？实现 RPC 框架的核⼼原理 是什么？</h2><p>RPC【<strong>Remote Procedure Call</strong>】是指远程过程调⽤，是⼀种<strong>进程间通信</strong>⽅式，他是⼀种技术的思想，⽽不是规范。它<strong>允许程序调⽤另⼀个地址空间（通常是共享⽹络的另⼀台机器上）的过程或函数</strong>，⽽不⽤程序员显式编码这个远程调⽤的细节。即程序员⽆论是调⽤本地的还是远程的函数，<strong>本质上编写的调⽤代码基本相同</strong>。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240514095246125-1737881543402229.png" alt="image-20240514095246125" style="zoom: 67%;" />

<p>⽬前常⻅的 <strong>RPC 框架</strong>有：</p>
<ol>
<li>Dubbo：阿⾥巴巴开源的<strong>分布式 RPC 框架</strong>，⽀持多种协议和负载均衡策略。 </li>
<li>gRPC：Google 开源的⾼性能 <strong>RPC 框架</strong>，⽀持多种语⾔。 </li>
<li>Thrift：Facebook 开源的跨语⾔ RPC 框架，⽀持多种传输协议和数据编解码⽅式。 </li>
<li>Spring Cloud Netflix：Spring Cloud 的⼦项⽬之⼀，提供了基于 Netflix OSS 开源组件的微服务解决⽅案， 包括服务发现、负载均衡、熔断器等功能。</li>
</ol>
<h2 id="6、什么是注册中心？如何实现⼀个注册中心？"><a href="#6、什么是注册中心？如何实现⼀个注册中心？" class="headerlink" title="6、什么是注册中心？如何实现⼀个注册中心？"></a>6、什么是注册中心？如何实现⼀个注册中心？</h2><p>注册中⼼是<strong>服务实例信息的存储仓库，也是服务提供者和服务消费者进⾏交互的桥梁</strong>。它主要提供了<strong>服务注册和服务发现</strong>这两⼤核⼼功能。在⼀个分布式系统中，不同的服务会以微服务的形式运⾏在不同的机器上，它们需要相互通信以完成业务逻辑。⽽注册中⼼则充当了服务之间的“⻩⻚”，记录了所有可⽤的服务及其⽹络地址，⽅便其他服务进⾏查找和调⽤。 </p>
<p>当⼀个新的服务启动时，它会向注册中⼼注册⾃⼰的⽹络地址和⼀些元数据信息（例如服务名称、版本号、健康状态等），注册中⼼会将这些信息存储在⾃⼰的数据中⼼中。当其他服务需要调⽤这个新服务时，它们可以通过向注册中⼼查询来获取该服务的地址和元数据信息，然后与该服务建⽴⽹络连接。</p>
<p> 常⻅的注册中⼼包括 ZooKeeper、Consul、Eureka 、Nacos 等等</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240427204241650-1737881543402230.png" alt="image-20240427204241650"></p>
<p>实现⼀个注册中⼼：</p>
<ol>
<li><p>设计数据模型：设计注册中⼼的数据模型，包括服务的元数据信息、服务实例的⽹络地址等。</p>
</li>
<li><p>实现服务注册：当服务启动时，它需要向注册中⼼注册⾃⼰的元数据信息和⽹络地址。可以通过 REST API、 RPC 等⽅式实现服务的注册。 </p>
</li>
<li><p>实现服务发现：当⼀个服务需要调⽤其他服务时，它需要向注册中⼼查询⽬标服务的⽹络地址。可以通过  REST API、RPC 等⽅式实现服务的发现。 </p>
</li>
<li><p>实现健康检查：为了保证服务的可⽤性，注册中⼼需要定期检查服务实例的健康状况，并将不健康的实例从服务列表中移除。 </p>
</li>
<li><p>实现⾼可⽤：注册中⼼是⼀个分布式系统的核⼼组件，需要保证⾼可⽤性。可以采⽤主从复制、集群等⽅式实 现注册中⼼的⾼可⽤性。 </p>
</li>
<li><p>实现安全机制：注册中⼼涉及到服务的元数据信息和⽹络地址等敏感信息，需要采取合适的安全措施</p>
</li>
</ol>
<h2 id="7、什么是分布式的-BASE-理论，它与-CAP-理论有什么联系？"><a href="#7、什么是分布式的-BASE-理论，它与-CAP-理论有什么联系？" class="headerlink" title="7、什么是分布式的 BASE 理论，它与 CAP 理论有什么联系？"></a>7、什么是分布式的 BASE 理论，它与 CAP 理论有什么联系？</h2><p>BASE 理论是对 CAP 理论的延伸，核⼼思想是即使⽆法做到强⼀致性（Strong Consistency，CAP 的⼀致性就是强⼀致性），但应⽤可以采⽤适合的⽅式达到最终⼀致性（Eventual Consitency）。</p>
<ol>
<li><p>Basically Available（基本可⽤）：分布式同再出现不可预知故障的时候，允许损失部分可⽤性</p>
</li>
<li><p>Soft state（软状态）：软状态也称弱状态，和硬状态相对，是指允许系统中的数据存在中间状态，并认为该 中间状态的存在不会影响系统的整体可⽤性，即允许系统在不同节点的数据副本之间进⾏数据同步的过程存在 延时 </p>
</li>
<li><p>Eventually consistent（最终⼀致性）：最终⼀致性强调的是系统中所有的数据副本，在经过⼀段时间上的同步后，最终能够达到⼀个⼀致的状态。因此，最终⼀致性的本质是需要系统保证最终数据能够达到⼀致，⽽不需要实时保证系统数据的强⼀致性</p>
</li>
</ol>
<p><strong>CAP 与 BASE 关系</strong></p>
<p>BASE 是对 CAP 中⼀致性和可⽤性权衡的结果，其来源于对⼤规模互联⽹系统分布式实践的结论，是基于 CAP定理逐步演化⽽来的，其核⼼思想是即使⽆法做到强⼀致性（Strong consistency），更具体地说，是对 CAP 中 AP  ⽅案的⼀个补充。其基本思路就是：通过业务，牺牲强⼀致性⽽获得可⽤性，并允许数据在⼀段时间内是不⼀致 的，但是最终达到⼀致性状态。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240514095643706-1737881543402231.png" alt="image-20240514095643706"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240521110925023-1737881543402232.png" alt="image-20240521110925023"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240521110944896-1737881543402233.png" alt="image-20240521110944896"></p>
<p><strong>事务协调器，起到一个拦截事务请求的作用。</strong></p>
<h2 id="8、分布式事务解决方案"><a href="#8、分布式事务解决方案" class="headerlink" title="8、分布式事务解决方案"></a>8、分布式事务解决方案</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240521203221147-1737881543402234.png" alt="image-20240521203221147"></p>
<h2 id="9、幂等"><a href="#9、幂等" class="headerlink" title="9、幂等"></a>9、幂等</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240521212134725-1737881543402235.png" alt="image-20240521212134725"></p>
<h2 id="10、分布式任务调度"><a href="#10、分布式任务调度" class="headerlink" title="10、分布式任务调度"></a>10、分布式任务调度</h2><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240521213330122-173788154335631.png" alt="image-20240521213330122" style="zoom:67%;" />

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240821102935479-1737881543402236.png" alt="image-20240821102935479"></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240821103351415-1737881543402238.png" alt="image-20240821103351415" style="zoom: 67%;" />

<h2 id="11、分布式事务"><a href="#11、分布式事务" class="headerlink" title="11、分布式事务"></a>11、分布式事务</h2><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240828084350303-1737881543402237.png" alt="image-20240828084350303"  />



<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240828084535876-1737881543402239.png" alt="image-20240828084535876"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240828084729589-1737881543402242.png" alt="image-20240828084729589"></p>
<p><strong>TCC 代码补偿事务（3pc）：解决跨服务调用场景下的分布式事务问题。</strong></p>
<p>非强一致性、保证的是最终一致性。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240828085323684-1737881543402240.png" alt="image-20240828085323684" style="zoom:67%;" />

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240828085612659-1737881543402241.png" alt="image-20240828085612659"></p>
<p><strong>本地消息：</strong>   </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240828090009203-1737881543402243.png" alt="image-20240828090009203"></p>
<p>问题：网络问题造成的5，没有收到请求。</p>
<p>解决：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/JOB-md.assets/image-20240828090226478-1737881543402244.png" alt="image-20240828090226478"></p>
<p><strong>同时需要保证消息的幂等性</strong>：使用乐观锁</p>
<p><strong>Seata框架</strong>：AT(2PC 的改进)和TCC</p>
<p><strong>Transaction Coordinator (TC)<strong>、</strong>Transaction Manager (TM)<strong>、</strong>Resource Manager (RM)</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240828090801586-1737881543402245.png" alt="image-20240828090801586" style="zoom:50%;" />

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240828090925022-1737881543402246.png" alt="image-20240828090925022"></p>
<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p>##1、什么是消息队列？消息队列有哪些应⽤场景？</p>
<p>消息队列是⼀种⽤于异步通信的机制，⽤于在不同的应⽤程序之间传递消息。消息队列通常由<strong>消息⽣产者、消息队列和消息消费者</strong>三部分组成。</p>
<p>消息⽣产者将消息发送到消息队列中，⽽消息消费者则从消息队列中接收消息。<strong>消息队列负责存储和管理消息，确保消息传递的可靠性和稳定性。在实现过程中，消息队列还会提供⼀些额外的功能，如消息过滤、消息路由、消息持久化等</strong>。</p>
<p>消息队列的特点：</p>
<ol>
<li><strong>异步通信：</strong>消息⽣产者和消息消费者之间采⽤异步通信模式，发送⽅⽆需等待接收⽅的响应即可继续执⾏。 </li>
<li><strong>解耦合：</strong>消息队列可以将消息⽣产者和消息消费者解耦合，使得它们之间的关系更加灵活。 </li>
<li><strong>可靠性：</strong>消息队列通常会提供⼀些保证消息传递可靠性的机制，如消息持久化、重试机制等。 </li>
<li><strong>缓冲：</strong>消息队列可以缓冲来⾃多个消息⽣产者的消息，使得消息消费者可以按照⾃⼰的节奏进⾏消费，从⽽有效地平衡⽣产者和消费者之间的处理速度。</li>
</ol>
<p>消息队列的应⽤：</p>
<ol>
<li><strong>异步任务处理：</strong>通过将任务发送到消息队列中，异步处理任务，提⾼系统的并发性能和吞吐量。 </li>
<li><strong>解耦合系统：</strong>将不同的业务逻辑拆分成不同的服务，通过消息队列实现服务之间的通信，提⾼系统的可维护性和可扩展性。 </li>
<li><strong>流量削峰</strong>：将流量通过消息队列分散到不同的服务中，避免单个服务被⾼并发流量打垮。 </li>
<li><strong>⽇志收集：</strong>通过将⽇志消息发送到消息队列中，将⽇志收集和分析与业务逻辑解耦合，提⾼系统的可靠性和可维护性</li>
<li><strong>应⽤解耦</strong>：将不同的应⽤程序通过消息队列进⾏集成，实现应⽤之间的解耦合和数据交换。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240820093953304-1737881543402247.png" alt="image-20240820093953304"></p>
<p>1、</p>
<p>2、均匀的分发消息给消费者，消息只能被消费一次：12306</p>
<p>3、发布订阅：生产者发的消息可以发给不同的队列，消息可以重复消费：天气预报，不同的网站接收消息</p>
<p>4、路由：附加路由Key，对数据进行筛选，发送给不同的队列，消费精准分发给消费者</p>
<p>5、主题模式：模糊匹配，根据通配符匹配队列分给不同的队列</p>
<p>6、RPC同步通信：异步通信不能获得结果，Rabbitmq提供了相同的实现。使用dubbo</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240820095736109-1737881543402248.png" alt="image-20240820095736109"></p>
<p>##2、有哪些主流的消息队列，它们分别有什么优缺点、各⾃的适⽤场景是什 么？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240514100043079-173788154335633.png" alt="image-20240514100043079"></p>
<p>##3、有哪些常⻅的消息队列模型？分别适⽤于什么场景？</p>
<p>⼀、什么是消息队列</p>
<p>我们可以把消息队列⽐作是⼀个存放消息的容器，当我们需要使⽤消息的时候可以取出消息供⾃⼰使⽤。<strong>消息队列是分布式系统中重要的组件，使⽤消息队列主要是为了通过异步处理提⾼系统性能和削峰、降低系统耦合性</strong></p>
<p>⼆、常⻅模型</p>
<p><strong>ActiveMQ，RabbitMQ，Kafka，RocketMQ</strong></p>
<ol>
<li><p>点对点模型（Point-to-Point Model）：也被称为队列模型，消息⽣产者将消息发送到队列中，然后消息消费 者从队列中获取消息并处理。适⽤于需要精确传递消息的场景，如订单处理、任务调度等。 </p>
</li>
<li><p>发布&#x2F;订阅模型（Publish&#x2F;Subscribe Model）：也被称为主题模型，消息⽣产者将消息发送到主题中，然后主 题将消息⼴播给所有订阅该主题的消费者。适⽤于需要将消息⼴播给多个消费者的场景，如新闻订阅、实时数据更新等。 </p>
</li>
<li><p>管道模型（Pipes and Filters Model）：消息⽣产者将消息发送到管道中，然后管道中的过滤器依次处理消息 并将其发送给下⼀个过滤器。适⽤于需要将消息按照⼀定的处理流程进⾏处理的场景，如⽇志处理、数据清洗 等。</p>
</li>
</ol>
<p>三、具体应⽤场景</p>
<ol>
<li><strong>RabbitMQ：⾼吞吐量的消息队列；多种语⾔客户端库⽀持；⽀持多种消息协议；⽀持复杂的路由规则；⽀持消息确认机制；适合任务队列、⽇志处理、消息通信等场景。</strong> </li>
<li><strong>Apache Kafka：</strong>⾼吞吐量、⽀持百万级别的消息每秒处理能⼒；分布式、⾼可靠、可扩展；⽀持持久化存储消息；数据复制⾄多个副本，保证数据可靠性；适合⼤规模数据流处理、⽇志系统等场景。 </li>
<li>Apache ActiveMQ：完全⽀持 JMS 规范，具有良好的跨语⾔⽀持；⽀持多种消息协议和多种持久化⽅式；具有较强的安全机制和集群管理能⼒；适合企业级应⽤、⾦融⾏业等场景。 </li>
<li>Apache RocketMQ：⾼吞吐量，低延迟，亿级消息堆积能⼒；⽀持事务消息、定时消息等⾼级特性；⽀持数据双写，保证数据可靠性；适合⼤规模数据流处理、⾦融⽀付等⾼可靠性场景</li>
</ol>
<p>##4、如何保证消息不丢失？</p>
<p><strong>RabbitMQ</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240521111731827-173788154335635.png" alt="image-20240521111731827"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240521112716302-1737881543402249.png" alt="image-20240521112716302"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240521111858513-1737881543402250.png"></p>
<p>消息、队列、交换机</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240521112753397-1737881543402252.png" alt="image-20240521112753397"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240521112345993-1737881543402251.png" alt="image-20240521112345993"></p>
<p>kafka</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240521170540203-1737881543402253.png" alt="image-20240521170540203"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240521191838903-1737881543403254.png" alt="image-20240521191838903"></p>
<h2 id="5、消息的重复消费"><a href="#5、消息的重复消费" class="headerlink" title="5、消息的重复消费"></a>5、消息的重复消费</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240521113052775-1737881543403255.png" alt="image-20240521113052775"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240521113104264-1737881543403256.png" alt="image-20240521113104264"></p>
<h2 id="6、RabbitMQ-死信交换机-延迟队列"><a href="#6、RabbitMQ-死信交换机-延迟队列" class="headerlink" title="6、RabbitMQ 死信交换机&#x2F;延迟队列"></a>6、RabbitMQ 死信交换机&#x2F;延迟队列</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240521113320746-1737881543403257.png" alt="image-20240521113320746"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/JOB-md.assets/image-20240521113956194-173788154336437.png" alt="image-20240521113956194"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240521114216907-1737881543403258.png" alt="image-20240521114216907"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240521115026051-173788154336539.png" alt="image-20240521115026051"></p>
<h2 id="7、消息堆积怎么解决？"><a href="#7、消息堆积怎么解决？" class="headerlink" title="7、消息堆积怎么解决？"></a>7、消息堆积怎么解决？</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240521145959612-173788154336541.png" alt="image-20240521145959612"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240521150319785-173788154336543.png" alt="image-20240521150319785"></p>
<p>RabbitMQ：惰性队列：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240521150127802-173788154336545.png" alt="image-20240521150127802"></p>
<p>RabbitMQ的高可用；普通集群、镜像集群、仲裁队列（用来代替镜像集群）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240521152128335-173788154336547.png" alt="image-20240521152128335"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240521164107445-1737881543403259.png" alt="image-20240521164107445"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240521193413040-173788154336549.png" alt="image-20240521193413040"></p>
<p>##8、kafka数据清理机制</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240521200429661-1737881543403260.png" alt="image-20240521200429661"></p>
<h2 id="9、kafka实现高性能的设计"><a href="#9、kafka实现高性能的设计" class="headerlink" title="9、kafka实现高性能的设计"></a>9、kafka实现高性能的设计</h2><p>零拷贝指的是cpu不参与拷贝，可以使用dma硬件参与拷贝而非cpu</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240521201405088-1737881543403261.png" alt="image-20240521201405088"></p>
<p>##10、</p>
<p><a target="_blank" rel="noopener" href="https://gw-c.nowcoder.com/api/sparta/jump/link?link=https://github.com/shaogezhu/easy-rpc">https://github.com/shaogezhu/easy-rpc</a>  </p>
<p>#JWT令牌技术</p>
<p><a target="_blank" rel="noopener" href="https://jwt.io/">官网</a></p>
<p><strong>Cookie的缺点:</strong></p>
<p><strong>安全性问题</strong>：Cookie可能会被截获或篡改，尤其是如果使用明文传输的话。虽然可以通过使用HTTPS和标记为安全的Cookie来提高安全性，但仍然存在潜在的风险。</p>
<p><strong>存储限制</strong>：浏览器对每个域的Cookie数量和大小有限制。虽然现代浏览器支持更大的存储空间，但仍然存在限制。</p>
<p><strong>用户配置</strong>：用户可能会禁用浏览器的Cookie功能，这会导致依赖于Cookie的应用程序无法正常工作。</p>
<p><strong>跨域问题</strong>：默认情况下，Cookie遵循同源策略，只能在设置它们的域中使用，这限制了跨域请求的使用。</p>
<p><strong>Session的缺点:</strong></p>
<p><strong>服务器负担</strong>：Session需要在服务器端存储用户状态，这会增加服务器的内存消耗，尤其是在高并发场景下。</p>
<p><strong>可扩展性</strong>：在分布式系统中，Session的管理和同步会成为问题。需要额外的机制来保证不同服务器间的Session状态一致。</p>
<p><strong>性能开销</strong>：每次请求都需要检查Session，这可能导致额外的数据库查询或其他存储机制的访问，影响性能。</p>
<p><strong>依赖Cookie</strong>：虽然Session本身存储在服务器上，但Session ID通常是通过Cookie传递的，这意味着如果用户禁用了Cookie，Session机制也可能失效。</p>
<p>###结构</p>
<h3 id="1-JWT-的结构"><a href="#1-JWT-的结构" class="headerlink" title="1. JWT 的结构"></a>1. JWT 的结构</h3><p>JWT 由三部分组成，以 <code>.</code> 分隔开：</p>
<ol>
<li><strong>Header（头部）</strong></li>
<li><strong>Payload（负载）</strong></li>
<li><strong>Signature（签名</strong>）</li>
</ol>
<h4 id="1-1-Header"><a href="#1-1-Header" class="headerlink" title="1.1 Header"></a>1.1 Header</h4><p>Header 是 JWT 的头部，通常包含两部分信息：</p>
<ul>
<li><strong>alg</strong>：签名算法，比如 HMAC SHA256 或 RSA。</li>
<li><strong>typ</strong>：类型，一般为 “JWT”。</li>
</ul>
<p>经过 Base64URL 编码后</p>
<h4 id="1-2-Payload"><a href="#1-2-Payload" class="headerlink" title="1.2 Payload"></a>1.2 Payload</h4><p>Payload 是 JWT 的有效载荷，包含需要传递的数据（如用户信息）。JWT 标准定义了一些默认字段（称为 “claims”，即声明），常见的有：</p>
<ul>
<li><strong>iss</strong>（Issuer）：签发者</li>
<li><strong>sub</strong>（Subject）：主题</li>
<li><strong>aud</strong>（Audience）：受众</li>
<li><strong>exp</strong>（Expiration Time）：过期时间</li>
<li><strong>nbf</strong>（Not Before）：在此之前无效</li>
<li><strong>iat</strong>（Issued At）：签发时间</li>
<li><strong>jti</strong>（JWT ID）：JWT 的唯一标识</li>
</ul>
<p>经过 Base64URL 编码后</p>
<h4 id="1-3-Signature"><a href="#1-3-Signature" class="headerlink" title="1.3 Signature"></a>1.3 Signature</h4><p>Signature 是签名部分，用于验证数据的完整性，防止数据被篡改。Signature 的生成过程如下：</p>
<ol>
<li>将编码后的 Header 和编码后的 Payload 用 <code>.</code> 连接起来。</li>
<li>使用指定的算法和密钥对 Header 和 Payload 的连接结果进行签名。</li>
</ol>
<p>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</p>
<p>###2、JWT 的工作流程</p>
<p>JWT 通常用于授权，基本的工作流程如下：</p>
<ol>
<li><strong>用户登录</strong>：用户通过用户名和密码登录。</li>
<li><strong>生成 JWT</strong>：服务器验证用户凭证（如用户名和密码）后，生成一个 JWT，并将用户的身份信息存入 Token 的 Payload 中。</li>
<li><strong>发送 JWT</strong>：服务器将 JWT 返回给客户端。</li>
<li><strong>存储 JWT</strong>：客户端通常将 JWT 存储在浏览器的本地存储（<code>localStorage</code>）或会话存储（<code>sessionStorage</code>）中，或通过 HTTP-only Cookie 存储。</li>
<li><strong>请求时携带 JWT</strong>：客户端每次请求资源时，将 JWT 附加到 HTTP 请求头中（通常放在 <code>Authorization: Bearer &lt;token&gt;</code>）。</li>
<li><strong>服务器验证 JWT</strong>：服务器接收到请求后，验证 JWT 的有效性。如果 JWT 合法且未过期，则允许访问资源，否则拒绝访问。</li>
</ol>
<h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h1><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240815220913477.png" alt="image-20240815220913477"  />

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240521090259863-173788154336652.png" alt="image-20240521090259863"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240521092554347-173788154336654.png" alt="image-20240521092554347"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240521095516111-173788154336656.png" alt="image-20240521095516111"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240521101912614-1737881543403262.png" alt="image-20240521101912614"></p>
<p>| <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240521103404530.png" alt="image-20240521103404530" style="zoom: 67%;" /> | <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="JOB-md.assets/image-20240521103554430-1737881543403263.png" alt="image-20240521103554430" style="zoom:67%;" /> |</p>
<p>##1、反向代理和正向代理的区别？为什么要反向代理？</p>
<p>正向代理：用来代理客户端，对服务器发起请求，<strong>服务器不知道哪个客户端发来的请求</strong>，只清楚是代理服务器发过来的，eg：我们常用的魔法；</p>
<p>反向代理：代理服务器将服务端的服务器隐藏起来，充当代理，<strong>客户端的请求会发送到代理服务器</strong>上。 </p>
<p>1、负载均衡</p>
<p>反向代理最大的优点就是可以充当负载均衡器，高流量网站通常面临每分钟处理大量请求的问题，这可能会降低其系统性能并破坏响应时间。使用反向代理可以保证更好的用户体验和更快的响应。</p>
<p> 2、充当缓存</p>
<p>一些反向代理可以充当缓存机器。通常，如果您在一分钟内发送一千个请求请求相同的资源，这些请求将一遍遍地到达请求相同资源的服务器，浪费了资源和宝贵的时间。首次请求资源时，反向代理可以缓存(保存)获取的资源，等下次需要相同资源时，直接可以获取，节省了资源和时间。</p>
<p>3、保障安全</p>
<p>如果使用反向代理，请求不会直接到达Web服务器。它们有助于保护Web服务器免受已知漏洞的影响。</p>
<h1 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h1><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240830195940705-1737881543403264.png" alt="image-20240830195940705" style="zoom:80%;" />

<p>以bash为例：</p>
<p>cat:查看命令</p>
<p>echo:    $0:   当前正在执行脚本的名称                       $shell:系统的环境变量</p>
<p>把想要执行的命令写到脚本中：</p>
<p>​                   脚本开头：#!&#x2F;bin&#x2F;bash</p>
<p>执行脚本命令：.&#x2F;+脚本名称</p>
<p>修改执行权限：<code>chmod a+x hello.sh</code>的作用是为所有用户（<code>a</code>代表所有用户，<code>u</code>代表文件所有者，<code>g</code>代表文件所属组的成员，<code>o</code>代表其他用户）添加执行（<code>x</code>）权限到文件<code>hello.sh</code>。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240830202030670-1737881543403265.png" alt="image-20240830202030670" style="zoom:67%;" />

<p>显示所有文件，.bashrc是在用户登录的时候只执行一次，.profile是在每次打开一个终端或者新建一个会话的时候执行的</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240830202240602-1737881543403267.png" alt="image-20240830202240602"></p>
<p>修改.bashrc文件之后，需要使用source或者.命令重新加载一下文件</p>
<p>alias:	起别名</p>
<p>shuf:    生成随机数</p>
<p>**<code>$()</code>**：</p>
<ul>
<li><code>$(command)</code> 结构用于命令替换（Command Substitution），它会执行 <code>command</code> 并将输出结果替换到 <code>$(command)</code> 的位置。</li>
</ul>
<p><strong><code>$(())</code></strong>:</p>
<ul>
<li><code>$(())</code> 结构用于算术扩展（Arithmetic Expansion），它允许在shell中进行基本的算术运算。</li>
<li>在 <code>$(())</code> 中可以执行加（+）、减（-）、乘（*）、除（&#x2F;）、取模（%）等算术操作，以及对变量进行自增（++）或自减（–）操作。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240830203907655.png" alt="image-20240830203907655" style="zoom: 50%;" /><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-11-12%20202953-1737881543403268.png" alt="屏幕截图 2024-11-12 202953"></p>
<p>echo:<code>echo</code> 是一个在类 Unix 系统中的常用命令，用于在终端或命令行界面输出（打印）文本或变量的值到标准输出（通常是屏幕）</p>
<p><code>grep</code> 命令的名称来源于 “global regular expression print”，即在全局范围内按照正则表达式打印匹配的文本行。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240830205629761-1737881543403269.png" alt="image-20240830205629761"></p>
<p><code>sed</code> 是一种流编辑器，用于对文本进行过滤和转换。命令 <code>sed -n &#39;10p&#39; file.txt</code> 的作用是打印文件 <code>file.txt</code> 中第10行的内容。</p>
<p>下面是命令中各个部分的解释：</p>
<ul>
<li><code>sed</code>：调用流编辑器。</li>
<li><code>-n</code>：这个选项告诉 <code>sed</code> 不要默认打印所有行，只打印经过编辑命令处理后的行。</li>
<li><code>&#39;10p&#39;</code>：这是一个 <code>sed</code> 编辑命令，其中 <code>10</code> 是地址（address），表示只对第10行进行操作；<code>p</code> 是打印命令，表示打印匹配的行。</li>
<li><code>file.txt</code>：这是要处理的文件名。</li>
</ul>
<p>##1-shell如何实现并发</p>
<ul>
<li>使用 <code>nohup</code> 命令可以避免命令在父进程结束时被终止。</li>
<li><strong>使用 <code>&amp;</code> 符号可以将命令放入后台执行，这样就可以在同一终端中运行多个命令。</strong></li>
<li>使用 <code>&amp;</code> 符号和 <code>jobs</code> 命令可以查看后台运行的命令，并使用 <code>fg</code> 命令将后台命令调到前台。</li>
<li><strong>使用 <code>&amp;&amp;</code> 和 <code>||</code> 符号可以实现顺序和选择执行。</strong></li>
<li>使用 <code>xargs</code> 命令可以实现管道化，并可以指定最大同时运行的进程数。</li>
</ul>
<p>##2-如何实现排他锁，防止重复执行</p>
<ul>
<li><p>在 shell 中，通常使用<strong>文件锁（flock</strong>）来模拟排他锁。例如，<code>flock -x -n /path/to/lockfile</code>。</p>
</li>
<li><p><strong>文件锁确保在同一时间只有一个进程可以访问特定的文件或目录。</strong></p>
</li>
</ul>
<h2 id="3-shell函数的特殊特点，例如和python对比"><a href="#3-shell函数的特殊特点，例如和python对比" class="headerlink" title="3-shell函数的特殊特点，例如和python对比"></a>3-shell函数的特殊特点，例如和python对比</h2><ul>
<li>Shell 函数通常用于封装重复使用的命令序列，而 Python 函数则可以包含更复杂的逻辑和返回值。</li>
<li>Shell 函数没有参数类型检查和默认参数，而 Python 函数可以。</li>
<li>Python 函数可以返回多个值，而 Shell 函数只能返回最后一个命令的输出。</li>
<li>Python 函数可以有文档字符串（docstrings），而 Shell 函数没有。</li>
</ul>
<h2 id="4-shell常用的命令有哪些"><a href="#4-shell常用的命令有哪些" class="headerlink" title="4-shell常用的命令有哪些"></a>4-shell常用的命令有哪些</h2><ul>
<li><code>ls</code>：列出目录内容。</li>
<li><code>cd</code>：改变目录。</li>
<li><code>pwd</code>：显示当前工作目录。</li>
<li><code>mkdir</code>：创建目录。</li>
<li><code>rm</code>：删除文件或目录。</li>
<li><code>mv</code>：移动或重命名文件或目录。</li>
<li><code>cp</code>：复制文件或目录。</li>
<li><code>cat</code>：查看文件内容。</li>
<li><code>grep</code>：搜索文本。</li>
<li><code>sed</code>：流编辑器。对grep检索的内容进行增删查改</li>
<li><code>awk</code>：强大的文本处理工具。可以利用正则表达式对文件进行一定的处理</li>
<li><code>find</code>：查找文件。</li>
<li><code>sort</code>：排序文本。</li>
<li><code>uniq</code>：去除文本中的重复行。</li>
</ul>
<h2 id="5-shell如何记录执行日志"><a href="#5-shell如何记录执行日志" class="headerlink" title="5-shell如何记录执行日志"></a>5-shell如何记录执行日志</h2><ul>
<li><strong>使用 <code>&gt;</code> 符号可以将命令的输出重定向到文件，从而记录日志。</strong></li>
<li>使用 <code>2&gt;</code> 符号可以将命令的错误输出重定向到文件。</li>
<li>使用 <code>&amp;&gt;</code> 符号可以将命令的输出和错误输出都重定向到文件。</li>
</ul>
<p>##6-shell如何控制异常</p>
<ul>
<li><strong>使用 <code>set -e</code> 命令可以设置 shell 环境为在遇到错误时退出。</strong></li>
<li>使用 <code>set -o pipefail</code> 命令可以确保管道中的任何命令失败都会导致整个管道失败。</li>
<li>使用 <code>try</code> 和 <code>catch</code> 结构可以模拟异常处理，虽然这不是真正的异常处理机制，但可以实现类似的效果。</li>
</ul>
<p>*****苏小妍专注于云计算、大数据和IT支撑系统的研发，目前就云计算和大数据技术的研发已经完成了基本产品布局，其“大云”系列产品正在不断更新迭代。</p>
<h1 id="测试开发"><a href="#测试开发" class="headerlink" title="测试开发"></a>测试开发</h1><p>我相信每一个面过测开岗位的牛油们，一定被问过这个问题吧。今天正好借此机会从我自身经历来介绍测试开发。<br>岗位内容：</p>
<p>这里主要分两种情况，1、新业务，2、稳定成熟的业务。<br>        新业务：</p>
<p>​               1、前中期可能有大量的功能测试，因为很多功能模块，上下游链路都不是很稳定可靠。<br>​               2、中期可以涉及比较多的性能测试，保证整条业务链路的性能。<br>​               3、会写相当多的技术沉淀文档，作为开拓者，很多问题都是全新的未知的。测试经验的积累对一个部门后续效率发展也是相当重要的。<br>​        旧业务：</p>
<p>​               1、适量的功能测试，测试的重 点和方向可参考之前相似的项目。<br>​               2、编写自动化测试用例，版本迭代很长时间后，整个软件体量就会很大。人工回归测试成本太大，所以需要自动化来提高效率。<br>​               3、针对业务开发工具，比如某一个业务测试时需要重复：创建活动、设置参数、修改不同路径下文本、修改上下游相关参数。可以开一个工具把这些都集合起来，只需在页面选择参数，点击执行即可。<br>​               4、公司发展过程中，技术也在不断的更新。有时候会涉及到代码的重构工作，需要学习新的语言来替换之前的代码，依次来提高效率。</p>
<p>未来发展：大厂测开和开发的薪资基本一致，进入公司之后一定要选择一个细分方向，例如：性能、自动化、安全、开发。在国外测试人员和开发人员的比重一般是1:2，所以以后国内企业想接轨国际势必要通过测试来提高产品质量。<br>个人成长：以技术为主管理为辅发展，后期也可以选择转型产品经理</p>
<p>学习网址：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1lTMMLqVXNuBspau6Vys4EA?pwd=q318#list/path=%2F">https://pan.baidu.com/s/1lTMMLqVXNuBspau6Vys4EA?pwd=q318#list/path=%2F</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">梦境引导者</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/01/26/JOB-md/">http://example.com/2025/01/26/JOB-md/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">过去的过去是过往，未来的未来是遥不可及</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java-knowledge-update/">Java_knowledge-update</a></div><div class="post-share"><div class="social-share" data-image="/img/5.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">梦境引导者</div><div class="author-info-description">憧憬希望，累积满心的欣喜</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://blog.csdn.net/qq_52983712?spm=1018.2226.3001.5343" target="_blank" title="csdn"><i class="fa fa-book-open"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=728831102&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:2830072717@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java"><span class="toc-text">Java</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-Java-%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%9F-%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%88%86%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B-%EF%BC%9F%E5%86%85%E9%83%A8%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%82%B9%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-text">1、什么是 Java 内部类？ 内部类的分类有哪些 ？内部类有哪些优点和应用场景？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%EF%BC%9F%E8%AF%B4%E8%AF%B4%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E3%80%81%E5%BA%94%E2%BD%A4%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-text">2、什么是反射机制？说说反射机制的优缺点、应⽤场景？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E8%AF%B4%E8%AF%B4-Java-%E4%B8%AD%E5%A4%9A%E6%80%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">3、说说 Java 中多态实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-text">多态的优势</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%89%E4%B8%AA%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5-%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%8C%E5%8F%AF%E8%A7%81%E6%80%A7%EF%BC%8C%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-text">多线程编程中的三个核心概念:原子性，可见性，有序性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-text">如何实现线程安全</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E5%88%86%E6%94%AF%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-text">查看当前分支的情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%88%86%E6%94%AF"><span class="toc-text">创建分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF%E5%92%8C%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB"><span class="toc-text">查看本地分支和远程分支对应关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%92%A4%E5%9B%9E%E4%BF%AE%E6%94%B9"><span class="toc-text">撤回修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E5%B9%B6push"><span class="toc-text">创建远程分支并push</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%89%E5%8F%96%E5%BD%93%E5%89%8D%E5%88%86%E6%94%AF%E7%9A%84%E6%9C%80%E6%96%B0%E4%BB%A3%E7%A0%81"><span class="toc-text">拉取当前分支的最新代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84-starter-%E7%BB%84%E4%BB%B6"><span class="toc-text">常见的 starter 组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-IOC"><span class="toc-text">Spring IOC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-AOP"><span class="toc-text">Spring AOP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker"><span class="toc-text">docker</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#completableFuture"><span class="toc-text">completableFuture</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ"><span class="toc-text">RabbitMQ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL%E8%B0%83%E4%BC%98"><span class="toc-text">SQL调优</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Nacos%E5%92%8CEureka%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">Nacos和Eureka的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3"><span class="toc-text">端口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81Java-%E4%B8%AD-IO-%E6%B5%81%E5%88%86%E4%B8%BA%E5%87%A0%E7%A7%8D"><span class="toc-text">4、Java 中 IO 流分为几种?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-text">5、守护线程是什么？用什么方法实现守护线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81Threadlocal"><span class="toc-text">6、Threadlocal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81ThreadLocal%E4%B8%8ESynchronized%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">7、ThreadLocal与Synchronized的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">8、线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="toc-text">9、数据库连接池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E8%AF%B7%E4%BD%A0%E4%BB%8B%E7%BB%8D%E4%B8%8B-JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%8C%E5%88%86%E4%B8%BA%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%9F%9F%EF%BC%9F%E5%90%84%E5%8C%BA%E5%9F%9F%E7%9A%84%E4%BD%9C%E2%BD%A4%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">10、请你介绍下 JVM 内存模型，分为哪些区域？各区域的作⽤是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%BC%8F%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E2%BD%A4%EF%BC%9F"><span class="toc-text">11、什么是双亲委派模式？有什么作⽤？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81%E6%80%8E%E4%B9%88%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%BC%8F"><span class="toc-text">11、怎么打破双亲委派模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81%E5%B8%B8%E2%BB%85%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E6%9C%89%E2%BC%8F%E7%A7%8D%E7%B1%BB%E5%9E%8B%EF%BC%9F%E4%BB%96%E4%BB%AC%E5%AF%B9%E5%BA%94%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">12、常⻅的垃圾回收算法有⼏种类型？他们对应的优缺点是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-text">引用计数法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-text">可达性分析算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E2%BE%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">13、并发和并⾏有什么区别？同步和异步有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-BIO%E3%80%81NIO%E3%80%81AIO%EF%BC%9F%E5%86%99%E7%9A%84%E4%B8%8D%E5%A5%BD"><span class="toc-text">14、什么是 BIO、NIO、AIO？写的不好</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E2%BD%A3%E5%91%BD%E5%91%A8%E6%9C%9F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E7%BA%BF%E7%A8%8B%E6%9C%89%E2%BC%8F%E7%A7%8D%E7%8A%B6%E6%80%81%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8A%E4%B8%8B%E2%BD%82%E5%88%87%E6%8D%A2%EF%BC%9F"><span class="toc-text">15、线程的⽣命周期是什么，线程有⼏种状态，什么是上下⽂切换？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%E3%80%81%E7%BA%BF%E7%A8%8B"><span class="toc-text">15、线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16%E3%80%81synchronized-%E5%85%B3%E9%94%AE%E5%AD%97%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E2%BD%A4%EF%BC%9F"><span class="toc-text">16、synchronized 关键字是什么，有什么作⽤？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8F%AF%E4%BB%A5%E5%88%86%E4%B8%BA%E5%93%AA%E2%BC%8F%E7%B1%BB%EF%BC%9F%E2%BC%80%E5%85%B1%E6%9C%89%E5%A4%9A%E5%B0%91%E7%A7%8D%E4%B8%BB%E6%B5%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-text">17、设计模式可以分为哪⼏类？⼀共有多少种主流的设计模式？场景？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E2%BC%AF%E2%BC%9A%E6%A8%A1%E5%BC%8F%EF%BC%9F%E4%BD%BF%E2%BD%A4%E2%BC%AF%E2%BC%9A%E6%A8%A1%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F%E2%BC%AF%E2%BC%9A%E6%A8%A1%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%E5%88%86%E7%B1%BB%EF%BC%9F%E5%90%84-%E2%BE%83%E7%9A%84%E5%BA%94%E2%BD%A4%E5%9C%BA%E6%99%AF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">18、什么是⼯⼚模式？使⽤⼯⼚模式有什么好处？⼯⼚模式有哪些分类？各 ⾃的应⽤场景是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0%E5%92%8C%E4%BD%BF%E2%BD%A4%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-text">19、设计模式是什么？为什么要学习和使⽤设计模式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%9F%E4%BD%BF%E2%BD%A4%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E2%BD%A4%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E2%BD%85%E5%BC%8F%EF%BC%9F%E5%90%84%E2%BE%83%E7%9A%84%E5%BA%94%E2%BD%A4%E5%9C%BA%E6%99%AF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">20、什么是单例模式？使⽤单例模式有什么好处？有哪些常⽤的单例模式实现⽅式？各⾃的应⽤场景是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21%E3%80%81JVM%E5%AE%9E%E8%B7%B5"><span class="toc-text">21、JVM实践</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23%E3%80%81%E9%9D%9E%E5%8F%97%E6%A3%80%E5%BC%82%E5%B8%B8%E5%92%8C%E5%8F%97%E6%A3%80%E5%BC%82%E5%B8%B8"><span class="toc-text">23、非受检异常和受检异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24%E3%80%81%E8%AE%B2%E4%B8%80%E4%B8%8Bwait%E5%92%8Cnotify%E8%BF%99%E4%B8%AA%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9C%A8synchronized"><span class="toc-text">24、讲一下wait和notify这个为什么要在synchronized?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9B%BA%E5%AE%9A%E5%A4%A7%E5%B0%8F%E5%86%85%E5%AD%98%E6%B1%A0%EF%BC%88Fixed-Size-Memory-Pool%EF%BC%89"><span class="toc-text">1. 固定大小内存池（Fixed-Size Memory Pool）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8F%AF%E5%8F%98%E5%A4%A7%E5%B0%8F%E5%86%85%E5%AD%98%E6%B1%A0%EF%BC%88Variable-Size-Memory-Pool%EF%BC%89"><span class="toc-text">2. 可变大小内存池（Variable-Size Memory Pool）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AF%B9%E8%B1%A1%E6%B1%A0%EF%BC%88Object-Pool%EF%BC%89"><span class="toc-text">3. 对象池（Object Pool）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%9F%BA%E4%BA%8E%E9%A1%B5%E7%9A%84%E5%86%85%E5%AD%98%E6%B1%A0%EF%BC%88Page-Based-Memory-Pool%EF%BC%89"><span class="toc-text">4. 基于页的内存池（Page-Based Memory Pool）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5"><span class="toc-text">四舍五入</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80"><span class="toc-text">计算机基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%BD%91"><span class="toc-text">计网</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E7%AE%80%E8%BF%B0%E8%AE%A1%E7%AE%97%E6%9C%BA%E2%BD%B9%E7%BB%9C%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%90%84%E2%BE%83%E7%9A%84%E4%BD%9C%E2%BD%A4%EF%BC%9F"><span class="toc-text">1、简述计算机⽹络七层模型和各⾃的作⽤？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81HTTP-%E6%98%AF%E5%93%AA%E2%BC%80%E5%B1%82%E7%9A%84%E5%8D%8F%E8%AE%AE%EF%BC%9F%E7%AE%80%E8%BF%B0%E5%AE%83%E7%9A%84%E4%BD%9C%E2%BD%A4%EF%BC%9F"><span class="toc-text">2、HTTP 是哪⼀层的协议？简述它的作⽤？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81HTTP-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E2%BB%85%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81%EF%BC%9F"><span class="toc-text">3、HTTP 有哪些常⻅的状态码？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81TCP-%E5%92%8C-UDP-%E5%8D%8F%E8%AE%AE%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%88%86%E5%88%AB%E9%80%82%E2%BD%A4%E4%BA%8E%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF"><span class="toc-text">4、TCP 和 UDP 协议有什么区别，分别适⽤于什么场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E7%AE%80%E8%BF%B0-TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E6%B5%81%E7%A8%8B%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-text">6、简述 TCP 三次握手、四次挥手的流程？为什么需要三次握手？为什么需要四次挥手</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81HTTP%E5%8D%8F%E8%AE%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%A0%E7%8A%B6%E6%80%81%E7%9A%84%EF%BC%9F%E5%A6%82%E4%BD%95%E8%AE%A9HTTP%E2%80%9C%E6%9C%89%E7%8A%B6%E6%80%81%E2%80%9D%EF%BC%9F"><span class="toc-text">7、HTTP协议为什么是无状态的？如何让HTTP“有状态”？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81session%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">8、session的工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81HTTP%E5%92%8CTCP%E7%9A%84%E8%81%94%E7%B3%BB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">11、HTTP和TCP的联系是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81Https%E7%9A%84%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%EF%BC%88HyperText-Transfer-Protocol-over-Secure-Socket-Layer%EF%BC%89"><span class="toc-text">12、Https的握手过程（HyperText Transfer Protocol over Secure Socket Layer）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E3%80%81DNS%E8%A7%A3%E6%9E%90"><span class="toc-text">14、DNS解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%E3%80%81UDP%E7%9A%84%E5%A4%9A%E6%92%AD%E5%92%8C%E5%B9%BF%E6%92%AD"><span class="toc-text">15、UDP的多播和广播</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-text">操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%EF%BC%9F%E5%AE%83%E4%BB%AC%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB%EF%BC%9F"><span class="toc-text">1、什么是进程和线程？它们有哪些区别和联系？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E6%AD%BB%E9%94%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E9%A2%84%E9%98%B2%E5%92%8C%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="toc-text">2、死锁是什么？如何预防和避免死锁？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E7%BA%BF%E7%A8%8B%E9%97%B4%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%9A%E4%BF%A1%E2%BD%85%E5%BC%8F%EF%BC%9F"><span class="toc-text">3、线程间有哪些通信⽅式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%B6%E6%8B%B7%E2%BB%89%EF%BC%9F%E8%AF%B4%E2%BC%80%E8%AF%B4%E4%BD%A0%E5%AF%B9%E9%9B%B6%E6%8B%B7%E2%BB%89%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-text">4、什么是零拷⻉？说⼀说你对零拷⻉的理解？*</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Linux-%E4%B8%AD%E7%9A%84%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%92%8C%E8%BD%AF%E8%BF%9E%E6%8E%A5%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E2%BC%86%E8%80%85%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">1、Linux 中的硬链接和软连接是什么，⼆者有什么区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E9%93%BE%E6%8E%A5%EF%BC%88Hard-Link%EF%BC%89%E5%92%8C%E8%BD%AF%E9%93%BE%E6%8E%A5%EF%BC%88Soft-Link%EF%BC%89%EF%BC%9A"><span class="toc-text">硬链接（Hard Link）和软链接（Soft Link）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%A1%AC%E9%93%BE%E6%8E%A5%EF%BC%88Hard-Link%EF%BC%89%EF%BC%9A"><span class="toc-text">1. 硬链接（Hard Link）：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-text">特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-text">创建方式：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-text">示例：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%BD%AF%E9%93%BE%E6%8E%A5%EF%BC%88Soft-Link%EF%BC%89%EF%BC%9A"><span class="toc-text">2. 软链接（Soft Link）：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A-1"><span class="toc-text">特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%EF%BC%9A-1"><span class="toc-text">创建方式：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-1"><span class="toc-text">示例：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8C%BA%E5%88%AB%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">3. 区别总结：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-text">实际使用场景：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81CC-%E6%94%BB%E5%87%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BB%80%E4%B9%88%E5%8F%AB-DDOS-%E6%94%BB%E5%87%BB%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E2%BD%B9%E7%AB%99%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B3%A8%E2%BC%8A%EF%BC%9F"><span class="toc-text">2、CC 攻击是什么？什么叫 DDOS 攻击？什么是⽹站数据库注⼊？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%A6%82%E4%BD%95%E5%9C%A8-Linux-%E4%B8%AD%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%E4%BD%BF%E2%BD%A4%E6%83%85%E5%86%B5%EF%BC%9F%E2%BD%90%E5%A6%82%E5%86%85%E5%AD%98%E3%80%81CPU%E3%80%81%E2%BD%B9%E7%BB%9C%E7%AB%AF%E5%8F%A3%E3%80%82"><span class="toc-text">3、如何在 Linux 中查看系统资源使⽤情况？⽐如内存、CPU、⽹络端口。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81Linux%E7%9A%84swap-%E7%B1%BB%E4%BC%BC%E4%BA%8EWindows%E7%9A%84%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-text">4、Linux的swap  (类似于Windows的虚拟内存)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#swap%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">swap的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#swap%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">swap的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8Bswap%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5"><span class="toc-text">查看swap使用情况</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0%E3%80%81%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-text">0、介绍一下红黑树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81ConcurrentHashMap%E5%92%8CHashtable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">1、ConcurrentHashMap和Hashtable的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81LinkedList%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E5%AE%9E%E7%8E%B0RandomAccess%E6%8E%A5%E5%8F%A3%EF%BC%9F"><span class="toc-text">2、LinkedList为什么不能实现RandomAccess接口？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81ArrayList%E4%B8%8ELinkedList%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">3、ArrayList与LinkedList区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81ArrayList%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-text">4、ArrayList的扩容机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81Comparable-%E5%92%8C-Comparator-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">5、Comparable 和 Comparator 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E6%97%A0%E5%BA%8F%E6%80%A7%E5%92%8C%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E6%80%A7%E7%9A%84%E5%90%AB%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">6、无序性和不可重复性的含义是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E6%AF%94%E8%BE%83HashSet%E3%80%81LinkedHashSet%E5%92%8CTreeSet%E4%B8%89%E8%80%85%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-text">7、比较HashSet、LinkedHashSet和TreeSet三者的异同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81Queue-%E4%B8%8E-Deque-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">8、Queue 与 Deque 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81ArrayDeque-%E4%B8%8E-LinkedList-%E6%A8%A1%E6%8B%9F%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">9、ArrayDeque 与 LinkedList(模拟栈、队列) 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%EF%BC%88BlockingQueue-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97-%E6%98%AF%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%A3%EF%BC%8C%E7%BB%A7%E6%89%BF%E8%87%AA-Queue%EF%BC%89"><span class="toc-text">11、阻塞队列（BlockingQueue (阻塞队列)是一个接口，继承自 Queue）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81%E5%8E%9F%E7%94%9F%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88%E7%B1%BB"><span class="toc-text">12、原生的线程安全的集合类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81HashMap-%E5%92%8C-Hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">13、HashMap 和 Hashtable 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E3%80%81HashMap%E5%92%8CHashSet%E5%8C%BA%E5%88%AB"><span class="toc-text">14、HashMap和HashSet区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%E3%80%81HashMap%E5%92%8CTreeMap%E5%8C%BA%E5%88%AB"><span class="toc-text">15、HashMap和TreeMap区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17%E3%80%81HashMap%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C%E5%AF%BC%E8%87%B4%E6%AD%BB%E5%BE%AA%E7%8E%AF%E9%97%AE%E9%A2%98"><span class="toc-text">17、HashMap多线程操作导致死循环问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18%E3%80%81HashMap-%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF-2-%E7%9A%84%E5%B9%82%E6%AC%A1%E6%96%B9"><span class="toc-text">18、HashMap 的长度为什么是 2 的幂次方</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19%E3%80%81HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-text">19、HashMap为什么线程不安全？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20%E3%80%81HashMap-%E5%B8%B8%E8%A7%81%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-text">20、HashMap 常见的遍历方式?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21%E3%80%81ConcurrentHashMap%E4%B8%BA%E4%BB%80%E4%B9%88key%E5%92%8Cvalue%E4%B8%8D%E8%83%BD%E4%B8%BAnull%EF%BC%9F"><span class="toc-text">21、ConcurrentHashMap为什么key和value不能为null？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22%E3%80%81ConcurrentHashMap%E8%83%BD%E4%BF%9D%E8%AF%81%E5%A4%8D%E5%90%88%E6%93%8D%E4%BD%9C%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E5%90%97%EF%BC%9F"><span class="toc-text">22、ConcurrentHashMap能保证复合操作的原子性吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23%E3%80%81%E6%8B%93%E5%B1%95"><span class="toc-text">23、拓展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89Collection%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">1）Collection工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E6%93%8D%E4%BD%9C"><span class="toc-text">排序操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%EF%BC%8C%E6%9B%BF%E6%8D%A2%E6%93%8D%E4%BD%9C"><span class="toc-text">查找，替换操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%8D%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-text">同步控制（不重要）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AF%B9%E4%BA%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84"><span class="toc-text">1. 对于基本数据类型数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AF%B9%E4%BA%8E%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84"><span class="toc-text">2. 对于对象类型数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B0%8F%E8%A7%84%E6%A8%A1%E6%95%B0%E7%BB%84%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-text">3. 小规模数组的优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL"><span class="toc-text">MySQL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%EF%BC%9F%E8%AE%B2%E2%BC%80%E4%B8%8B%E4%BA%8B%E5%8A%A1%E7%9A%84-ACID-%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-text">1、什么是数据库事务？讲⼀下事务的 ACID 特性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E2%BD%A4%EF%BC%8C%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E9%80%82%E5%90%88%E4%BD%BF%E2%BD%A4%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-text">2、数据库索引是什么，有什么作⽤，什么场景适合使⽤索引？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81MySQL-%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9FB-%E6%A0%91%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8CB-%E6%A0%91%E5%92%8C-B-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C-%E4%B8%BA%E4%BB%80%E4%B9%88-MySQL-%E8%A6%81%E2%BD%A4-B-%E6%A0%91%EF%BC%9F"><span class="toc-text">3、MySQL 中的索引是怎么实现的？B+ 树是什么，B 树和 B+ 树的区别， 为什么 MySQL 要⽤ B+ 树？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81MySQL-%E2%BD%80%E6%8C%81%E5%93%AA%E4%BA%9B%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%EF%BC%9F%E9%BB%98%E8%AE%A4%E4%BD%BF%E2%BD%A4%E5%93%AA%E4%B8%AA%EF%BC%9FMyISAM-%E5%92%8C-InnoDB-%E5%BC%95%E6%93%8E%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%EF%BC%9F"><span class="toc-text">4、MySQL ⽀持哪些存储引擎？默认使⽤哪个？MyISAM 和 InnoDB 引擎有什么区别，如何选择？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E6%84%8F%E5%90%91%E9%94%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E2%BD%A4%EF%BC%9F%E5%AE%83%E6%98%AF%E8%A1%A8%E7%BA%A7%E9%94%81%E8%BF%98%E6%98%AF%E2%BE%8F%E7%BA%A7%E9%94%81%EF%BC%9F"><span class="toc-text">5、意向锁是什么？有什么作⽤？它是表级锁还是⾏级锁？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81InnoDB%E6%9C%89%E5%93%AA%E5%87%A0%E7%B1%BB%E8%A1%8C%E9%94%81%EF%BC%9F"><span class="toc-text">6、InnoDB有哪几类行锁？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81MySQL-%E6%97%A5%E5%BF%97%E6%9C%89%E4%BA%86%E8%A7%A3%E8%BF%87%E5%90%97%EF%BC%9Fbinlog%E3%80%81redolog%E3%80%81undolog-%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%E3%80%81%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">7、MySQL 日志有了解过吗？binlog、redolog、undolog 分别有什么作用、有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81MVCC-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9FInnoDB-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-MVCC-%E6%9C%BA%E5%88%B6%E7%9A%84%EF%BC%9F"><span class="toc-text">8、MVCC 是什么？InnoDB 是如何实现 MVCC 机制的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E5%92%8C%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E8%AE%B2%E2%BC%80%E4%B8%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99%E3%80%82"><span class="toc-text">9、覆盖索引和联合索引是什么？讲⼀下索引的最左前缀匹配原则。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81MySQL%E6%9F%A5%E8%AF%A2%E6%85%A2-%E9%99%A4%E4%BA%86%E7%B4%A2%E5%BC%95%E8%BF%98%E8%83%BD%E5%9B%A0%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">10、MySQL查询慢,除了索引还能因为什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81Buffer-Pool-%E6%94%BE%E7%9A%84%E6%98%AF%E6%95%B0%E6%8D%AE%E9%A1%B5"><span class="toc-text">3、Buffer Pool(放的是数据页)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%8C%83%E5%BC%8F%EF%BC%881NF%EF%BC%89"><span class="toc-text">第一范式（1NF）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F%EF%BC%882NF%EF%BC%89"><span class="toc-text">第二范式（2NF）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F%EF%BC%883NF%EF%BC%89"><span class="toc-text">第三范式（3NF）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SSM%E2%80%94-Spring%E3%80%81SpringMVC%E3%80%81MyBatis-SpringBoot"><span class="toc-text">SSM—&gt;Spring、SpringMVC、MyBatis   +    SpringBoot</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring"><span class="toc-text">Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Bean"><span class="toc-text">Spring Bean</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">1）是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89-Component-%E5%92%8C-Bean-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">2）@Component 和 @Bean 的区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%89Bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">4）Bean的作用域是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%EF%BC%89bean%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97"><span class="toc-text">5）bean是线程安全的吗?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%EF%BC%89Bean%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98"><span class="toc-text">8）Bean的循环依赖问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Aop-%E4%BD%BF%E7%94%A8%E8%BF%87%E5%90%97%EF%BC%9F%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-text">Spring Aop,使用过吗？怎么使用？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89Spring-AOP%E5%92%8CAspectJ-AOP%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">1）Spring AOP和AspectJ AOP有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89AspectJ%E5%AE%9A%E4%B9%89%E7%9A%84%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B"><span class="toc-text">2）AspectJ定义的通知类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E5%A4%9A%E4%B8%AA%E5%88%87%E9%9D%A2%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%EF%BC%9F"><span class="toc-text">3）多个切面的执行顺序如何控制？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-%E4%BA%8B%E5%8A%A1"><span class="toc-text">Spring 事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89Spring%E5%AE%9E%E7%8E%B0%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">1）Spring实现事务的两种方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7"><span class="toc-text">2）事务属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89Spring%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA"><span class="toc-text">3）Spring有哪几种事务传播行为</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%89%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">4）隔离级别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%EF%BC%89Spring-Data-JPA%EF%BC%886%EF%BC%8C7%E6%B2%A1%E6%9C%89%E6%8E%A5%E8%A7%A6%E8%BF%87%EF%BC%89"><span class="toc-text">6）Spring Data JPA（6，7没有接触过）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%89%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8JPA%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%9D%9E%E6%8C%81%E4%B9%85%E5%8C%96%E4%B8%80%E4%B8%AA%E5%AD%97%E6%AE%B5"><span class="toc-text">1）如何使用JPA在数据库中非持久化一个字段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-JPA%E7%9A%84%E5%AE%A1%E8%AE%A1%E5%8A%9F%E8%83%BD%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-text">2)JPA的审计功能是做什么的？有什么用？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%89%E5%AE%9E%E4%BD%93%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E9%94%AE%E5%85%B3%E7%B3%BB%E6%B3%A8%E8%A7%A3%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">3）实体之间的关键关系注解有哪些？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%EF%BC%89Spring-Security"><span class="toc-text">7）Spring Security</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%89%E6%9C%89%E5%93%AA%E4%BA%9B%E6%8E%A7%E5%88%B6%E8%AF%B7%E6%B1%82%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">1）有哪些控制请求访问权限的方法？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%89%E6%9C%89%E5%93%AA%E4%BA%9B%E6%8E%A7%E5%88%B6%E8%AF%B7%E6%B1%82%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">2）有哪些控制请求访问权限的方法？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%89%E6%9C%89%E5%93%AA%E4%BA%9B%E6%8E%A7%E5%88%B6%E8%AF%B7%E6%B1%82%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">3）有哪些控制请求访问权限的方法？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E6%9B%B4%E6%8D%A2%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8%E7%9A%84%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95"><span class="toc-text">4)如何优雅更换系统使用的加密算法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringMVC"><span class="toc-text">SpringMVC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1%EF%BC%89-%E5%AF%B9SpringMVC%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">1）*对SpringMVC的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MyBatis"><span class="toc-text">MyBatis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1%EF%BC%89-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">1）#{}和${}的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%EF%BC%89xml-%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E4%B8%AD%EF%BC%8C%E9%99%A4%E4%BA%86%E5%B8%B8%E8%A7%81%E7%9A%84-select%E3%80%81insert%E3%80%81update%E3%80%81delete-%E6%A0%87%E7%AD%BE%E4%B9%8B%E5%A4%96%EF%BC%8C%E8%BF%98%E6%9C%89%E5%93%AA%E4%BA%9B%E6%A0%87%E7%AD%BE"><span class="toc-text">2）xml 映射文件中，除了常见的 select、insert、update、delete 标签之外，还有哪些标签?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%EF%BC%89MyBatis-%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%88%86%E9%A1%B5%E7%9A%84%EF%BC%9F%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">4）MyBatis 是如何进行分页的？分页插件的原理是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%EF%BC%89%E7%AE%80%E8%BF%B0-MyBatis-%E7%9A%84%E6%8F%92%E4%BB%B6%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E6%8F%92%E4%BB%B6"><span class="toc-text">5）简述 MyBatis 的插件运行原理，以及如何编写一个插件**</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%EF%BC%89MyBatis-%E6%89%A7%E8%A1%8C%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%EF%BC%8C%E8%83%BD%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BB%E9%94%AE%E5%88%97%E8%A1%A8%E5%90%97%EF%BC%9F"><span class="toc-text">6）MyBatis 执行批量插入，能返回数据库主键列表吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%EF%BC%89MyBatis-%E5%8A%A8%E6%80%81-sql-%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8A%A8%E6%80%81-sql%EF%BC%9F%E8%83%BD%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E5%8A%A8%E6%80%81-sql-%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E4%B8%8D%EF%BC%9F"><span class="toc-text">7）MyBatis 动态 sql 是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%EF%BC%89MyBatis-%E6%98%AF%E5%A6%82%E4%BD%95%E5%B0%86-sql-%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%B0%81%E8%A3%85%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E5%B9%B6%E8%BF%94%E5%9B%9E%E7%9A%84%EF%BC%9F%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%98%A0%E5%B0%84%E5%BD%A2%E5%BC%8F%EF%BC%9F"><span class="toc-text">8）MyBatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%EF%BC%89MyBatis-%E8%83%BD%E6%89%A7%E8%A1%8C%E4%B8%80%E5%AF%B9%E4%B8%80%E3%80%81%E4%B8%80%E5%AF%B9%E5%A4%9A%E7%9A%84%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%E5%90%97%EF%BC%9F%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">9）MyBatis 能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%EF%BC%89MyBatis-%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%EF%BC%9F%E5%A6%82%E6%9E%9C%E6%94%AF%E6%8C%81%EF%BC%8C%E5%AE%83%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">10）MyBatis 是否支持延迟加载？如果支持，它的实现原理是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%EF%BC%89MyBatis-%E7%9A%84-xml-%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E4%B8%AD%EF%BC%8C%E4%B8%8D%E5%90%8C%E7%9A%84-xml-%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%EF%BC%8Cid-%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%A4%8D%EF%BC%9F"><span class="toc-text">11）MyBatis 的 xml 映射文件中，不同的 xml 映射文件，id 是否可以重复？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%EF%BC%89MyBatis-%E4%B8%AD%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E6%89%B9%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-text">12）MyBatis 中如何执行批处理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%EF%BC%89MyBatis-%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B-Executor-%E6%89%A7%E8%A1%8C%E5%99%A8%EF%BC%9F%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">13）MyBatis 都有哪些 Executor 执行器？它们之间的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%EF%BC%89MyBatis-%E4%B8%AD%E5%A6%82%E4%BD%95%E6%8C%87%E5%AE%9A%E4%BD%BF%E7%94%A8%E5%93%AA%E4%B8%80%E7%A7%8D-Executor-%E6%89%A7%E8%A1%8C%E5%99%A8%EF%BC%9F"><span class="toc-text">14）MyBatis 中如何指定使用哪一种 Executor 执行器？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9SqlsessionFactory%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">14) 谈谈你对SqlsessionFactory的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%EF%BC%89%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9SqiSession%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">15）谈谈你对SqiSession的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16%EF%BC%89MyBatis-%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%98%A0%E5%B0%84-Enum-%E6%9E%9A%E4%B8%BE%E7%B1%BB%EF%BC%9F"><span class="toc-text">16）MyBatis 是否可以映射 Enum 枚举类？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17%EF%BC%89MyBatis-%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E4%B8%AD%EF%BC%8C%E5%A6%82%E6%9E%9C-A-%E6%A0%87%E7%AD%BE%E9%80%9A%E8%BF%87-include-%E5%BC%95%E7%94%A8%E4%BA%86-B-%E6%A0%87%E7%AD%BE%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%8C%E8%AF%B7%E9%97%AE%EF%BC%8CB-%E6%A0%87%E7%AD%BE%E8%83%BD%E5%90%A6%E5%AE%9A%E4%B9%89%E5%9C%A8-A-%E6%A0%87%E7%AD%BE%E7%9A%84%E5%90%8E%E9%9D%A2%EF%BC%8C%E8%BF%98%E6%98%AF%E8%AF%B4%E5%BF%85%E9%A1%BB%E5%AE%9A%E4%B9%89%E5%9C%A8-A-%E6%A0%87%E7%AD%BE%E7%9A%84%E5%89%8D%E9%9D%A2%EF%BC%9F"><span class="toc-text">17）MyBatis 映射文件中，如果 A 标签通过 include 引用了 B 标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在 A 标签的前面？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18%EF%BC%89%E7%AE%80%E8%BF%B0-MyBatis-%E7%9A%84-xml-%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E5%92%8C-MyBatis-%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%97%B4%E7%9A%84%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-text">18）简述 MyBatis 的 xml 映射文件和 MyBatis 内部数据结构之间的映射关系？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20%EF%BC%89Mybatis%E7%9A%84%E4%B8%80%E7%BA%A7%E3%80%81%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%EF%BC%8C%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-text">20）Mybatis的一级、二级缓存，何时使用？有什么缺点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringBoot"><span class="toc-text">SpringBoot</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Spring-Boot-%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-text">1. Spring Boot 有哪些特点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E2%80%9C-SpringBootApplication%E2%80%9D%E6%B3%A8%E8%A7%A3%E5%9C%A8%E5%86%85%E9%83%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84"><span class="toc-text">2、“@SpringBootApplication”注解在内部是如何工作的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BB%80%E4%B9%88%E6%98%AF-Bean%EF%BC%9F"><span class="toc-text">3. 什么是 Bean？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Spring-Boot-%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9F"><span class="toc-text">7、 如何使用 Spring Boot 连接数据库？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis"><span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-Redis%EF%BC%9FRedis-%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9%EF%BC%9FRedis-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E2%BB%85%E7%9A%84%E5%BA%94%E2%BD%A4%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-text">1、什么是 Redis？Redis 有哪些特点？Redis 有哪些常⻅的应⽤场景？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E8%AE%B2%E2%BC%80%E4%B8%8B-Redis-%E7%9A%84%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%EF%BC%8CIO-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E2%BD%A4%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">2、讲⼀下 Redis 的单线程模型，IO 多路复⽤是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%A5%97%E6%8E%A5%E5%AD%97%EF%BC%88sockets%EF%BC%89%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">1.2 套接字（sockets）是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-I-O%E8%B5%84%E6%BA%90%E4%B8%AD%E7%9A%84%E7%AE%A1%E9%81%93%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F"><span class="toc-text">1.3 I&#x2F;O资源中的管道是什么意思？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-Unix%E5%92%8C%E7%B1%BBUnix%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F"><span class="toc-text">1.4 Unix和类Unix操作系统是什么意思？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%9C%BA%E5%88%B6%E4%B8%ADselect%E3%80%81poll%E3%80%81epoll%E8%BF%99%E4%BA%9B%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">1.6 IO多路复用机制中select、poll、epoll这些系统调用分别是什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81Redis-%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E8%AF%B4%E8%AF%B4%E5%90%84%E2%BE%83%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%92%8C%E5%BA%94%E2%BD%A4%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-text">5、Redis 的持久化机制有哪些？说说各⾃的优缺点和应⽤场景？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E8%AE%B2%E2%BC%80%E4%B8%8B-Redis-%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6%E3%80%81%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%EF%BC%9F"><span class="toc-text">7、讲⼀下 Redis 中的内存淘汰机制、有哪些内存淘汰策略？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81Redis-6-0-%E4%B9%8B%E5%90%8E%E4%B8%BA%E4%BD%95%E5%BC%95%E5%85%A5%E4%BA%86%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F6-0-%E4%B9%8B%E5%89%8D%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BD%BF%E2%BD%A4%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-text">8、Redis 6.0 之后为何引入了多线程？6.0 之前为什么不使⽤多线程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81Redis%E4%B8%8EMySQL%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%EF%BC%9F"><span class="toc-text">13、Redis与MySQL双写一致性如何保证？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E3%80%81%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-text">14、缓存穿透</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-text">15、缓存雪崩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-text">16、缓存击穿</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%80%BB%E8%BE%91"><span class="toc-text">黑马点评逻辑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17%E3%80%81Redis%E7%9A%84%E8%B7%B3%E8%A1%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%8C%E6%80%A7%E8%83%BD%E5%A6%82%E4%BD%95%EF%BC%8C%E5%B1%82%E9%AB%98%E6%80%8E%E4%B9%88%E7%94%9F%E6%88%90%E7%9A%84"><span class="toc-text">17、Redis的跳表是怎么实现的，性能如何，层高怎么生成的</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F"><span class="toc-text">分布式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81Dubbo-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%98%AF%E5%90%A6%E4%BA%86%E8%A7%A3%E8%BF%87%E5%AE%83%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%9F"><span class="toc-text">3、Dubbo 是什么？是否了解过它的架构设计？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-RPC%EF%BC%9F%E2%BD%AC%E5%89%8D%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E2%BB%85%E7%9A%84-RPC-%E6%A1%86%E6%9E%B6%EF%BC%9F%E5%AE%9E%E7%8E%B0-RPC-%E6%A1%86%E6%9E%B6%E7%9A%84%E6%A0%B8%E2%BC%BC%E5%8E%9F%E7%90%86-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">5、什么是 RPC？⽬前有哪些常⻅的 RPC 框架？实现 RPC 框架的核⼼原理 是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E2%BC%80%E4%B8%AA%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%EF%BC%9F"><span class="toc-text">6、什么是注册中心？如何实现⼀个注册中心？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84-BASE-%E7%90%86%E8%AE%BA%EF%BC%8C%E5%AE%83%E4%B8%8E-CAP-%E7%90%86%E8%AE%BA%E6%9C%89%E4%BB%80%E4%B9%88%E8%81%94%E7%B3%BB%EF%BC%9F"><span class="toc-text">7、什么是分布式的 BASE 理论，它与 CAP 理论有什么联系？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">8、分布式事务解决方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81%E5%B9%82%E7%AD%89"><span class="toc-text">9、幂等</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6"><span class="toc-text">10、分布式任务调度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-text">11、分布式事务</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-text">消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E6%B6%88%E6%81%AF%E7%9A%84%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9"><span class="toc-text">5、消息的重复消费</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81RabbitMQ-%E6%AD%BB%E4%BF%A1%E4%BA%A4%E6%8D%A2%E6%9C%BA-%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97"><span class="toc-text">6、RabbitMQ 死信交换机&#x2F;延迟队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-text">7、消息堆积怎么解决？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81kafka%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-text">9、kafka实现高性能的设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-JWT-%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-text">1. JWT 的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-Header"><span class="toc-text">1.1 Header</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-Payload"><span class="toc-text">1.2 Payload</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-Signature"><span class="toc-text">1.3 Signature</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringCloud"><span class="toc-text">SpringCloud</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Shell"><span class="toc-text">Shell</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-shell%E5%87%BD%E6%95%B0%E7%9A%84%E7%89%B9%E6%AE%8A%E7%89%B9%E7%82%B9%EF%BC%8C%E4%BE%8B%E5%A6%82%E5%92%8Cpython%E5%AF%B9%E6%AF%94"><span class="toc-text">3-shell函数的特殊特点，例如和python对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-shell%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">4-shell常用的命令有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-shell%E5%A6%82%E4%BD%95%E8%AE%B0%E5%BD%95%E6%89%A7%E8%A1%8C%E6%97%A5%E5%BF%97"><span class="toc-text">5-shell如何记录执行日志</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91"><span class="toc-text">测试开发</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/01/26/%E7%A7%8B%E6%8B%9B%E5%B0%8F%E7%BB%93/" title="秋招小结"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="秋招小结"/></a><div class="content"><a class="title" href="/2025/01/26/%E7%A7%8B%E6%8B%9B%E5%B0%8F%E7%BB%93/" title="秋招小结">秋招小结</a><time datetime="2025-01-26T14:24:22.000Z" title="发表于 2025-01-26 22:24:22">2025-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/26/JOB-md/" title="八股文更新"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="八股文更新"/></a><div class="content"><a class="title" href="/2025/01/26/JOB-md/" title="八股文更新">八股文更新</a><time datetime="2025-01-26T08:48:54.000Z" title="发表于 2025-01-26 16:48:54">2025-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/12/%E5%85%AB%E8%82%A1%E6%96%87/" title="八股文"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="八股文"/></a><div class="content"><a class="title" href="/2024/08/12/%E5%85%AB%E8%82%A1%E6%96%87/" title="八股文">八股文</a><time datetime="2024-08-12T08:13:45.000Z" title="发表于 2024-08-12 16:13:45">2024-08-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/12/hello-world/" title="Hello World"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/2024/08/12/hello-world/" title="Hello World">Hello World</a><time datetime="2024-08-12T05:33:15.817Z" title="发表于 2024-08-12 13:33:15">2024-08-12</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By 梦境引导者</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天" style="display:none"><i class="fas fa-message"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const initValine = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyValine = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const valineConfig = {
      el: '#vcomment',
      appId: 'MfVX9yNzASBZAanH8f3MMbOY-gzGzoHsz',
      appKey: 'J4MjNn3mKklife68c7SB50qv',
      avatar: 'monsterid',
      serverURLs: 'https://mfvx9ynz.lc-cn-n1-shared.com',
      emojiMaps: {"tv_��ͷ":"bb_annoyed.png","tv_����":"0d15c7e2ee58e935adc6a7193ee042388adc22af.png","tv_͵Ц":"bb_awkward.png","tv_�ټ�":"bb_bye.png","tv_��Į":"b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png","tv_��ŭ":"34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png","tv_�ɰ�":"9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png","tv_��Ѫ":"09dd16a7aa59b77baa1155d47484409624470c77.png","tv_��":"241ee304e44c0af029adceb294399391e4737ef2.png","tv_Ż��":"9f996894a39e282ccf5e66856af49483f81870f3.png","tv_��Ц":"1f0b87f731a671079842116e0991c91c2c88645a.png","tv_���":"23269aeb35f99daee28dda129676f6e9ea87934f.png","tv_ί��":"d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png","tv_΢Ц":"70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png","tv_˼��":"90cf159733e558137ed20aa04d09964436f618a1.png"},
      visitor: false,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || window.location.pathname
    }

    new Valine(valineConfig)
  }

  const loadValine = async (el, path) => {
    if (typeof Valine === 'function') {
      initValine(el, path)
    } else {
      await btf.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js')
      initValine(el, path)
    }
  }

  if (isShuoshuo) {
    'Valine' === 'Valine'
      ? window.shuoshuoComment = { loadComment: loadValine }
      : window.loadOtherComment = loadValine
    return
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script>(() => {
  window.ChatraID = 'RWBaTkpoJ8EN3zZGE'
  window.Chatra = window.Chatra || function() {
    (window.Chatra.q = window.Chatra.q || []).push(arguments)
  }

  btf.getScript('https://call.chatra.io/chatra.js').then(() => {
    const isChatBtn = true
    const isChatHideShow = true

    if (isChatBtn) {
      const close = () => {
        Chatra('minimizeWidget')
        Chatra('hide')
      }

      const open = () => {
        Chatra('openChat', true)
        Chatra('show')
      }

      window.ChatraSetup = { startHidden: true }
    
      window.chatBtnFn = () => document.getElementById('chatra').classList.contains('chatra--expanded') ? close() : open()

      document.getElementById('chat-btn').style.display = 'block'
    } else if (isChatHideShow) {
      window.chatBtn = {
        hide: () => Chatra('hide'),
        show: () => Chatra('show')
      }
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="placeholder" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>